<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style type="text/css">body{
margin:40px auto;
max-width:650px;
line-height:1.6;
font-size:18px;
color:#888;
background-color:#111;
padding:0 10px
}
h1,h2,h3{line-height:1.2}
a:link {color: #999;}
a:visited {color: #666;}
pre {
    background-color:#1D2B53;
    color: #aaa;
}
</style></head>
<body><h2>Pico-8 Wikia</h2>The wiki for PICO-8, the fantasy programmable game console by Lexaloffe Games.

<mainpage-leftcolumn-start /><h4>Welcome to the PICO-8 Wiki</h4>[[Pico8|PICO-8]] by [[LexaloffleGames|Lexaloffle Games]] is a fantasy programmable game console for making, sharing, and playing tiny games and other computer programs (cartridges, or "carts"). The console provides simple built-in tools for creating your own cartridges.<h4>Quick links</h4><ul><li>Getting started<ul><li>[[Pico8|What is PICO-8?]] ([http://www.lexaloffle.com/pico-8.php official home page])</li><li>[[PlayingGames|How to play games]]</li><li>[[GettingStarted|Getting started making games]]</li><li>[[:Category:Tutorials|Tutorials category]]</li></ul></li></ul><ul><li>Community<ul><li>[[Forum|Forum (BBS)]] ([http://www.lexaloffle.com/bbs/?cat=7 direct link])</li><li>[[Pico8Slack|PICO-8 Slack]]</li><li>[[IRC]]</li><li>[[Pico8Zine|PICO-8 Zine]]</li><li>[[:Category:Community|Community category]]</li></ul></li></ul><ul><li>Reference<ul><li>[[CommandReference|Commands]]</li><li>[[APIReference|APIs]]</li><li>[[Lua]]</li><li>[[Memory]]</li><li>[[Configuration]]</li><li>[[RunningPico8|Running PICO-8]]</li><li>[[:Category:Reference|Reference category]]</li></ul></li></ul><h4>Categories</h4><ul><li>[[:Category:Tutorials|Tutorials]]</li><li>[[:Category:Code snippets|Code snippets]]</li><li>[[:Category:Games|Games]]</li><li>[[:Category:Community|Community]]</li><li>[[:Category:Tools|Tools]]</li><li>[[:Category:Reference|Reference]]<ul><li>[[:Category:API|API]]</li><li>[[:Category:Command|Command]]</li></ul></li></ul><mainpage-endcolumn />

<mainpage-rightcolumn-start /><h4>Latest activity</h4><activityfeed></activityfeed>

<mainpage-endcolumn />

[[zh:]]
<hr style="height: 0.0625em;background-color: #888;" /><h2>Main Page</h2>#REDIRECT [[Pico-8 Wikia]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Draw zoomed sprite (zspr)</h2><span style="font-size:14px;">I find the syntax of <span style="font-weight:bold;">sspr</span> involves too much work, so I wrote a wrapper function that requires less arguments and less thinking. So... </span>

<span style="font-size:14px;"><span style="font-weight:bold;">zspr</span></span>

<span style="font-size:14px;">Arguments:</span>

<span style="font-size:14px;">--n: standard sprite number</span>

<span style="font-size:14px;">--w: number of sprite blocks wide to grab</span>

<span style="font-size:14px;">--h: number of sprite blocks high to grab</span>

<span style="font-size:14px;">--dx: destination x coordinate</span>

<span style="font-size:14px;">--dy: destination y coordinate</span>

<span style="font-size:14px;">--dz: destination scale/zoom factor</span>

<span style="font-size:14px;">
</span><pre> <span style="font-size:14px;">function zspr(n,w,h,dx,dy,dz)</span>

<span style="font-size:14px;">  sx = 8 * (n % 16)</span>

<span style="font-size:14px;">  sy = 8 * flr(n / 16)</span>

<span style="font-size:14px;">  sw = 8 * w</span>

<span style="font-size:14px;">  sh = 8 * h</span>

<span style="font-size:14px;">  dw = sw * dz</span>

<span style="font-size:14px;">  dh = sh * dz</span>



<span style="font-size:14px;">  sspr(sx,sy,sw,sh, dx,dy,dw,dh)</span>

<span style="font-size:14px;">end</span></pre><hr style="height: 0.0625em;background-color: #888;" /><h2>Draw zoomed sprite</h2>#REDIRECT [[Pico-8 Wikia:Zspr: draw zoomed sprite]]<hr style="height: 0.0625em;background-color: #888;" /><h2>PICO-8 Wiki:Zspr: draw zoomed sprite</h2>#REDIRECT [[Draw zoomed sprite (zspr)]]<hr style="height: 0.0625em;background-color: #888;" /><h2>The Tower of Archeos</h2>{{Game|title = Tower of Archeos|imagecaption = Logo|first = Benjamin Soulé|second = Puzzle|third = One|image = Tower_of_Archeos_Logo.png|imagewidth = 224}}<h4>Description</h4>Climb the Tower of Archeos and kill the evil sorceror!<h4>Rules</h4><ul><li>Attack a group of the same kind of monsters!</li><li>Monsters will retaliate, but group size does not affect final damage, so try to destroy large groups first.</li><li>When your XP reaches 0, your health and items are refilled, and you also gain another heart slot.</li><li>Blocked doors and chests can be opened by killing monsters that are next to it.</li><li>To go up a floor, you need to go through a door.</li><li>Reach the 8th level to fight Archeon, the evil sorceror!</li></ul><h4>Controls</h4><ul><li>Use the Up/Down/Left/Right to move the Cursor.</li><li>Use the Z button to attack/go through doors/grab items.</li><li>Use the X Button to enter or leave your inventory.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Multiple States System</h2><h4>Description</h4>Ever wanted a Title Screen or a Menu?

This guide can show you how to manage multiple states at the same time!

<span style="font-style:italic;">Note:</span> For examplatory purposes, we'll be using the prefixes "game" and "title" for this tutorial.<h4>Instructions</h4><h5><nowiki/></h5><h5>Initializing</h5>The function "_init()" is what happens when the game is started up (or in this case, the State).

<pre>
function _init()
  titleinit() -- does title things.
end

function titleinit()
  mode = 0
  --whatever you wish to do when the title starts up.
end

function gameinit()
  mode = 1
  --what to do at the start of the play session.
end
</pre>

We'll call on gameinit() later.<h5>Updating</h5>The function "_update()" is where gameplay elements are changed (like a timer).

<pre>
function _update()
  if (mode == 0) then --Title Screen mode
    titleupdate()
  else
    gameupdate()
  end
end

function titleupdate()
  --Example "Press Z to start"
  --if btn(4,0) then
  --  gameinit()
  --end
end

function gameupdate()
  --gameplay elements (or whatever used to be in _update) goes here.
end
</pre>

The example given can be used by simply getting rid of the dashes (or rather uncommenting it).<h5>Drawing</h5>The function "_draw()" is called to draw things to the screen. (There's some repetition in this one.)

<pre>
function _draw()
  if (mode == 0) then --Tit
    titledraw()
  else
    gamedraw()
  end
end

function titledraw()
  --Example "Title"
  --print("Super Cool Game")
end

function gamedraw()
  --the screen drawing mechanisms(or whatever used to be in _draw) goes here.
end
</pre><h4>Notes</h4>- If you want to add more to "_draw" or "_update", simply follow this guideline:
<pre>
else if (mode == 2) then
    --optiondraw() or optionupdate()
</pre>
just be sure to put that before the else statement!
<hr style="height: 0.0625em;background-color: #888;" /><h2>Known Bugs</h2>Little wrinkles in PICO-8's language implementation.<h5>Overflow and Distance Calculations</h5>Pico-8's numbers are 16.16 fixed point, with a maximum integer value of 32767. This means it's quite easy to overflow numbers when squaring for distance calculations: 181^2==32761, almost overflowing, so even pixels two screens away will overflow a naive distance calculation. One workaround is to move the fixed point artificially, like this:

<pre>
-- works with x,y up to +/-8191
-- and distance up to 11584 by
-- sacrificing some precision
function dist(x0,y0,x1,y1)
  -- scale inputs down by 6 bits
  local dx=(x0-x1)/64
  local dy=(y0-y1)/64
  
  -- get distance squared
  local dsq=dx*dx+dy*dy
  
  -- in case of overflow/wrap
  if(dsq<0) return 32767.99999
  
  -- scale output back up by 6 bits
  return sqrt(dsq)*64
end
</pre>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Informative BBS links</h2>#REDIRECT [[Memory]]__STATICREDIRECT__<hr style="height: 0.0625em;background-color: #888;" /><h2>Random tips</h2>#REDIRECT [[Rnd]]
__STATICREDIRECT__<hr style="height: 0.0625em;background-color: #888;" /><h2>Best practices</h2><h5>External links</h5><ul><li>[http://blog.jvscott.net/post/128051478244/clear-code Clear code] (and [http://www.lexaloffle.com/bbs/?tid=2508 BBS thread]), and series of primers on good code practices with examples from the PICO-8 Fanzine</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Pico-8 memory layout</h2>#REDIRECT [[Memory]]__STATICREDIRECT__<hr style="height: 0.0625em;background-color: #888;" /><h2>PICO-8 Wiki:Administrators</h2><hr style="height: 0.0625em;background-color: #888;" /><h2>Picotool</h2>picotool is a suite of tools and a Python library for manipulating PICO-8 cartridges.<ul><li>[https://github.com/dansanderson/picotool picotool] on Github</li></ul>The tool suite includes commands for gathering statistics, inspecting contents, minifying or formatting Lua code, and searching for strings in the Lua code of multiple carts. The tools can read .p8.png carts as well as .p8 carts.

The picotool library can read .p8 and .p8.png cartridges, and can save .p8 cartridges. It includes a full Lua parser tailored to match PICO-8, with Python access to the token stream and AST. Other libraries provide read/write access to graphics, music, and sound data, as well as arbitrary access to cartridge binary data.

The p8upsidedown tech demo uses the picotool library to invert a cartridge's graphics, map, music, and controls so that the cart plays upside down. This demo modified both the data and the code to accomplish this effect.
<hr style="height: 0.0625em;background-color: #888;" /><h2>Centering Text</h2><pre>
textlabel="this is some cool text!!!"

function hcenter(s)
  -- screen center minus the
  -- string length times the 
  -- pixels in a char's width,
  -- cut in half
  return 64-#s*2
end

function vcenter(s)
  -- screen center minus the
  -- string height in pixels,
  -- cut in half
  return 61
end

function _draw()
  cls()
  print(textlabel,hcenter(textlabel),vcenter(textlabel),8)
end
</pre>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Spr</h2>{{ApiReference
|name=spr
|shortdesc=Draws a sprite, or a range of sprites, on the screen.
|n||The sprite number. When drawing a range of sprites, this is the upper-left corner.
|x||The x coordinate.
|y||The y coordinate.
|w|optional|The width of the range, as a number of sprites. Non-integer values may be used to draw partial sprites. The default is 1.0.
|h|optional|The height of the range, as a number of sprites. Non-integer values may be used to draw partial sprites. The default is 1.0.
|flip_x|optional|If <code>true</code>, the sprite is drawn inverted left to right. The default is <code>false</code>.
|flip_y|optional|If <code>true</code>, the sprite is drawn inverted top to bottom. The default is <code>false</code>.
}}
This operation is affected by the [[DrawState|draw state]].<h4>Examples</h4><pre>
-- draw sprite 1 (1x1) at (60, 60) 
spr(1, 60, 60)

-- draw sprite 1 (1x1) at (72, 60), flipped vertically
spr(1, 72, 60, 1, 1, false, true)

-- draw the top-left quarter of sprite 1 at (72, 60)
spr(1, 72, 60, 0.5, 0.5)

-- draw sprite range starting at sprite 16, 3 wide 2 high, at (20, 52)
spr(16, 20, 52, 3, 2)
</pre>
[[File:Spr ex1.png|thumb|center|220x220px|alt=The spr function in action.]]
[[File:Spr ex1 sprites.png|thumb|center|216x216px|alt=The sprite sheet used in this example.]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Sspr|<code>sspr()</code>]]</li><li>[[Pal|<code>pal()</code>]]</li><li>[[Palt|<code>palt()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Load</h2>{{CommandReference
|name=load
|shortdesc=Loads a cartridge.
|filename||The name of the cartridge file, a BBS cart ID (<code>#1234</code>), or <code>@clip</code> to load a cartridge from the system clipboard copied from the BBS.
|breadcrumb|optional|When called from within a cart with this parameter, this adds an item to the pause menu to return to the original cart.
|param|optional|An arbitrary string value that can be accessed by the loaded cart using <code>stat(6)</code>.
}}
When this system command is executed at the PICO-8 prompt, the cart currently in memory is erased and replaced with the loaded cart.

When called as a function (<code>load('filename')</code>), the loaded cart completely replaces the current cart in memory and begins executing immediately.

If a "breadcrumb" string is provided, a menu option with that text is added to the pause menu of the new cart that reloads the original cart. No state is preserved when following the breadcrumb: the cart is loaded and run from the beginning. The loaded cart can access this string programmatically using <code>stat(100)</code>. (See [[Stat|stat]].)

If a "param" string is provided, the loaded cart can access this string value using <code>stat(6)</code>. This can be used to pass arbitrary values to loaded carts.

Data can also be passed to and from loaded carts via the [[Memory#General use|general use memory region]].

PICO-8 can load cartridges in <code>.p8</code> format or <code>.p8.png</code> format. If the filename is specified without an extension, PICO-8 assumes <code>.p8</code>, even if another file ending in <code>.p8.png</code> exists.

If the filename is <code>#nnn</code> where <code>nnn</code> is a number, it loads the cart with that ID from the [[Forum|PICO-8 forum]]. (This requires a connection to the Internet.) The ID can also be for the forum post containing the cart. Only local carts and carts loaded from the forum can load carts from the forum, not carts running in standalone players created through [[Export|export]].

If the filename is <code>@clip</code>, PICO-8 attempts to load the contents of the system clipboard as a cartridge. The value on the clipboard must be in the format used by <code>[[Save|save @clip]]</code>. This is the same format provided by the "Copy" feature of the PICO-8 BBS, meaning cartridges can quickly be transferred from BBS posts into the PICO-8 app.<h4>Examples</h4>At the PICO-8 prompt:
<pre>
> load demos/jelpi.p8
</pre>

Loading from the clipboard:
<pre>
> load @clip
</pre>

Loading from the forum (network connection required):
<pre>
> load #1234
</pre>

In source code:
<pre>
-- load a cart
load('demos/jelpi.p8')
</pre>

In source code with a breadcrumb menu item back to the original cart:
<pre>
load('demos/jelpi.p8', 'back to menu')
</pre><h4>See also</h4><ul><li>[[Save|save]]</li><li>[[Folder|folder]]</li><li>[[Ls|ls]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Save</h2>{{CommandReference
|name=save
|shortdesc=Saves the current cartridge to a file.
|filename|optional|The name of the cartridge file. If this is <code>@clip</code>, the cartridge data is copied to the system clipboard instead of saved to a file.
}}
If the filename ends in <code>.p8</code>, the file will use the <code>.p8</code> file format. This file includes the source code, sprites, map, sound effects, and music data.

If the filename ends in <code>.p8.png</code>, the file will use the <code>.p8.png</code> file format. The PNG image looks like a game cartridge, including a label with a screenshot and title.

If you use <code>@clip</code> as the filename, PICO-8 will save the contents of the cartridge to the system clipboard instead of to a file.

If the filename doesn't have an extension, PICO-8 will automatically add <code>.p8</code>.<h4>Setting the label</h4>When saving as a <code>.p8.png</code> file, PICO-8 generates a cartridge label. This label can include two lines of text and a screenshot image.

To set the text of the label, put two lines of comments at the top of the source code:

<pre>
-- game title
-- by author name
</pre>

To set the screenshot, run the game, then press F7 to take the current image. The label will use the most recent screenshot when you save the cartridge.<h4>The compressed code size limit</h4>PICO-8 uses compression to reduce the size of the source code when saving as a <code>.p8.png</code> file. The compressed code size must be under a certain limit (15,360 bytes) for the save to succeed. Use [[Info|the info command]] to see how the code size compares to this limit. If you save to a <code>.p8.png</code> file and the compressed size exceeds the limit, PICO-8 prints an error message.

You can save and load a cartridge whose compressed code size exceeds the limit using a <code>.p8</code> file. This allows you to save your program in progress before reducing its code size for publishing as a <code>.p8.png</code>, if necessary.<h4>Saving to the system clipboard</h4>You can save the contents of the cartridge to the system clipboard by specifying a filename of <code>@clip</code>:

<pre>
> save @clip
</pre>

The format of this value is designed to be pasted into a PICO-8 BBS message. It is delimited with <code>[code]...[/code]</code> and contains a hexadecimal representation of the cartridge. (This is *not* the same format as a <code>.p8</code> file.) When you paste this into a BBS message, it is replaced with the cartridge running in the web player when the message is viewed.<h4>Examples</h4>At the PICO-8 prompt:
<pre>
> save                 -- saves to the last file loaded or saved

> save mygame          -- saves to "mygame.p8"

> save mygame.p8       -- saves to "mygame.p8"

> save mygame.p8.png   -- saves to "mygame.p8.png" in image-encoded format

> save @clip           -- saves to clipboard in text-encoded format
</pre><h4>See also</h4><ul><li>[[Load|load]]</li><li>[[Folder|folder]]</li><li>[[Cd|cd]]</li><li>[[Info|info]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Folder</h2>{{CommandReference
|name=folder
|shortdesc=Opens the PICO-8 cartridge folder in the host operating system.
}}
When you execute this system command at the PICO-8 prompt, your operating system's file browser opens a window showing the files and folders in the cartridge storage area. You can copy files in and out of this area to make them available to PICO-8.<h4>Examples</h4>At the PICO-8 prompt:
<pre>
> folder
</pre><h4>See also</h4><ul><li>[[Load|load]]</li><li>[[Save|save]]</li><li>[[Ls|ls]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Ls</h2>{{CommandReference
|name=ls
|shortdesc=Lists the files in the current working directory of the cartridge storage area.
}}
You execute this system command at the PICO-8 prompt.

Unlike the <code>ls</code> command of some operating systems, this command does not take arguments. To see the contents of a directory (folder) in the cartridge storage area, first use [[Cd|the cd command]] to change the current working directory, then use <code>ls</code>.

<code>dir</code> is an alias for this command.

This command can also be used by a program as a function: <code>ls()</code> The return value is a table of filenames. This returns the names of files only, and does not return subdirectories.<h4>Examples</h4>At the command prompt:
<pre>
> cd demos
> ls
</pre>

In code:
<pre>
-- get the list of files
files = ls()
</pre><h4>See also</h4><ul><li>[[Cd|cd]]</li><li>[[Folder|folder]]</li><li>[[Load|load]]</li><li>[[Save|save]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Run</h2>{{ApiReference
|name=run [str]<br /><br />run
|shortdesc=Runs the current cartridge from the start of the program.
|str|optional|A "breadcrumb" string, as if passed by a calling cartridge.
}}
When run as a system command at the PICO-8 prompt, this starts the program. If the program was running previously, <code>run</code> resets the game state and starts from the beginning.

When called as a function in code (<code>run()</code>), the runtime environment resets and the program executes from the beginning.

A string may be passed as a "breadcrumb" that the cartridge can find in <code>stat(6)</code>. Breadcrumbs are usually used when one cartridge loads another and wishes to tell the other where it came from. This is a way to simulate that, or to retain the existing breadcrumb if the cartridge chooses to re-run itself.<h4>Examples</h4>At the PICO-8 prompt:
<pre>
> run

> run this is my breadcrumb

> run "this is my breadcrumb"
</pre>
Note that quotes are optional and both of the latter examples produce the same result.

In source code:
<pre>
-- reset the program
run()

-- reset the program with a breadcrumb
run("this is my breadcrumb")

-- reset the program and preserve the current breadcrumb
run(stat(6))
</pre><h4>See also</h4><ul><li>[[Resume|resume]]</li><li>[[Reboot|reboot]]</li><li>[[Shutdown|shutdown]]</li><li>[[Stat|<code>stat()</code>]]</li></ul>

<hr style="height: 0.0625em;background-color: #888;" /><h2>Resume</h2>{{CommandReference
|name=resume
|shortdesc=Resumes execution of an interrupted program.
}}
You execute this system command at the PICO-8 prompt.

The <code>resume</code> command resumes execution of a program interrupted by the player pressing the Escape key or the program calling [[Stop|stop()]].

This command only works if the program uses the [[GameLoop|game loop]]. It does <span style="font-style:italic;">not</span> resume from the place in the code where the program was interrupted. Instead, it starts a new frame by calling [[Update|_update()]].

The PICO-8 manual describes this command as "flaky." Some carts may have difficulty resuming from an interrupted state because the code that was interrupted may have left global variables in an inconsistent state.<h4>Examples</h4><pre>
> resume
</pre><h4>See also</h4><ul><li>[[Run|run]]</li><li>[[Reboot|reboot]]</li><li>[[Stop|stop]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Reboot</h2>{{CommandReference
|name=reboot
|shortdesc=Reboots PICO-8, erasing all cartridge data and state from memory.
}}
Executing this command from the PICO-8 prompt is the easiest way to reset cartridge data for a new project.<h4>Examples</h4><pre>
> reboot
</pre><h4>See also</h4><ul><li>[[Load|load]]</li><li>[[Save|save]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Stat</h2>{{ApiReference
|name=stat
|shortdesc=Returns information about the current runtime environment.
|n||The ID of the information to return. (See below.)
}}
The <code>stat()</code> function returns information about the current runtime environment. Each kind of information has an ID (a number), described below.

You can display this metric on the game screen with [[Print|<code>print()</code>]], write it to the console with [[Printh|<code>printh()</code>]], or perhaps use it some other way to adjust the behavior of your program.<h4>{0…2} Memory and CPU usage</h4><code>stat(0)</code> returns the [[Memory#Lua Memory|memory]] usage:<ul><li>This number is in [[KiB]]. 1 would represent 1024 bytes allocated. The fractional portion is accurate, so 1.875 would represent 1920 bytes.</li><li>Accounts for all Lua data, such as variables and tables.</li><li>Ranges from 0 to 2048. (As of 0.1.11g, Lua is allowed up to 2 [[MiB]] of data.)</li><li>Does not include [[Peek|<code>peek()</code>]]/[[Poke|<code>poke()</code>]]-able RAM such as sprite or video RAM.</li><li>Does not include cartridge ROM.</li></ul><code>stat(1)</code> returns the total [[CPU]] usage:<ul><li>Begins at 0 at the start of the first [[Update|<code>_update()</code>]] after the most recent [[Draw|<code>_draw()</code>]].</li><li>Progresses towards 1 as it nears time for the next frame to begin. Therefore, 1 would represent 1/30s elapsed when using [[Update|<code>_update()</code>]], or 1/60s for [[Update60|<code>_update60()</code>]].</li><li>A value higher than 1 indicates that the program has gone over its processing budget for code and drawing this frame. Frames may be dropped to compensate, or overall execution may be slowed.</li></ul><code>stat(2)</code> returns the system [[CPU]] usage:<ul><li>This number uses the same range and behavior as <code>stat(1)</code>.</li><li>This number only increases while work is being done in unseen code. For instance, clearing the screen about 70 times would push <code>stat(2)</code> past 1.0. Almost all of the work would be done inside of calls to [[Cls|<code>cls()</code>]], which is a system call. However, spending the whole frame calculating pi wouldn't budge <code>stat(2)</code>, because it wouldn't involve any system calls.</li></ul><h4>{3} Unknown</h4><code>stat(3)</code> returns a number, 0 at the time of writing, whose purpose is unknown.<h4>{4} Clipboard contents</h4>The system clipboard contents can be found in <code>stat(4)</code>, as a string.

See [[Clipboard#Reading the clipboard with Lua|Clipboard]] for full details on usage and limitations.<h4>{5} PICO-8 version</h4>The running PICO-8 version ID can be found in <code>stat(5)</code>, as a number.

This is the same number as the "version" ID in the p8 file. (e.g. 16 for 0.1.11g)<h4>{6} Parameter string from a third-party load</h4>When a cart calls [[Load|<code>load()</code>]] to load another cart, it can provide an arbitrary string as the third argument. This string is accessible to the loaded cart by calling <code>stat(6)</code>. If PICO-8 is run from the command line, the -p flag can be used to provide this argument instead.

If the load() call also included a breadcrumb string, the loaded cart can access this with <code>stat(100)</code>.<h4>{7} Frame rate</h4><code>stat(7)</code> returns the current frame rate, as the number of frames rendered per second.

Specifically, the frame rate is the number of times per second PICO-8 is able to call the game's [[Draw|<code>_draw()</code>]] function in the game loop (if provided), or the number of times the game calls [[Flip|<code>flip()</code>]]. When using the game loop, the expected frame rate is 30 frames per second (fps) with an [[Update|<code>_update()</code>]] function or 60 fps with an <code>_update60()</code> function, but may be fewer if the draw or update functions take too long and PICO-8 skips <code>_draw()</code> calls to catch up. This makes frame rate an interesting measure of game performance for games that do a lot of calculation between frames.<h4>{8} Target frame rate</h4><code>stat(8)</code> returns the intended frame rate of the system, currently either 30 or 60. See [[Update|<code>_update()</code>]] for more details on how to choose one or the other.<h4>{9} PICO-8 frame rate</h4><code>stat(9)</code> appears to return the number of times the PICO-8 application itself has updated in the last second. This will tend to be similar to the refresh rate of the physical display, but may vary with system load. It is independent of the current game's update rate. If you configure PICO-8 to show an FPS indicator, this is the value being shown.<h4>{10…11} Unknown</h4><code>stat(10…11)</code> returns a number, 0 at the time of writing, whose purpose is unknown.<h4>{12…15} Pause menu location</h4><code>stat(12)</code> through <code>stat(15)</code> represents the coordinate position of the pause menu if the player were to pause the game at that moment, as the x and y coordinates of the upper left corner and bottom right corner, respectively.

Various things determine the contents of the pause menu dynamically, including [[Menuitem|<code>menuitem()</code>]] calls, [[Load|<code>load()</code>]] parameters, whether the game was loaded with [[Splore]], and possible future extensions. PICO-8 calculates the size and position of the menu based on its contents.<h4>{16…26} Sound and music status</h4><code>stat(16)</code> through <code>stat(19)</code> return the index of the sound effect currently playing on the four channels, respectively. If no sound is playing on the channel, <code>stat()</code> returns -1.

<code>stat(20)</code> through <code>stat(23)</code> return the note number (0 through 31) of the sound effect currently playing on the four channels, respectively. If no sound is playing on the channel, <code>stat()</code> returns -1.

[http://www.lexaloffle.com/bbs/?tid=1925 From zep]: "Note that the row number may not be very precise depending on what is going on with the host operating system's audio mixer. Also in the case of the web player which needs to have a large mixing buffer, the result is often slightly earlier that what is audible."

<code>stat(24)</code> is the music pattern ID currently being played, as a result of the most recent call to [[Music|<code>music()</code>]].:'''Caution:''' There is a bug in PICO-8 versions prior to 0.1.12: If no music is currently playing, an ID of 0 will be returned instead of -1, but this does not mean music pattern 0 is actively playing. In affected versions, workarounds like checking <code>stat(25)</code> are necessary to detect whether music is actually playing.<code>stat(25)</code> is the number of music patterns played since the most recent call to [[Music|<code>music()</code>]].

<code>stat(26)</code> is the number of ticks (notes or rests) played on the current pattern.<h4>{27…29} Unknown</h4><code>stat(27…29)</code> returns a number, 0 at the time of writing, whose purpose is unknown.<h4>{30…36} Mouse and keyboard in "devkit mode"</h4>From inside a cart, "devkit mode" can be enabled for platforms that have mouse and keyboard attached:

<pre>
poke(0x5f2d, 1)
</pre>

Once enabled, <code>stat(...)</code> can be used to read mouse and keyboard values:<ul><li><code>stat(30)</code> -> <code>true</code> if a keypress is in <code>stat(31)</code>, <code>false</code> otherwise</li><li><code>stat(31)</code> -> the key being pressed, as a string</li><li><code>stat(32)</code> -> mouse X coord</li><li><code>stat(33)</code> -> mouse Y coord</li><li><code>stat(34)</code> -> mouse button bitmask (1=primary, 2=secondary, 4=middle)</li><li><code>stat(35)</code> -> (unknown, returns 0 in testing)</li><li><code>stat(36)</code> -> mouse wheel delta since previous update</li></ul>When the user presses one or more keys, PICO-8 sets <code>stat(30)</code> to <code>true</code>, and then sets <code>stat(31)</code> to the next keypress to be read. When the application sees <code>stat(30)</code> is <code>true</code> and reads the keypress via <code>stat(31)</code>, PICO-8 will then refresh the value of both stats, based on whether or not there are more keypresses remaining to be reported. This can be checked multiple times per frame to fully read all keys pressed since last frame.

An example of reading the keyboard:

<pre>
function _update()
  while stat(30) do
    handle_keypress(stat(31))
  end
end
</pre>

Some special keys can be detected using these standard [https://www.lua.org/pil/2.4.html Lua escape sequences]::{| class="article-table"!scope="col"|Key
!scope="col"|Sequence
!scope="col"|Notes
|-
|<kbd>Backspace</kbd>
|<code>"\b"</code>
|
|-
|<kbd>Enter</kbd>
|<code>"\r"</code>
|By default, <kbd>Enter</kbd> and <kbd>P</kbd> bring up the pause menu. If either is detected, [[Memory|<code>poke(0x5f30,1)</code>]] can be used to temporarily suppress this action.
|-
|<kbd>Esc</kbd>
|<code>"\27"</code> or <code>"\x1b"</code>
|Only seen when the user is exiting the pause menu or halting execution. Neither action can be suppressed.
|-
|<kbd>Tab</kbd>
|<code>"\t"</code>
|
|}

<span style="font-weight:bold;">Modifier keys:</span>

The <kbd>Shift</kbd> key is not reported separately. Instead, it changes the character that is returned from <code>stat(31)</code>. For instance, if the player presses <kbd>Shift</kbd>+<kbd>H</kbd>, a double-wide heart character will be returned. Other modifier keys are invisible to PICO-8 programs.

<span style="font-weight:bold;">Usage notes:</span>

Conceptually, PICO-8 is a small game console, similar to an NES or GameBoy. It may be running on a machine without a keyboard or mouse connected, such as a game cabinet with only game controllers, or even a small system-on-a-chip implementation with integrated controls. For that reason, this is referred to as "devkit mode", intended for debugging and tools. It's not forbidden to write games that use this mode, but games that do may find a limited audience.

If PICO-8 is running in a context where mouse and keyboard cannot be safely relied on (for instance, on the [[Forum|BBS]]), it will display a notice that devkit mode has been enabled. This is so the user will not be confused if they cannot control the game. This notice will come up the first time a relevant <code>stat()</code> is read; this knowledge can be used to make sure the notice will not obscure something important at a bad time.<h4>{48…71} Unknown</h4><ul><li><code>stat(48)</code> -> nil?</li><li><code>stat(49)</code> -> empty string?</li><li><code>stat(50..57)</code> -> nil?</li><li><code>stat(58..63)</code> -> empty string?</li><li><code>stat(64..71)</code> -> nil?</li></ul><h4>{80…85,90…95} Time of day</h4>A PICO-8 cart can access the current time of day, in the host system's local time zone:<ul><li><code>stat(90)</code> -> year, e.g. 2018</li><li><code>stat(91)</code> -> month of year, 1-12</li><li><code>stat(92)</code> -> day of month, 1-31</li><li><code>stat(93)</code> -> hour of day, 0-23</li><li><code>stat(94)</code> -> minute of hour, 0-59</li><li><code>stat(95)</code> -> second, 0-61 (usually 0-59, see note below)</li></ul>A corresponding set of values, but in UTC time, are available at <code>stat(80)</code> through  <code>stat(85)</code>.

<span style="font-style:italic;">Note: PICO-8 and/or Lua appear to be using the standard C [http://www.cplusplus.com/reference/ctime/tm/ <code>tm_time</code>] interface to provide these values, and as such, you should be aware that the current second is allowed to go past 59, to 60 or 61, in the event of [[Wikipedia:Leap_second|leap seconds]] occurring.</span><h4>{100…104} BBS information</h4>The following are not officially documented and mostly unknown, but all appear to be related to [[Forum|BBS]] functionality:<ul><li><code>stat(100)</code> -> Returns [[Load|breadcrumb]] label.</li><li><code>stat(101)</code> -> For BBS carts, <code>stat(101)</code> returns the current BBS ID. (per [https://twitter.com/lexaloffle/status/1007377500027084800 zep on Twitter])</li><li><code>stat(102)</code> -> For BBS carts, returns site (e.g. <code>"www.lexaloffle.com"</code>). For local carts, returns <code>0</code>.</li><li><code>stat(103)</code> -> Unknown, returns some kind of SHA1 hash (some kind of cart hash, maybe?)</li><li><code>stat(104)</code> -> Unknown, returns <code>false</code> in limited testing.</li><li><code>stat(105)</code> -> Unknown, returns <code>0</code> in limited testing.</li><li><code>stat(106)</code> -> Unknown, returns some other kind of SHA1 hash.</li><li><code>stat(107)</code> -> Unknown, returns <code>0</code> in limited testing.</li><li><code>stat(108)</code> -> Unknown, returns <code>0</code> in limited testing.</li><li><code>stat(109)</code> -> Unknown, returns 256 in limited testing.</li></ul>(If you know more details about any of these, please update this section.)<h4>Examples</h4><pre>
function _update()
  -- game update code...
end

function _draw()
  cls()

  -- game draw code...

  print('mem:'..stat(0), 0, 0, 7)
  print('cpu:'..stat(1), 0, 6, 7)
end
</pre><h4>See also</h4><ul><li>[[Update|<code>_update()</code>]]</li><li>[[Draw|<code>_draw()</code>]]</li><li>[[Flip|<code>flip()</code>]]</li><li>[[Load|<code>load()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Info</h2>{{CommandReference
|name=info
|shortdesc=Prints information about the cartridge currently loaded in memory.
}}
You execute this system command from the PICO-8 command prompt.

The command prints the current size of the source code relative to the code size limits, including the character count, the Lua token count, and the compressed byte count. If the code exceeds any of these limits, you will not be able to run the cart or save it in the <code>.p8.png</code> file format.

This command also prints the last known filename for the current cartridge, if any. This is the filename used when running the [[Save|save]] command without arguments, and used for detecting changes automatically when using an external editor.<h4>Examples</h4><pre>
> info
file: gta6.p8.png
tokens:       604 /  8192
chars:       5322 / 65535
compressed:  2657 / 15360
</pre><h4>See also</h4><ul><li>[[Save|save]]</li><li>[[Load|load]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Flip</h2>{{ApiReference
|name=flip
|shortdesc=Copies the graphics buffer to the screen, then synchronizes to the next frame at 30 frames per second.
}}
Carts that use the built-in game loop functions [[Update|_update()]] and [[Draw|_draw()]] do not need to call <code>flip()</code>. You can use <code>flip()</code> if you want to implement your own game loop and still synchronize to the 30 frames per second draw timer.

<span style="font-weight:bold;">Note:</span> If the [[Draw|_draw()]] game loop is not used by the program, PICO-8 will copy the graphics buffer to the screen 30 times per second automatically even if <code>flip()</code> is not called as often. <code>flip()</code> waits until the next frame has been copied, synchronizing program execution to the frame timer.<h4>Examples</h4><pre>
for x=4,124 do
  cls()
  circfill(x, x, 4, 8)
  flip()
end
</pre>

This example animates a circle moving diagonally across the screen, one pixel per frame for 120 frames (four seconds).

If you remove the call to <code>flip()</code>, this clears the graphics buffer and draws the circle 120 times, but the buffer is only copied to the screen when the program exits.<h4>See also</h4><ul><li>[[Update|<code>_update()</code>]]</li><li>[[Draw|<code>_draw()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Printh</h2>{{ApiReference
|name=printh
|shortdesc=Prints a string to a console window that is running PICO-8, or to a file or the clipboard.
|str||The string to print.
|filename|optional|The name of a file to append the output, instead of printing to the console. If this is the string <code>"@clip"</code>, the message replaces the contents of the system clipboard instead of writing to a file. 
|overwrite|optional|If <code>filename</code> is provided and is the name of a file and <code>overwrite</code> is <code>true</code>, this overwrites the file. The default is <code>false</code>, which appends the message to the end of the file.
}}

You can use <code>printh()</code> to emit debugging information without printing it on the PICO-8 display. It can emit this output to a command console window, to a file, or to the system clipboard.<h4>Running PICO-8 in a console window</h4>To see the output of <code>printh()</code> in a window, you must run PICO-8 from a command console. How to do this depends on which operating system you're using.<h5>Windows</h5>In Windows, instead of double-clicking the PICO-8 icon, open Command Prompt, then start PICO-8 with the following command:

<pre>
"\Program Files (x86)\PICO-8\pico8.exe"
</pre>

The prompt appears immediately, even though PICO-8 is running. <code>printh()</code> output will appear in this window anyway.

Alternatively, create a file in the same folder as <code>pico8.exe</code> named <code>pico8.bat</code> containing this line:

<pre>
cmd /k start pico8.exe
</pre>

When you double-click on this file, it opens a Command Prompt window and runs PICO-8. Messages appear in the window, and the window closes automatically when PICO-8 exits.<h5>Mac OS X</h5>In Mac OS X, instead of double-clicking the PICO-8 icon, open Terminal, then start PICO-8 with the following command, adjusting the path to match where you put the app. For example:

<pre>
/Applications/PICO-8.app/Contents/MacOS/pico8
</pre>
If you don't want to type that into your terminal every time, you can add an alias to your terminal configuration file. Open a terminal window, and type:
<pre>
nano ~/.bash_profile
</pre>
Then, paste the following (do not add any spaces between the = or it will not work!):
<pre>
alias pico8=/Applications/PICO-8.app/Contents/MacOS/pico8
</pre>
Save the file, logout and log back in. You will now be able to type pico8 in the terminal to open the program.<h5>Linux</h5>In Linux, you probably already run the <code>pico8</code> command from a terminal window. If you don't, locate where you put the <code>pico-8/</code> directory, then run the <code>pico8</code> command from a terminal window using its full path. For example:

<pre>
~/pico-8/pico8
</pre><h4>Writing to a file</h4>The <code>printh()</code> function accepts optional arguments that tell it to send its output to a file instead of to the console. This works even if PICO-8 was not invoked from a command console.

To append the message to a file, provide a filename as the second argument. This creates the file if it does not exist.

<pre>
printh('debug: score='..score, 'scores.txt')
</pre>

To overwrite an existing file instead of appending to it, provide <code>true</code> as the third argument:

<pre>
printh('scores', 'scores.txt', true)
printh('------', 'scores.txt')
</pre><h4>Writing to the system clipboard</h4>Writing to the special filename <code>'@clip'</code>, you can overwrite the system clipboard.

See [[Clipboard#Writing to the clipboard with Lua|Clipboard]] for full details.<h4>Examples</h4><pre>
t = 0

function _update()
  t = (t + 1) % 30
  printh('t = '..t)
end

function _draw()
  cls()
  circfill(t * 3, t * 3, 4, 8)
end
</pre><h4>See also</h4><ul><li>[[Print|<code>print()</code>]]</li><li>[[Stat|<code>stat()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Update</h2>The first part of a [[GameLoop|game loop]] is normally an <span style="font-style:italic;">update</span>.  In PICO-8, this is done with either an <code>_update()</code> function, for 30fps games, or <code>_update60()</code> for 60fps games.

If a cartridge's source code includes both an <code>_update()</code> function and a <code>_draw()</code> function, then PICO-8 will attempt to call these functions once for each animation frame, at a rate of 30 frames per second for <code>_update()</code> or 60 frames per second with with <code>_update60()</code>.

You define this function in your game's source code. It takes no arguments.

The intended purpose of <code>_update()</code> is to test for user inputs (button presses), perform all of the calculations to advance the state of the game, and update the game's data structures with the results. For example, you might compare the state of variables to see if the player's avatar is near an item during <code>_update()</code>. Typically, this function does not update the display, though it may initiate sound effects ([[Sfx|sfx()]]) and music ([[Music|music()]]).

See the entry on the [[GameLoop|game loop]].<h4>Examples</h4><pre>
player_x=64
player_y=100

function _update()
  if(btn(0)) player_x-=1
  if(btn(1)) player_x+=1
end
</pre><h4>See also</h4><ul><li>[[GameLoop|game loop]]</li><li><code>[[Init|_init()]]</code></li><li><code>[[Draw|_draw()]]</code></li><li>[[Stat|<code>stat()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Draw</h2>The <code>_draw()</code> function is the second part of the [[GameLoop|game loop]].

If a cartridge's source code includes both an <code>_update()</code> function and a <code>_draw()</code> function, then PICO-8 will attempt to call these functions once for each animation frame, at a rate of 30 frames per second (60 if <code>_update60()</code> is used.)

You define this function in your game's source code. It takes no arguments.

The intended purpose of <code>_draw()</code> is to draw the state of the game onto the screen, such as with calls to [[Map|map()]] and [[Spr|spr()]]. A typical <code>_draw()</code> function starts with a call to [[Cls|cls()]] to clear the screen then draws all of the game elements, but this is not required.

If <code>_update()</code> and <code>_draw()</code> together take longer than 1/30th of a second (or 1/60th with <code>_update60()</code>) to complete, PICO-8 may decide not to call <code>_draw()</code> for a given frame. See the entry on the [[GameLoop|game loop]].<h4>Examples</h4><pre>
function _draw()
  cls()
  print("hello, world!", rnd(76), rnd(124), rnd(15)+1)
end
</pre><h4>See also</h4><ul><li>[[GameLoop|Game loop]]</li><li>[[Init|<code>_init()</code>]]</li><li>[[Update|<code>_update()</code>]]</li><li>[[Stat|<code>stat()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Init</h2>The <code>_init()</code> function is called by PICO-8 to initialize a cartridge.

You define this function in your game's source code. It takes no arguments.

PICO-8 calls this function after evaluating all of the source code. In typical usage, a cartridge's source code includes definitions for functions and variables, an <code>_init()</code> function, and <code>_update()</code> and <code>_draw()</code> functions for the [[GameLoop|game loop]]. PICO-8 calls <code>_init()</code> once before starting the game loop.

If any code outside of functions has side effects, these effects occur before <code>_init()</code> is called. (This is trivial if the code consists only of function and global variable definitions.)<h4>Examples</h4><pre>
function _init()
  -- start player in lower center of screen
  player_x=64
  player_y=100
end
</pre><h4>See also</h4><ul><li>[[GameLoop|game loop]]</li><li>[[Update|<code>_update()</code>]]</li><li>[[Draw|<code>_draw()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Dir</h2>#REDIRECT [[Ls]]__STATICREDIRECT__<hr style="height: 0.0625em;background-color: #888;" /><h2>Cd</h2>{{CommandReference
|name=cd
|shortdesc=Changes the current working directory.
|path|optional|The path to the new working directory.
}}

PICO-8 [[CartridgeStorage|cartridge storage]] uses a hierarchical filesystem of directories that corresponds to that of the host operating system. Similar to other command shells, PICO-8 has a notion of a <span style="font-style:italic;">current working directory</span>, a location in this hierarchy where other commands that operate on files, like [[Save|save]] or [[Ls|ls]], perform an action.

When given an argument, the <code>cd</code> command changes the current working directory. The argument is a <span style="font-style:italic;">path</span> to the new directory, either a <span style="font-style:italic;">relative path</span> from the current working directory or an <span style="font-style:italic;">absolute path</span> from the root of the cartridge storage area. An absolute path begins with a forward slash (<code>/</code>) character. A relative path does not.

Paths use the forward slash (<code>/</code>) to separate directory names. This is true even if the host operating system uses a different path delimiter.

A relative path can use two dots (<code>..</code>) to indicate traversing to the parent directory.

When run without arguments, <code>cd</code> prints the current working directory's absolute path, and does not change it.<h4>Examples</h4>Consider a cartridge storage area with the following directories and files:
<pre>
/
  demos/
    api.p8
    jelpi.p8
  projects/
    helloworld/
      hello.p8
      hello2.p8
    squashy/
      squashy.p8
</pre>

From the PICO-8 command prompt:
<pre>
> cd demos
</pre>
The current working directory is now <code>/demos/</code>.

<pre>
> cd ..
</pre>
The current working directory is now <code>/</code>.

<pre>
> cd projects/squashy
</pre>
The current working directory is now <code>/projects/squashy/</code>.

<pre>
> cd ../helloworld
</pre>
The current working directory is now <code>/projects/helloworld/</code>.

<pre>
> cd /
</pre>
The current working directory is now <code>/</code>.

To print the current working directory:
<pre>
> cd
</pre><h4>See also</h4><ul><li>[[Ls|ls]]</li><li>[[Folder|folder]]</li><li>[[Mkdir|mkdir]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Mkdir</h2>{{CommandReference
|name=mkdir
|shortdesc=Creates a new directory.
|path||The path to the new directory.
}}

PICO-8's [[CartridgeStorage|cartridge storage]] uses a hierarchical filesystem of directories that corresponds to that of the host operating system. The <code>mkdir</code> command makes a new directory that can contain files and other directories.

The path can be a <span style="font-style:italic;">relative path</span> from the current working directory or an <span style="font-style:italic;">absolute path</span> from the root of the storage area. The last part of the path is the name of the new directory. The name must not already exist (as a directory or a file), and the rest of the path must be to a directory that exists. See [[Cd|cd]].

<span style="font-weight:bold;">Caution:</span> As of 0.1.6, the <code>mkdir</code> command does not report an error when the directory could not be created. Use the [[Ls|ls]] command to confirm that the directory was created successfully.

<span style="font-weight:bold;">Note:</span> There is no way to delete or rename a directory from the PICO-8 command prompt. If you're organizing your files, it's easier to use the [[folder]] command to open your operating system's file browser.<h4>Examples</h4><pre>
> cd /
> mkdir projects

> cd projects
> mkdir squashy

> cd /
> mkdir projects/squashy
</pre><h4>See also</h4><ul><li>[[CartridgeStorage|cartridge storage]]</li><li>[[Cd|cd]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Help</h2>{{CommandReference
|name=help
|shortdesc=Displays a brief message about available commands.
}}<h4>Examples</h4><pre>
> help
</pre><h4>See also</h4><ul><li>[[CommandReference|Command reference]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Splore</h2>{{CommandReference
|name=splore
|shortdesc=Activates the cartridge explorer.
}}
Splore is a graphical interface for exploring PICO-8 cartridges. You can use Splore to browse, search, and play cartridges published to the [[Forum|forum (BBS)]] directly over the Internet. You can also use Splore to navigate the [[CartridgeStorage|cartridge storage area]], with or without an Internet connection.

To activate Splore, run the <code>splore</code> command (or its abbreviation, <code>s</code>) from the PICO-8 command prompt.
[[File:Splore.png|thumb|center|220x220px|The Splore interface.]]

Select a cartridge to run it. To return to Splore from the running cart, press the <kbd>Esc</kbd> key to pause the cart and display the [[Pause menu|pause menu]], then select Splore.
[[File:Splore pause.png|thumb|center|220x220px|The Splore pause menu.]]

To return to the command prompt, press <kbd>Esc</kbd> from within the Splore interface.<h4>Saving carts locally</h4>When you select a published cartridge, PICO-8 downloads the cart, loads it into memory, and runs it. The cart is stored on your computer in a cache separate from the cartridge storage area.

To save the cart to the storage area:<ol><li>While the cart is running, press <kbd>Esc</kbd> to pause the cart.</li><li>Select <span style="font-weight:bold;">Splore</span> to return to the browse interface.</li><li>Press <kbd>Esc</kbd> again to exit Splore and return to the command prompt.</li><li>Use the [[Save|<code>save</code>]] command to save the cart.</li></ol>As usual, you can press <kbd>Esc</kbd> from the prompt to examine the contents of the cart.<h4>Examples</h4><pre>
> splore

> s
</pre><h4>See also</h4><ul><li>[[Forum|Forum (BBS)]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Shutdown</h2>{{CommandReference
|name=shutdown
|shortdesc=Quits PICO-8.
}}
The <code>shutdown</code> command closes the PICO-8 app.

<nowiki/><span style="font-weight:bold;">Caution:</span> PICO-8 will not warn you if you have unsaved changes. Be sure to save your work before quitting.<h4>Examples</h4><pre>
> shutdown
</pre><h4>See also</h4><ul><li>[[RunningPico8|Running PICO-8]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Export</h2>{{CommandReference
|name=export
|shortdesc=Exports the cartridge in various forms.
|filename||The filename to export, ending in <code>.html</code>, <code>.png</code>, or <code>.wav</code>.
}}
The <code>export</code> command serves several functions. It can be used to produce a standalone version of the cartridge that can be added to a website and played in a browser. It can also be used to generate a PNG image of the sprite sheet, or a WAV audio file of the sound effects or music.

Exported files are created in the current working directory of the [[CartridgeStorage|cartridge storage area]]. You can use the [[Folder|folder]] command to access this area with your operating system's file browser.<h4>Exporting a web player</h4><pre>
> export mygame.html
</pre>

To export the cartridge so it can be embedded in a website, use a filename that ends in <code>.html</code>. PICO-8 generates two files: an HTML file with this name, and a JavaScript file with a similar name and a <code>.js</code> extension.

The HTML file contains the code that adds the cart to the page along with control features. You can include this code in your website and modify it as needed.

The JS file contains the cartridge data and a standalone PICO-8 player that runs in a web browser. This file is referenced by the HTML file, and should not be changed.<h4>Exporting a desktop app</h4><pre>
> export mygame.bin
</pre>

To export the cartridge so it can be downloaded and played on Windows, Linux (64-bit), and macOS computers, use the <code>.bin</code> filename extension.

This creates a folder named <code>mygame.bin</code> containing a <code>windows/</code> subdirectory with the Windows files, a <code>linux/</code> subdirectory with the Linux files, and the <code>mygame.app</code> macOS bundle.

These are standalone versions of the game and do not require PICO-8 to play.<h4>Exporting the sprite sheet</h4><pre>
> export mygame_sprites.png
</pre>

To export the sprite sheet as a PNG file, use a filename that ends in <code>.png</code>. The image is 128 pixels wide and 128 pixels high, and uses the PICO-8 palette.

This file is suitable for importing into another cartridge with the [[Import|import]] command.

<span style="font-style:italic;">Note:</span> If the cartridge uses the bottom half of the sprite sheet for map data, this data will be included in the exported image. See [[Graphics]].<h4>Exporting sound effects</h4><pre>
> export mygame_sfx.wav

> export mygame_sfx_%d.wav
</pre>

To export the sound effects as WAV audio files, use a filename that ends in <code>.wav</code>.

The audio file contains each of the sound effects, one after another. To export each sound effect as a separate audio file, include <code>%d</code> somewhere in the filename, e.g. <code>mygame_sfx_%d.wav</code>. This will be replaced by the number of the sound effect (<code>mygame_sfx_01.wav</code>).

There is no way to import sound effects.<h4>Exporting music</h4><pre>
> export mygame_music.wav

> export mygame_music_%d.wav
</pre>

To export the music tracks as WAV audio files, make sure the music tab is open in the PICO-8 editor, press ESC, and then type the export command using a filename that ends in <code>.wav</code>.<h4>Examples</h4><pre>
> export mygame.html

> export mygame_sprites.png

> export mygame_sfx.wav
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Sound]]</li><li>[[Import|<code>import</code>]]</li><li>[[Save|<code>save</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Install demos</h2>{{CommandReference
|name=install_demos
|shortdesc=Installs the PICO-8 demo cartridges.
}}
This command creates a <code>demos/</code> subdirectory in the [[CartridgeStorage|cartridge storage area]] containing a collection of demonstration cartridges.

After these are created, you can use [[Splore|splore]] or the [[Load|load]] command to explore these carts.<h4>Examples</h4><pre>
> install_demos
</pre><h4>See also</h4><ul><li>[[Splore|splore]]</li><li>[[Cd|cd]]</li><li>[[Load|load]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Import</h2>{{CommandReference
|name=import
|shortdesc=Imports a PNG image file as sprite data.
|filename||The <code>.png</code> graphics file to import.
}}
This command imports a specially formatted PNG image file to be the sprite sheet for the current cartridge. The file must be 128 pixels wide, 128 pixels tall, and use the PICO-8 palette (otherwise the file will be clipped, and the colors will be set to the closest PICO-8 color).

To edit the sprite sheet in an external graphics editing program, use the [[Export|<code>export</code>]] command to make a PNG image file with the correct properties, edit it in the external editor, then use the <code>import</code> command to update the cartridge. You can set up the palette in your editor by placing some of each color on the sprite sheet within PICO-8, then sampling the exported file.

To transfer a sprite sheet from one cartridge to another, export it from the first cartridge, then <code>import</code> it into the second cartridge.<h4>Examples</h4><pre>
> import sprites.png
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Export|<code>export</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>CommandReference</h2>A command is an action you can perform in PICO-8 by typing it at the [[CommandPrompt|command prompt]]. Commands are used to load and save cartridges, manage files, and launch the [[Splore]] cartridge explorer.<h4>Executing commands</h4>Unlike [[Function|functions]], you do not use parentheses after the command name. For commands that take arguments, you type each argument after the command separated by spaces. String arguments such as filenames are not surrounded by quote marks.

<pre>
> load jelpi.p8
</pre>

All commands can be called by source code as functions, using parentheses around the argument list, quotes around string arguments, and commas between arguments. Most commands don't do anything useful when called from code.

<pre>
-- load a new cart, overwriting this one
load('jelpi.p8')
</pre><h4>Help and information</h4><ul><li>[[Help|help]]</li><li>[[Info|info]]</li><li>[[Install_demos|install_demos]]</li><li>[[Keyconfig|keyconfig]]</li><li>[[Splore|splore]]</li></ul><h4>Files and folders</h4><ul><li>[[Cd|cd <nowiki>[dirpath]</nowiki>]]</li><li>[[Export|export filename]]</li><li>[[Folder|folder]]</li><li>[[Import|import filename]]</li><li>[[Load|load filename]]</li><li>[[Ls|ls]]</li><li>[[Mkdir|mkdir dirname]]</li><li>[[Save|save <nowiki>[filename]</nowiki>]]</li></ul><h4>Running and quitting</h4><ul><li>[[Reboot|reboot]]</li><li>[[Resume|resume]]</li><li>[[Run|run]]</li><li>[[Shutdown|shutdown]]</li></ul><h4>See also</h4><ul><li>[[APIReference]]</li><li>[[:Category:Command]]</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>APIReference</h2>This is a list of functions provided by PICO-8's Lua-based [https://en.wikipedia.org/wiki/Application_programming_interface API] .

Typically you run these functions by writing them in the code editor and using the [[Run]] command to run your program. You can also call API functions from the PICO-8 [[CommandPrompt|command prompt]].<h4>Calling functions</h4>Some functions have optional arguments, indicated in this guide by square brackets around the argument name. To specify a value for an optional argument, you must specify values for all other arguments to the left in the argument list.

For example, the [[Spr|spr()]] function has three required arguments and four optional arguments:

<pre>
spr( n, x, y, [w,] [h,] [flip_x,] [flip_y] )
</pre>

This function can be called with three arguments, accepting the defaults for the others:

<pre>
spr(1, 60, 60)
</pre>

To specify a value for the <code>flip_x</code> argument, you must also specify <code>w</code> and <code>h</code>, even if you're using their default values:

<pre>
spr(1, 60, 60, 1, 1, true)
</pre><h4>The game loop</h4>If you define these functions in your code, PICO-8 will call them at specific times. See [[GameLoop|Game loop]].<ul><li>[[Init|<code>_init()</code>]]</li><li>[[Update|<code>_update()</code>]]</li><li>[[Draw|<code>_draw()</code>]]</li></ul>If your code doesn't use the game loop, you can call this function to copy the graphics buffer to the screen:<ul><li>[[Flip|<code>flip()</code>]]</li></ul><h4>Graphics</h4><ul><li>[[Camera|<code>camera([x,] [y])</code>]]</li><li>[[Circ|<code>circ(x, y, r, [col])</code>]]</li><li>[[Circfill|<code>circfill(x, y, r, [col])</code>]]</li><li>[[Clip|<code>clip([x,] [y,] [w,] [h])</code>]]</li><li>[[Cls|<code>cls()</code>]]</li><li>[[Color|<code>color(col)</code>]]</li><li>[[Cursor|<code>cursor([x,] [y,] [col])</code>]]</li><li>[[Fget|<code>fget(n, [f])</code>]]</li><li>[[Fillp|<code>fillp([pat])</code>]]</li><li>[[Fset|<code>fset(n, [f,] [v])</code>]]</li><li>[[Line|<code>line(x0, y0, x1, y1, [col])</code>]]</li><li>[[Pal|<code>pal([c0,] [c1,] [p])</code>]]</li><li>[[Palt|<code>palt([c,] [t])</code>]]</li><li>[[Pget|<code>pget(x, y)</code>]]</li><li>[[Print|<code>print(str, [x,] [y,] [col])</code>]]</li><li>[[Pset|<code>pset(x, y, [c])</code>]]</li><li>[[Rect|<code>rect(x0, y0, x1, y1, [col])</code>]]</li><li>[[Rectfill|<code>rectfill(x0, y0, x1, y1, [col])</code>]]</li><li>[[Sget|<code>sget(x, y)</code>]]</li><li>[[Spr|<code>spr(n, x, y, [w,] [h,] [flip_x,] [flip_y])</code>]]</li><li>[[Sset|<code>sset(x, y, [c])</code>]]</li><li>[[Sspr|<code>sspr(sx, sy, sw, sh, dx, dy, [dw,] [dh,] [flip_x,] [flip_y])</code>]]</li></ul>See also [[Graphics]].<h4>Tables</h4><ul><li>[[Add|<code>add(t, v)</code>]]</li><li>[[All|<code>all(t)</code>]]</li><li>[[Del|<code>del(t, v)</code>]]</li><li>[[Foreach|<code>foreach(t, f)</code>]]</li><li>[[Pairs|<code>pairs(t)</code>]]</li></ul>See also [[Lua]], [[Tables]].<h4>Input</h4><ul><li>[[Btn|<code>btn([i,] [p])</code>]]</li><li>[[Btnp|<code>btnp([i,] [p])</code>]]</li></ul><h4>Sound</h4><ul><li>[[Music|<code>music([n,] [fade_len,] [channel_mask])</code>]]</li><li>[[Sfx|<code>sfx(n, [channel,] [offset])</code>]]</li></ul><h4>Map</h4><ul><li>[[Map|<code>map(cel_x, cel_y, sx, sy, cel_w, cel_h, [layer])</code>]]</li><li>[[Mget|<code>mget(x, y)</code>]]</li><li>[[Mset|<code>mset(x, y, v)</code>]]</li></ul><h4>Memory</h4><ul><li>[[Cstore|<code>cstore(dest_addr, source_addr, len, [filename])</code>]]</li><li>[[Memcpy|<code>memcpy(dest_addr, source_addr, len)</code>]]</li><li>[[Memset|<code>memset(dest_addr, val, len)</code>]]</li><li>[[Peek|<code>peek(addr)</code>]]</li><li>[[Poke|<code>poke(addr, val)</code>]]</li><li>[[Reload|<code>reload(dest_addr, source_addr, len, [filename])</code>]]</li></ul><h4>Math</h4><ul><li>[[Abs|<code>abs(x)</code>]]</li><li>[[Atan2|<code>atan2(dx, dy)</code>]]</li><li>[[Band|<code>band(x, y)</code>]]</li><li>[[Bnot|<code>bnot(x)</code>]]</li><li>[[Bor|<code>bor(x, y)</code>]]</li><li>[[Bxor|<code>bxor(x, y)</code>]]</li><li>[[Cos|<code>cos(x)</code>]]</li><li>[[Flr|<code>flr(x)</code>]]</li><li>[[Max|<code>max(x, y)</code>]]</li><li>[[Mid|<code>mid(x, y, z)</code>]]</li><li>[[Min|<code>min(x, y)</code>]]</li><li>[[Rnd|<code>rnd(x)</code>]]</li><li>[[Shl|<code>shl(x, y)</code>]]</li><li>[[Shr|<code>shr(x, y)</code>]]</li><li>[[Sin|<code>sin(x)</code>]]</li><li>[[Sqrt|<code>sqrt(x)</code>]]</li><li>[[Srand|<code>srand(x)</code>]]</li></ul>See also [[Math]].<h4>Cartridge data</h4><ul><li>[[Cartdata|<code>cartdata(id)</code>]]</li><li>[[Dget|<code>dget(index)</code>]]</li><li>[[Dset|<code>dset(index, value)</code>]]</li></ul><h4>Coroutines</h4><ul><li>[[Cocreate|<code>cocreate(func)</code>]]</li><li>[[Coresume|<code>coresume(cor)</code>]]</li><li>[[Costatus|<code>costatus(cor)</code>]]</li><li>[[Yield|<code>yield()</code>]]</li></ul><h4>Values and objects</h4><ul><li>[[Setmetatable|<code>setmetatable(tbl, metatbl)</code>]]</li><li>[[Getmetatable|<code>getmetatable(tbl)</code>]]</li><li>[[Type|<code>type(v)</code>]]</li><li>[[Sub|<code>sub(str, from, [to])</code>]]</li><li>[[Tonum|<code>tonum(str)</code>]]</li><li>[[Tostr|<code>tostr(val, [usehex])</code>]]</li></ul>See also [[Lua]], [[Strings]], [[Tables]], [[Metatables]].<h4>Time</h4><ul><li>[[Time|<code>time()</code>]]</li></ul><h4>System</h4><ul><li>[[Menuitem|<code>menuitem(index, [label, callback])</code>]]</li><li>[[Extcmd|<code>extcmd(cmd)</code>]]</li></ul><h4>Debugging</h4><ul><li>[[Assert|<code>assert(cond, [message])</code>]]</li><li>[[Printh|<code>printh(str, [filename], [overwrite])</code>]]</li><li>[[Stat|<code>stat(n)</code>]]</li><li>[[Stop|<code>stop()</code>]] (undocumented)</li><li>[[Trace|<code>trace()</code>]] (undocumented)</li></ul><h4>See also</h4><ul><li>[[CommandReference]]</li><li>[[:Category:API]]</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Clip</h2>{{ApiReference
|name=clip
|shortdesc=Sets the clipping region in the [[DrawState|draw state]].
|x||The x coordinate of the upper left corner of the clipping rectangle.
|y||The y coordinate of the upper left corner of the clipping rectangle.
|w||The width of the clipping rectangle, in pixels.
|h||The height of the clipping rectangle, in pixels.
}}
When the [[DrawState|draw state]] has a clipping rectangle set, all draw operations will not affect any pixels in the graphics buffer outside of this rectangle. This is useful for reserving parts of the screen

When called without arguments, the function resets the clipping region to be the entire screen.<h4>Technical notes</h4>The actual current GPU clipping rectangle is [[Memory#Draw state|memory-mapped]] and may be read or written directly with [[Peek|<code>peek()</code>]] and [[Poke|<code>poke()</code>]]:<ul><li>0x5f20 / 24352: x_begin (no pixels < x_begin will be drawn)</li><li>0x5f21 / 24353: y_begin (no pixels < y_begin will be drawn)</li><li>0x5f22 / 24354: x_end (no pixels >= x_end will be drawn)</li><li>0x5f23 / 24355: y_end (no pixels >= x_end will be drawn)</li></ul><span style="font-weight:bold;">Important:</span> These values are not in the same format as the arguments to <code>clip()</code>. See the [[Memory#Draw state|draw state]] documentation for details.<h4>Examples</h4><pre>
-- set the clipping region to exclude 8 pixels at the top and bottom
clip(0, 8, 128, 112)

-- these circles are clipped to (0-127,8-119)
circfill(10, 10, 8, 8)
circfill(10, 118, 8, 8)

-- reset the clipping region to full screen
clip()

-- these circles are not clipped
circfill(40, 10, 8, 7)
circfill(40, 118, 8, 7)

-- get the current clip rectangle from its memory-mapped addresses
clip_x=peek(0x5f20)
clip_y=peek(0x5f21)
clip_w=peek(0x5f22)-clip_x
clip_h=peek(0x5f23)-clip_y
</pre>
[[File:Screen Shot 2016-06-05 at 10.48.07 AM.png|thumb|center|224x224px|alt=clip example]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Camera|<code>camera()</code>]]</li><li>[[Color|<code>color()</code>]]</li><li>[[Cursor|<code>cursor()</code>]]</li><li>[[Pal|<code>pal()</code>]]</li><li>[[Palt|<code>palt()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Pget</h2>{{ApiReference
|name=pget
|shortdesc=Gets the color value of a pixel at the given coordinates.
|x||The x coordinate.
|y||The y coordinate.
}}
The <code>pget()</code> function reads the color value of a pixel from the graphics buffer.

It will read from the buffer even if the buffer has not yet been copied to the display.

It will return 0 (black) if given coordinates outside the range (0-127,0-127).<h4>Examples</h4><pre>
pset(10, 10, 7)                 -- sets (10, 10) to white
print(pget(10, 10), 0, 112, 7)  -- prints 7

pset(10, 10, 8)                 -- sets (10, 10) to red
print(pget(10, 10), 0, 120, 7)  -- prints 8

flip()  -- displays the red (8) pixel and the messages 
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Pset|<code>pset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Pset</h2>{{ApiReference
|name=pset
|shortdesc=Sets a pixel in the graphics buffer.
|x||The x coordinate.
|y||The y coordinate.
|c|optional|The color value. If not specified, uses the current color of the [[DrawState|draw state]].
}}
The <code>pset()</code> function sets a pixel in the graphics buffer.

This operation is affected by the [[DrawState|draw state]].<h4>Examples</h4><pre>
pset(10, 10, 7)                 -- sets (10, 10) to white
print(pget(10, 10), 0, 96, 7)   -- prints 7

pset(10, 10, 8)                 -- sets (10, 10) to red
print(pget(10, 10), 0, 104, 7)  -- prints 8
</pre>

Repeatedly fill the screen with randomly colored pixels:
<pre>
function _update()
  -- _update() is required for game loop 
end

function _draw()
  for x=0,127 do
    for y=0,127 do
      pset(x, y, rnd(16))
    end
  end
end
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Pget|<code>pget()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sget</h2>{{ApiReference
|name=sget
|shortdesc=Gets the color value of a pixel on the sprite sheet.
|x||The x coordinate on the sprite sheet.
|y||The y coordinate on the sprite sheet.
}}
This is similar to [[Pget|pget()]] except instead of the graphics buffer, it gets the color value from the sprite sheet. The sprite sheet is treated as a single canvas 128 pixels wide and 128 pixels high.

If the bottom half of the sprite sheet is used for map data, <code>sget</code> will return map data values for that region. Prefer [[Mget|mget()]] for accessing map data.

It will return 0 (black) if given coordinates outside the range (0-127,0-127).<h4>Examples</h4><pre>
sset(10, 10, 7)      -- sets (10, 10) to white
print(sget(10, 10))  -- prints 7
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Sset|<code>sset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sset</h2>{{ApiReference
|name=sset
|shortdesc=Sets the color value of a pixel on the sprite sheet.
|x||The x coordinate on the sprite sheet.
|y||The y coordinate on the sprite sheet.
|c|optional|The color value to set. If unspecified, the color of the current [[DrawState|draw state]] will be used.
}}
This is similar to [[Pset|pset()]] except instead of the graphics buffer, it sets the color value to the sprite sheet. The sprite sheet is treated as a single canvas 128 pixels wide and 128 pixels high.

If the bottom half of the sprite sheet is used for map data, <code>sset</code> will modify map data values for that region. Prefer [[Mset|mset()]] for setting map data.

Drawing to the sprite sheet changes the data in memory, but does not change the cartridge. A program can restore the original data from the cartridge with [[Reload|reload()]], and can save the modified data to the cart with [[Cstore|cstore()]]. See [[Memory]] for information about the memory addresses to use.<h4>Examples</h4><pre>
sset(10, 10, 7)      -- sets (10, 10) to white
print(sget(10, 10))  -- prints 7
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Sget|<code>sget()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Fget</h2>{{ApiReference
|name=fget
|shortdesc=Gets the value of a flag of a sprite.
|n||The sprite number.
|f|optional|The flag index (0-7). If omitted, a bit field of all flags is returned.
}}
Each sprite has eight flags that can be set in the sprite editor or by the [[Fset|fset()]] function. You can use these flags for any purpose. One possible purpose is to define "layers" of map tiles, which modifies the behavior of the [[Map|map()]] function.

Flags are numbered from 0 to 7, appearing left to right in the sprite editor.

When <code>fget()</code> is called without a flag index, it returns a number that represents all of the flags. This is a bit field where flag 0 is the "least significant" bit: flag 0 (leftmost) has a value of 1, flag 1 has a value of 2, flag 2 has a value of 4, and so on, up to flag 7 with a value of 128.<h4>Examples</h4>Given a sprite with flags 0, 1, and 7 set:
<pre>
first = fget(16, 0)   -- true
second = fget(16, 1)  -- true
third = fget(16, 2)   -- false
eighth = fget(16, 7)  -- true

flags = fget(16)      -- 131 (1 + 2 + 128)
</pre>
[[File:Sprite flags.png|thumb|center|220x220px|alt=Sprite flags. Image from jelpi.p8 by zep.]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Fset|<code>fset()</code>]]</li><li>[[Map|<code>map()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Fset</h2>{{ApiReference
|name=fset
|shortdesc=Sets the value of a flag of a sprite.
|n||The sprite number.
|f|optional|The flag index (0-7). If omitted, a bit field of all flags is returned.
|v||The value, either <code>true</code> or <code>false</code> if the flag index is specified, or the bit field of all flags if it is not.
}}
Each sprite has eight flags that can be set in the sprite editor or by the [[Fset|fset()]] function. You can use these flags for any purpose. One possible purpose is to define "layers" of map tiles, which modifies the behavior of the [[Map|map()]] function.

To set a specific flag, specify the flag index as the second argument, and either <code>true</code> or <code>false</code> as the value. Flags are numbered from 0 to 7, appearing left to right in the sprite editor.

When <code>fset()</code> is called without a flag index, it accepts a number that represents all of the flags. This is a bit field where flag 0 is the "least significant" bit: flag 0 (leftmost) has a value of 1, flag 1 has a value of 2, flag 2 has a value of 4, and so on, up to flag 7 with a value of 128.

Setting a flag changes the data in memory, but does not change the cartridge. A program can restore the original data from the cartridge with [[Reload|reload()]], and can save the modified data to the cart with [[Cstore|cstore()]]. See [[Memory]] for information about the memory addresses to use.<h4>Examples</h4><pre>
-- Set flag 0 (leftmost) of sprite 16.
fset(16, 0, true)

-- Clear flag 7 (rightmost) of sprite 16.
fset(16, 7, false)

-- Set flags 0, 1, and 7 of sprite 16.
fset(16, 131)  -- 131 = 1 + 2 + 128
</pre>
[[File:Sprite flags.png|thumb|center|220x220px|alt=Sprite flags. Image from jelpi.p8 by zep.]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Fget|<code>fget()</code>]]</li><li>[[Map|<code>map()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Print</h2>{{ApiReference
|name=print
|shortdesc=Prints a string of characters to the screen.
|str||The string of characters to print.
|x|optional|The x coordinate of the upper left corner to start printing.
|y|optional|The y coordinate of the upper left corner to start printing.
|col|optional|The color to use for the text.
}}
The <code>print</code> function writes text to the screen using the PICO-8 font.

Given only a Lua string, <code>print</code> uses the cursor location and draw color of the current [[DrawState|draw state]]. The cursor position is moved to the next line, potentially scrolling the entire display up by a line. This form of <code>print()</code> behaves like a scrolling display of text.

<pre>
print('you are standing at the end of')
print('a road before a small brick')
print('building.')
</pre>

Given <code>x</code> and <code>y</code> coordinates, <code>print</code> uses the given coordinates as the upper left corner of the rectangle containing the text.

<pre>
print('press x to start', 32, 60)
</pre>

If the <code>col</code> argument is provided, the message is printed in the given color. This changes the draw color of the draw state.

<pre>
print('press x to start', 32, 60, 7)
</pre>

Each character of the PICO-8 font is 4 pixels wide and 6 pixels high. At this size, 32 characters can fit on a single line (128 pixels / 4 pixels per character). If the string is too long to display at the given coordinates, it is clipped, similar to other draw operations. (The string does not wrap to the next line.)

<code>print()</code> is especially useful at the PICO-8 command prompt. When you interrupt the program by pressing escape, the global variables and functions of the cartridge are available to expressions you type. To see the value of these expressions, you use the <code>print()</code> function.

<pre>
> print(player.x)
42
</pre><h4>Cursor positioning and scrolling</h4>When you call <code>print()</code> with only a string, the message is printed at the current cursor position, and the cursor is moved to the next line. Specifically, the cursor position advances to the next line: <code>y = y + 6</code>. The cursor's <code>x</code> position is unchanged from its original value, as if it were the left margin of a series of <code>print()</code> calls.

If the cursor's new <code>y</code> position is less than 6 pixels from the bottom of the screen, the entire graphics display is shifted up by six pixels after the string is printed, producing a scrolling display effect.

<span style="font-weight:bold;">Note:</span> The scrolling effect only occurs when the cursor position reaches the bottom of the physical display (<code>y > 128</code>). It ignores the [[Clip|clipping region]]. It honors the [[Camera|camera]] offset. The scroll effect has unusual behavior when a clipping region or camera offset are in effect. It is probably best to avoid using scrolling <code>print()</code> in combination with a clipping region or camera offset.<h4>Printing at coordinates</h4>When given explicit coordinate arguments, <code>print()</code> uses those coordinates as the upper left corner of the rectangle where the text appears.

In this case, the draw state's cursor position is set to the given coordinates, and remain there after the message is printed. The cursor is <span style="font-style:italic;">not</span> relocated to the next line of text. (This is not particularly useful, just a side effect of how it is implemented.)<h4>Newlines</h4>Without coordinates, there is an implied newline at the end of your string.  You may also include additional newline characters (<code>"\n"</code>) in your string to draw several lines of text with a single call.  The screen will scroll as needed.

With coordinates, there are no automatic newlines, only those you place in the string yourself.  Also, there is no scrolling if you try to render text outside of the visible area.  Aside from that, newlines still behave as expected.<h4>Shorthand form</h4>PICO-8 provides a [[Wikipedia:BASIC|BASIC]]-like "<code>?</code>" shorthand for <code>print()</code>. Here is an example showing the normal method and the shorthand method:

<pre>
-- print the player x position just inside the upper left corner, in red
print(player.x,2,2,8)

-- print the player y position to the right of the x position, in green
?player.y,32,2,11
</pre>

This shorthand is intended mostly for quick evaluation of variables at the command line:

<pre>
> ?player.x
42
</pre>

However, it does work in source code and can be used to save a few tokens in dire situations. The only requirement is that it must be alone on a line. Also keep in mind that this shorthand form is not as readable as the function call.<h4>Examples</h4><pre>
-- print a score display at the bottom of the screen in red
score = 1234
print('score: '..score, 0, 120, 8)
</pre>

A demonstration of cursor positioning and scrolling:

<pre>
-- clear the screen and reset the cursor position
cls()

-- print "try this" at the center of the screen
print('try this', 46, 60, 8)

-- reset the cursor to (0, 0) and the color to 7
cursor()
color(7)

print('one')  -- prints "one" in the upper left corner, advances cursor
print('two')  -- prints "two" on the line below "one", advances cursor

print('three', 16, 16)  -- prints "three" at (16, 16), sets cursor
print('four')  -- prints "four" on top of "three", advances cursor
print('five')  -- prints "five" on the line below "four", advances cursor

print('six', 0, 112)  -- prints "six" on the second-to-last line, sets cursor
print('seven')   -- prints "seven" on top of "six"
print('eight')   -- prints "eight" on the last line, then scrolls up by 8 pixels
</pre>

A function that prints a message at the center of the screen:
<pre>
-- 64 is half of the screen width (128 / 2). To calculate the x
-- coordinate, the length of the string is multiplied by half
-- of the character width (4 / 2), then subtracted from 64.
-- Similarly, the y coordinate is 60 = 64 - (8 / 2).
function print_centered(str)
  print(str, 64 - (#str * 2), 60) 
end

print_centered('you win!')
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Strings]]</li><li>[[Cls|<code>cls()</code>]]</li><li>[[Color|<code>color()</code>]]</li><li>[[Cursor|<code>cursor()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Cursor</h2>{{ApiReference
|name=cursor
|shortdesc=Sets the text cursor position for [[Print|<code>print()</code>]].
|x|optional|The x coordinate of the upper left corner. The default is 0.
|y|optional|The y coordinate of the upper left corner. The default is 0.
|col|optional|The color number to set the draw color to. (Added in PICO-8 0.1.12.)
}}
The [[DrawState|draw state]] maintains a cursor location for printing text with the [[Print|<code>print()</code>]] function (as well as a pen color). PICO-8 uses this to maintain a scrolling display, especially for the command prompt.

The [[Cls|<code>cls()</code>]] function resets the cursor position to (0, 0). Calling [[Print|<code>print()</code>]] with explicit coordinate arguments sets the cursor to that location.

See [[Print|<code>print()</code>]] for an explanation of the text cursor behavior.<h4>Technical notes</h4>The current cursor position is [[Memory|memory-mapped]] and may be read or written directly:<ul><li>0x5f26: cursor x position</li><li>0x5f27: cursor y position</li><li>0x5f25: pen color (see also [[Color|<code>color()</code>]])</li></ul><h4>Examples</h4><pre>
-- set the cursor position to (20, 24).
cursor(20, 24)

print('line one')
print('line two')
print('line three')

-- get the cursor position from its memory-mapped addresses
cursor_x=peek(0x5f26)
cursor_y=peek(0x5f27)
</pre>
[[File:Cursor-example.png|thumb|220x220px]]<h4>See also</h4><ul><li>[[DrawState|Draw state]]</li><li>[[Cls|cls]]</li><li>[[Print|print]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Color</h2>{{ApiReference
|name=color
|shortdesc=Sets the draw color in the [[DrawState|draw state]].
|col||The color number.
}}
Many graphics functions accept an optional color argument. When this argument is omitted, the current color of the [[DrawState|draw state]] is used by default. The <code>color()</code> function sets this color.

The color number corresponds to the PICO-8 palette, a value between 0 and 15. See [[Graphics]] for an illustrated table of colors.

When you provide an explicit color argument to a graphics function, PICO-8 changes the draw color to that color.

The <code>color()</code> function honors the alternate palette set by [[Pal|<code>pal()</code>]].<h4>Technical notes</h4>The current color is [[Memory|memory-mapped]] and may be read or written directly:<ul><li>0x5f25: current color</li></ul><h4>Examples</h4><pre>
cls()

color(7)  -- white
circfill(20, 20, 10)
circfill(60, 60, 10)

color(8)  -- red
circfill(20, 60, 10)
circfill(60, 20, 10)

pal(7, 10)  -- white -> yellow
color(7)
circfill(20, 100, 10)
circfill(60, 100, 10)

-- get the current color from its memory-mapped address
cur_color=peek(0x5f25)
</pre>
[[File:Color-example.png|thumb|220x220px]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Circ|<code>circ()</code>]]</li><li>[[Circfill|<code>circfill()</code>]]</li><li>[[Line|<code>line()</code>]]</li><li>[[Print|<code>print()</code>]]</li><li>[[Pset|<code>pset()</code>]]</li><li>[[Rect|<code>rect()</code>]]</li><li>[[Rectfill|<code>rectfill()</code>]]</li><li>[[Sset|<code>sset()</code>]]</li><li>[[Pal|<code>pal()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Cls</h2>{{ApiReference
|name=cls
|shortdesc=Clears the graphics buffer.
|color|optional|A color to use for the background. The default is 0 (black).
}}
The <code>cls()</code> function clears the graphics buffer, effectively setting every pixel to the color 0. If the color argument is provided, that number is used instead.

<code>cls()</code> also sets the text cursor in the [[DrawState|draw state]] to (0, 0).

This ignores the alternate palette set by [[Pal|pal()]] for the purposes of using color 0. (<code>pal(0, 7) cls()</code> does not fill the screen with white.) To fill the screen with a specific color, use [[Rectfill|rectfill]].

It is common (though not required) to call <code>cls()</code> at the beginning of the [[Draw|_draw()]] function as part of the [[GameLoop|game loop]].<h4>Examples</h4><pre>
function _init()
  x = 0
end

function _update()
  -- add 1 to x. if x > 128, reset it to 0.
  x = (x + 1) % 128
end

function _draw()
  cls()
  circfill(x, x, 10, 8)
end
</pre>

Try removing the <code>cls()</code> call from this example.
[[File:Cls example.gif|thumb|220x220px]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Cursor|<code>cursor()</code>]]</li><li>[[Rectfill|<code>rectfill()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Camera</h2>{{ApiReference
|name=camera
|shortdesc=Sets the camera offset in the [[DrawState|draw state]].
|x|optional|The x offset, in pixels, to subtract from future draw coordinates. (default 0)
|y|optional|The y offset, in pixels, to subtract from future draw coordinates. (default 0)
}}

Setting a camera offset causes all subsequent draw operations to have the offset <span style="font-style:italic;">subtracted</span> from their x and y coordinates. Camera sets the origin point for draw functions, and by default it is <code>(0,0)</code>.

The way <code>camera()</code> works is somewhat unintuitive. So, if you might expect to use <code>camera(64,64)</code> to put the camera origin in the middle of the screen, you'd actually use <code>camera(-64,-64)</code> to move the screen so that its middle is in front of the camera. This is probably because <code>camera()</code> sets an screen variable that is invisibly used by all draw functions, and in this case, the origin changed from <code>(0,0)</code> to <code>(-64,-64)</code>.

Camera offsets can be used to implement screen effects such as parallax scrolling (with a different offset per layer) or screen shake (a small random offset per frame).<h4>Technical notes</h4>The current camera offset is [[Memory|memory-mapped]] and may be read or written directly:<ul><li>0x5f28: offset x lo byte</li><li>0x5f29: offset x hi byte</li><li>0x5f2a: offset y lo byte</li><li>0x5f2b: offset y hi byte</li></ul><h4>Examples</h4><pre>
-- draw a dark blue circle at (20, 20)
circfill(20, 20, 10, 1)

camera(-2, 2)

-- draw a white circle at (22, 18)
circfill(20, 20, 10, 7)

camera(-64, -64)

-- draw a big red circle, centered
circfill(0, 0, 63, 8)

-- get the current offset from its memory-mapped addresses
camera_x=peek(0x5f28)+peek(0x5f29)*256
camera_y=peek(0x5f2a)+peek(0x5f2b)*256
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Circfill</h2>{{ApiReference
|name=circfill
|shortdesc=Draws a filled-in circle shape.
|x||The x coordinate of the center of the circle.
|y||The y coordinate of the center of the circle.
|r|optional|The radius of the circle, in pixels. If omitted, the radius will be 4.
|col|optional|The color of the circle and fill. If omitted, the color from the [[DrawState|draw state]] is used.
}}<h4>Examples</h4>[[File:Circfill example 1.png|thumb|220x220px]]
<pre>
-- draw a large red filled circle in the middle
circfill(64, 64, 32, 8)
</pre>

[[File:Circfill example 2.png|thumb|220x220px]]
<pre>
-- draw ten small white filled circles in random places
color(7)
for n=1,10 do
  circfill(rnd(128), rnd(128), 6)
end
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Circ|<code>circ()</code>]]</li><li>[[Line|<code>line()</code>]]</li><li>[[Rect|<code>rect()</code>]]</li><li>[[Rectfill|<code>rectfill()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Circ</h2>{{ApiReference
|name=circ
|shortdesc=Draws a circle shape, without fill.
|x||The x coordinate of the center of the circle.
|y||The y coordinate of the center of the circle.
|r|optional|The radius of the circle, in pixels. If omitted, the radius will be 4.
|col|optional|The color of the circle and fill. If omitted, the color from the [[DrawState|draw state]] is used.
}}<h4>Examples</h4>[[File:Circ-example-1.png|thumb|220x220px]]
<pre>
-- draw a large red circle in the middle
circ(64, 64, 32, 8)
</pre>
&nbsp;
[[File:Circ-example-2.png|thumb|220x220px]]
<pre>
-- draw ten small white empty circles in random places
color(7)
for n=1,10 do
  circ(rnd(128), rnd(128), 6)
end
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Circfill|<code>circfill()</code>]]</li><li>[[Line|<code>line()</code>]]</li><li>[[Rect|<code>rect()</code>]]</li><li>[[Rectfill|<code>rectfill()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Line</h2>{{ApiReference
|name=line
|shortdesc=Draws a line between two points.
|x0|optional|The x coordinate of the start of the line. If omitted, the x coordinate of the end of the previous line is used, or 0 if no previous line has been drawn.
|y0|optional|The y coordinate of the start of the line. If omitted, the y coordinate of the end of the previous line is used, or 0 if no previous line has been drawn.
|x1||The x coordinate of the end of the line.
|y1||The y coordinate of the end of the line.
|col|optional|The color of the line. If omitted, the color from the [[DrawState|draw state]] is used. This also sets the color in the draw state.
}}

Line continuation was added in PICO-8 0.1.12; if a line has already been drawn, you can omit the starting coordinates to continue the line from the ending coordinates of the previous line.<h4>Examples</h4><pre>
-- draw a red diamond shape
line(63, 0, 126, 63, 8)
line(126, 63, 63, 126, 8)
line(63, 126, 0, 63, 8)
line(0, 63, 63, 0, 8)

-- draw the same red diamond shape
-- using line continuation
color(8)
line(63, 0, 126, 63)
line(63, 126)
line(0, 63)
line(63, 0)

-- draw 20 white lines in random locations
color(7)
for x=1,20 do
  line(rnd(128), rnd(128), rnd(128), rnd(128))
end
</pre>
[[File:Line-example-1.png|thumb|220x220px]]
[[File:Line-example-2.png|thumb|220x220px]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Circ|<code>circ()</code>]]</li><li>[[Circfill|<code>circfill()</code>]]</li><li>[[Rect|<code>rect()</code>]]</li><li>[[Rectfill|<code>rectfill()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rectfill</h2>{{ApiReference
|name=rectfill
|shortdesc=Draws a filled-in rectangle shape.
|x0||The x coordinate of the upper left corner.
|y0||The y coordinate of the upper left corner.
|x1||The x coordinate of the lower right corner.
|y1||The y coordinate of the lower right corner.
|col|optional|The color of the rectangle and fill. If omitted, the color from the [[DrawState|draw state]] is used.
}}
This draws a rectangle shape parallel to the screen borders.

It's important to note that the coordinates are <span style="font-style:italic;">inclusive</span>, which is to say PICO-8 will render pixels at the right and bottom coords.  In many APIs, <code>x1</code> and <code>y1</code> would be the first pixels which are <span style="font-style:italic;">not</span> drawn, but on PICO-8, they are the last pixels which <span style="font-style:italic;">are</span> drawn.<h4>Examples</h4><pre>
-- fill the whole screen, as if we called cls(1)
rectfill(0, 0, 127, 127, 1)

-- fill the center 96x96 portion of the screen
rectfill(16, 16, 111, 111, 1)

-- draw three filled-in white rectangles at random locations and sizes
color(7)
for x=1,3 do
  rectfill(rnd(128), rnd(128), rnd(128), rnd(128))
end
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Circ|<code>circ()</code>]]</li><li>[[Circfill|<code>circfill()</code>]]</li><li>[[Line|<code>line()</code>]]</li><li>[[Rect|<code>rect()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rect</h2>{{ApiReference
|name=rect
|shortdesc=Draws an empty rectangle shape.
|x0||The x coordinate of the upper left corner.
|y0||The y coordinate of the upper left corner.
|x1||The x coordinate of the lower right corner.
|y1||The y coordinate of the lower right corner.
|col|optional|The color of the rectangle border. If omitted, the color from the [[DrawState|draw state]] is used.
}}
This draws a rectangle shape parallel to the screen borders.

It's important to note that the coordinates are <span style="font-style:italic;">inclusive</span>, which is to say PICO-8 will render pixels at the right and bottom coords.  In many APIs, <code>x1</code> and <code>y1</code> would be the first pixels which are <span style="font-style:italic;">not</span> drawn, but on PICO-8, they are the last pixels which <span style="font-style:italic;">are</span> drawn.<h4>Examples</h4><pre>
-- draw a border around the whole screen
rect(0, 0, 127, 127, 1)

-- draw a border inset by 16 pixels
rect(16, 16, 111, 111, 1)

-- draw three empty white rectangles at random locations and sizes
color(7)
for x=1,3 do
  rect(rnd(128), rnd(128), rnd(128), rnd(128))

end
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Circ|<code>circ()</code>]]</li><li>[[Circfill|<code>circfill()</code>]]</li><li>[[Line|<code>line()</code>]]</li><li>[[Rectfill|<code>rectfill()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sspr</h2>{{ApiReference
|name=sspr
|shortdesc=Draws a rectangle of pixels from the sprite sheet, optionally stretching the image to fit a rectangle on the screen.
|sx||The x coordinate of the upper left corner of the rectangle in the sprite sheet.
|sy||The y coordinate of the upper left corner of the rectangle in the sprite sheet.
|sw||The width of the rectangle in the sprite sheet, as a number of pixels.
|sh||The height of the rectangle in the sprite sheet, as a number of pixels.
|dx||The x coordinate of the upper left corner of the rectangle area of the screen.
|dy||The y coordinate of the upper left corner of the rectangle area of the screen.
|dw|optional|The width of the rectangle area of the screen. The default is to match the image width (sw).
|dh|optional|The height of the rectangle area of the screen. The default is to match the image height (sh).
|flip_x|optional|If <code>true</code>, the image is drawn inverted left to right. The default is <code>false</code>. 
|flip_y|optional|If <code>true</code>, the image is drawn inverted top to bottom. The default is <code>false</code>.
}}
This operation is affected by the [[DrawState|draw state]].

Unlike [[Spr|spr()]], this function uses pixel locations on the sprite sheet instead of sprite numbers. The sprite sheet is treated as an image 128 pixels wide and 128 pixels high, where (0, 0) is the upper left corner.<h4>Examples</h4><pre>
-- draw the 8 x 8 image from (8, 0) at screen location (60, 60)
sspr(8, 0, 8, 8, 60, 60)

-- draw the same image but stretched to 12 x 20 at screen location (44, 48)
sspr(8, 0, 8, 8, 44, 48, 12, 20)

-- draw it again, flipped horizontally, at (72, 48)
sspr(8, 0, 8, 8, 72, 48, 12, 20, true, false)
</pre>

This example appears to distort the original image differently based on whether the image is flipped. Notice that the stretched image must still use the 128 x 128 resolution of PICO-8. To stretch from 8 pixels to 12, <code>sspr()</code> doubles the width of every other column. Because of how this sprite is drawn, the flipped version puts the features of the image (hair, face, arms) on different columns, so different features get double-wide in the flipped version.

[[File:Sspr.png|thumb|center|220x220px|alt=A demonstration of sspr.]]
[[File:Spr ex1 sprites.png|thumb|center|216x216px|alt=The sprite sheet used in this example.]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Spr|<code>spr()</code>]]</li><li>[[Pal|<code>pal()</code>]]</li><li>[[Palt|<code>palt()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Palt</h2>{{ApiReference
|name=palt
|shortdesc=Change the transparency of a color in the [[DrawState|draw state]] for subsequent draw calls.
|col|optional|The number of the color to modify.
|t|optional|If <code>true</code>, treat this color as transparent. If <code>false</code>, treat this color as opaque.
}}
When the [[Spr|<code>spr()</code>]], [[Sspr|<code>sspr()</code>]], and [[Map|<code>map()</code>]] functions copy sprite pixels onto the screen, some colors are considered <span style="font-style:italic;">transparent</span> and are not drawn. By default, color 0 (black) is transparent, so when a sprite's pixel is this color and the sprite is drawn on top of an existing image, that pixel preserves the color underneath.

The <code>palt()</code> function changes the transparency of a given color.

If called without arguments, <code>palt()</code> resets the transparency for all colors. The [[Pal|<code>pal()</code>]] function called without arguments also resets transparency, though the opposite is not true and <code>palt()</code> will not reset colors.<h4>Examples</h4><pre>
-- draw black pixels
palt(0, false)

-- don't draw red pixels
palt(8, true)

-- reset transparency
palt()

-- pal() also resets transparency when it resets colors
pal()
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[DrawState|Draw state]]</li><li>[[Pal|<code>pal()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Pal</h2>{{ApiReference
|name=pal
|shortdesc=Changes the [[DrawState|draw state]] so all instances of a given color are replaced with a new color.
|c0||The number of the original color to replace.
|c1||The number of the new color to use instead.
|p|optional|0 to modify the palette used by draw operations, 1 to modify the palette for the screen already drawn. The default is 0.
}}
All functions that draw to the screen, including [[Spr|<code>spr()</code>]] and [[Map|<code>map()</code>]], use the <span style="font-style:italic;">draw palette</span> to decide which colors to write to the graphics buffer. The <code>pal()</code> function can modify this palette at any time to achieve certain effects, such as to temporarily replace a color used by a sprite with another color.

When the graphics buffer is copied to the screen (after [[Draw|<code>_draw()</code>]] executes or when the program calls [[Flip|<code>flip()</code>]]), it uses a <span style="font-style:italic;">screen palette</span>. This gives the program another opportunity to replace colors for the entire graphics buffer for full screen effects such as fades, or perhaps very large explosions. You tell the <code>pal()</code> function to modify the screen palette by passing <code>1</code> as the optional third argument.

See [[Graphics]] for a table of color numbers.

To reset the entire palette, call <code>pal()</code> without arguments. This also resets the transparency settings, as if you had also called [[Palt|<code>palt()</code>]] with no arguments, so it is not necessary to call both.

<code>pal()</code> is useful for a wide variety of effects. Just a few examples:<ul><li>Use different colors with the same sprite to create multiple distinct instances, such as two figures wearing different clothes.</li><li>Embed multiple color patterns in a single sprite then change the palette to cause different patterns to appear for the same sprite, such as multiple kinds of wall tiles using the same sprite.</li><li>Animate color changes in one or more sprites to indicate status, such as a successful hit to an enemy, or a bomb about to explode.</li><li>Change the palette of an entire environment to indicate the time of day.</li></ul><h4>Examples</h4><pre>
blink_frame = false
t = 0

function _update()
  -- every 8th frame is a "blink frame"
  t = (t + 1) % 8
  blink_frame = (t == 0)
end

function _draw()
  cls()

  -- reset the palette
  pal()

  if blink_frame then
    -- replace dark grey with red
    pal(5, 8)
  end

  -- draw the blinking light sprite
  spr(16, 56, 72)
end
</pre>
[[File:Pal example.gif|thumb|220x220px]]<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Palt|<code>palt()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>All</h2>{{ApiReference
|name=all
|shortdesc=Returns an iterator for all non-<code>nil</code> items in a sequence in a table, for use with <code>for...in</code>.
|tbl||The table to iterate.
}}
The <code>all()</code> function is used exclusively with <code>for...in</code> to iterate over all elements in a sequence in a table. Each non-<code>nil</code> value in the sequence is emitted in sequence order.

Specifically, <code>all()</code> starts at index 1, then steps forward through the table until it reaches the final index, emitting only the elements which are not <code>nil</code>.

When used with a table that contains only unique elements, it is safe to delete the current loop iteration's element from the table. For instance, given a table of all whole numbers, it would be safe to iterate over it and delete prime numbers when they are found. However, in a table with duplicate entries, behavior is undefined and a different method should be used.<h4>Examples</h4><pre>
t = {1, 3, nil, 5}
add(t, 7)
add(t, 9)

for v in all(t) do
  print(v)  -- prints 1, 3, 5, 7, 9
end

function no_primes(t)
  for e in all(t) do
    if is_prime(e) then
      del(t, e)
    end
  end
end
</pre><h4>Technical note</h4>Iterating with <code>all()</code> is good because it makes your code both concise and easy to read. When you need to iterate over objects in a table, in order, it's often the preferred method.

It should be noted, though, that this iterator needs to do some extra work to traverse the table in order. This causes it to be a little slower, per iteration, than using <code>pairs()</code> (which does not guarantee order) or a purely-numeric <code>for</code> loop.

Luckily, this is seldom an issue, as the code inside most loops significantly outweighs this overhead. However, in some tight, high-performance loops, it may have a noticeable impact on throughput. In those cases, it may be worth considering other options.<h4>See also</h4><ul><li>[[Lua]]</li><li>[[Tables]]</li><li>[[Add|<code>add()</code>]]</li><li>[[Del|<code>del()</code>]]</li><li>[[Foreach|<code>foreach()</code>]]</li><li>[[Pairs|<code>pairs()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Foreach</h2>{{ApiReference
|name=foreach
|shortdesc=Calls a function for each element in a sequence in a table.
|tbl||The table.
|func||The function to call. The function should accept an element as its sole argument.
}}
The <code>foreach()</code> function calls a given function for each element in a sequence in a table.

Specifically, it starts with the element at index 1, calls <code>func()</code> with the element as an argument, then increments the index until it reaches an unassigned index (<code>nil</code>).<h4>Examples</h4>A simple example that calls the built-in <code>print</code> function for each element in a sequence of simple values:
<pre>
t = {1, 3, 'hello', 5, 7}
foreach(t, print)
</pre>

A common technique for a game is to maintain a sequence of objects that need to be drawn to the screen, with a general purpose function that can draw an object:
<pre>
function draw_obj(o)
  -- draws an object...
end

game_objs = {}
add(game_objs, make_player_obj())
add(game_objs, make_enemy_obj())
add(game_objs, make_enemy_obj())
add(game_objs, make_enemy_obj())

foreach(game_objs, draw_obj)
</pre>

If the game objects have their own <code>obj:draw()</code> method, you can use an anonymous function to make this a method call:
<pre>
foreach(game_objs, function(obj) obj:draw() end)
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Tables]]</li><li>[[Add|<code>add()</code>]]</li><li>[[All|<code>all()</code>]]</li><li>[[Del|<code>del()</code>]]</li><li>[[Pairs|<code>pairs()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Add</h2>{{ApiReference
|name=add
|shortdesc=Adds a element to the end of a sequence in a table.
|tbl||The table.
|v||The value to add.
}}
The <code>add()</code> function appends an element to the end of a sequence in a table.

This always adds the new element immediately after the current final index. It does <span style="font-style:italic;">not</span> check for available gaps between the start and the end.

The <code>add()</code> function returns the object being added. You can ignore this return value, or pass it back to your own caller.<h4>Examples</h4><pre>
t = {1, 3, 5}
add(t, 7)  -- t = {1, 3, 5, 7}
add(t, 9)  -- t = {1, 3, 5, 7, 9}
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Tables]]</li><li>[[All|<code>all()</code>]]</li><li>[[Del|<code>del()</code>]]</li><li>[[Foreach|<code>foreach()</code>]]</li><li>[[Pairs|<code>pairs()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Del</h2>{{ApiReference
|name=del
|shortdesc=Deletes the first occurrence of a value from a sequence in a table.
|tbl||The table.
|v||The value to match and remove.
}}
The <code>del()</code> function searches a sequence in a table for an element that equals the given value then removes it. All subsequent values in the sequence shift down by one slot to keep the sequence contiguous.

Specifically, <code>del()</code> starts with the element at index 1, then increments the index while comparing elements to the given value. When it finds the first element that is equal to the value, it reassigns the indexes of the subsequent values until it reaches an unassigned index (<code>nil</code>).

From PICO-8 0.1.12, the <code>del()</code> function returns the object being removed (on prior versions, <code>nil</code> is returned). This can be ignored, tested it to see if the removal was successful, or used as needed.<h4>Examples</h4><pre>
t = {1, 3, 5, 3, 7, 5}
del(t, 3)  -- t = {1, 5, 3, 7, 5}
del(t, 7)  -- t = {1, 5, 3, 5}
del(t, 5)  -- t = {1, 3, 5}

del(t, 9)  -- not found, no changes to t
</pre>

The following example demonstrates how equality is used to match elements. A value is only equal to a table if the value is the same table in memory. (Two tables are not equal even if they contain the same elements.)

<pre>
x = {'foo'}
t = {}
add(t, {'bar'})
add(t, {'foo'})
add(t, {'baz'})
add(t, x)
add(t, {'bat'})

for v in all(t) do print(v[0]) end  -- bar foo baz foo bat

del(t, x)

for v in all(t) do print(v[0]) end  -- bar foo baz bat
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Tables]]</li><li>[[Add|<code>add()</code>]]</li><li>[[All|<code>all()</code>]]</li><li>[[Foreach|<code>foreach()</code>]]</li><li>[[Pairs|<code>pairs()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Pairs</h2>{{ApiReference
|name=pairs
|shortdesc=Returns an iterator of key-value pairs for all elements in a table, for use with <code>for...in</code>.
|tbl||The table.
}}
The <code>pairs()</code> function is used exclusively with <code>for...in</code> to iterate over all elements in a table. It emits the key and value together, which you can assign to variables in the <code>for</code> loop:
<pre>
for k, v in pairs(tbl) do
  -- ...
end
</pre>

<code>pairs()</code> returns every value in the table, not just those with sequential indexes. It can return keys and values for tables being used as mappings (dictionaries) or objects.

<code>pairs()</code> does not guarantee the order in which the results are returned.<h4>Examples</h4><pre>
t = {111, 222, 333}
for k, v in pairs(t) do
  print(k..': '..v)
end
-- 1: 111
-- 2: 222
-- 3: 333

t = {n=42, x=100, y=200}
for k, v in pairs(t) do
  print(k..': '..v)
end
-- x: 100
-- y: 200
-- n: 42
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Tables]]</li><li>[[Add|<code>add()</code>]]</li><li>[[All|<code>all()</code>]]</li><li>[[Del|<code>del()</code>]]</li><li>[[Foreach|<code>foreach()</code>]]</li><li>[[Next|<code>next()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Btn</h2>{{ApiReference
|name=btn
|shortdesc=Tests if a button is being pressed at this moment.
|i|optional|The button number.
|p|optional|The player number.
}}
PICO-8 supports six buttons (0-5) of input for each of up to eight players (0-7). When on the device with a keyboard, inputs for players 0 and 1 can come from keys on the keyboard. All eight players can connect [[SDL]]-supported [[Controllers|controllers]]. Each controller is meant to be (or resemble) a Nintendo Entertainment System controller.

<code>btn()</code> called with both arguments returns <code>true</code> if the given player is pressing the given button, <code>false</code> otherwise. If the button number is provided but the player number is omitted, player 0 is assumed.

When <code>btn()</code> is called without arguments, it returns a bitfield of the button states for players 0 and 1. Player 0's buttons are represented by bits 0 through 5 (the rightmost bits), and player 1's buttons are represented by bits 8 through 13 (the leftmost bits). Each bit corresponds to a button number, and a 1 (on) bit representing that the button is pressed.

The button numbers and default keyboard emulation keys are as follows:{| class="article-table"
!Number
!Button
!Player 0 key
!Mask
!Player 1 key
!Mask
|-
|0
|<kbd>🎮&#8239;←</kbd>
|<kbd>←</kbd>
|0x0001
|<kbd>S</kbd>
|0x0100
|-
|1
|<kbd>🎮&#8239;→</kbd>
|<kbd>→</kbd>
|0x0002
|<kbd>F</kbd>
|0x0200
|-
|2
|<kbd>🎮&#8239;&#8239;↑&#8239;</kbd>
|<kbd>&#8239;↑&#8239;</kbd>
|0x0004
|<kbd>E</kbd>
|0x0400
|-
|3
|<kbd>🎮&#8239;&#8239;↓&#8239;</kbd>
|<kbd>&#8239;↓&#8239;</kbd>
|0x0008
|<kbd>D</kbd>
|0x0800
|-
|4
|<kbd>🎮&nbsp;O</kbd>
|<kbd>Z</kbd> / <kbd>C</kbd> / <kbd>N</kbd> / <kbd>NP-</kbd>*
|0x0010
|<kbd>LShift</kbd> / <kbd>⇥Tab</kbd>
|0x1000
|-
|5
|<kbd>🎮&nbsp;X</kbd>
|<kbd>X</kbd> / <kbd>V</kbd> / <kbd>M</kbd> / <kbd>8</kbd>*
|0x0020
|<kbd>A</kbd> / <kbd>Q</kbd>
|0x2000
|}<span style="font-style:italic;">* Note that</span> <kbd>NumPad-</kbd> <span style="font-style:italic;">and</span> <kbd>8</kbd> <span style="font-style:italic;">are undocumented button mappings. From PICO-8 0.1.12, these mappings are only default in the CHIP build of PICO-8.</span>

<code>btn()</code> is useful for most action/arcade button uses, where holding down a button for multiple frames needs to be detected for each frame. For actions such as selecting menu options, see [[Btnp|btnp()]].<h4>Undocumented buttons</h4>{| class="article-table"
!Number
!Button
!Player 0 key
!Mask
!Player 1 key
!Mask
|-
|6
|<kbd>🎮&#8239;Pause</kbd>
|<kbd>Enter</kbd><br /><kbd>Esc</kbd> (Splore)
|0x0040
|n/a
|0x4000
|-
|7
|n/a
|n/a
|0x0080
|n/a
|0x8000
|}Button 6 opens the Pause/Splore menu, and thus <code>btn(6)</code> will only return true the frame just before the menu opens. If detected, this behavior can suppressed by <code>poke(0x5f30,1)</code> to allow the game to use a custom pause menu. See [[Memory#Draw State|Memory]] for further details.

Button 7 is currently reserved and always returns <code>false</code>.<h4>Examples</h4><pre>
x = 0
y = 0
c = 8

function _update()
  if (btn(0) and x > 0) x -= 1
  if (btn(1) and x < 127) x += 1
  if (btn(2) and y > 0) y -= 1
  if (btn(3) and y < 127) y += 1
  if (btn(4) and c > 1) c -= 1
  if (btn(5) and c < 15) c += 1
end

function _draw()
  cls()
  circfill(x, y, 10, c)
end  
</pre><h4>See also</h4><ul><li>[[Controllers]]</li><li>[[Configuration]]</li><li>[[SDL]]</li><li>[[Btnp|<code>btnp()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Btnp</h2>{{ApiReference
|name=btnp
|shortdesc=Tests if a button has just been pressed, with keyboard-style repeating.
|i|optional|The button number.
|p|optional|The player number.
}}
The <code>btnp()</code> function is similar to [[Btn|<code>btn()</code>]] except that it only reports that a button is on if it was not pressed during the previous frame. In other words, it returns <code>true</code> only if a given button was pressed just now, and does not report <code>true</code> again for the same button in the next frame even if it is held down.

This is useful for detecting button presses that are meant to select menu options or initiate actions. If you were to use <code>btn()</code> to initiate an action, the player is likely to initiate the action multiple times that they didn't intend, because the button will register as on for multiple frames.

<code>btnp()</code> implements a keyboard-like repeat mechanism: if the player holds the button for 15 frames, it registers as on again for one frame, then again every four frames after that. The frame counter resets when the player releases the button.

Like <code>btn()</code>, <code>btnp()</code> can take a button number and a player number and return <code>true</code> or <code>false</code>, or can be called without arguments to return a bitfield of button states.

See [[Btn|<code>btn()</code>]] for a description of the arguments and return values.<h4>Examples</h4><pre>
sel = 0
items = {"a", "b", "c", "d",
         "e", "f", "g", "h"}

function _update()
  if (btnp(0) and sel > 0) sel -= 1
  if (btnp(1) and sel < #items - 1) sel += 1
end

function _draw()
  cls()
  
  for i=1,#items do
    print(items[i], 10 * i, 10, 7)
  end

  rect(8 + (sel * 10), 8,
       14 + (sel * 10), 16,
       8)
end
</pre>

Try replacing <code>btnp()</code> with <code>btn()</code> to see what happens.<h4>See also</h4><ul><li>[[Controllers]]</li><li>[[Configuration]]</li><li>[[SDL]]</li><li>[[Btn|<code>btn()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sfx</h2>{{ApiReference
|name=sfx
|shortdesc=Plays a sound effect.
|n||The number of the sound effect to play (0-63), -1 to stop playing sound on the given channel, or -2 to release the sound of the given channel from looping.
|channel|optional|The channel to use for the sound effect (0-3). The default is -1, which chooses an available channel automatically. Can be -2 to stop playing the given sound effect on any channels it plays on.
|offset|optional|The note position in the sound effect to start playing (0-31). The default is 0 (the beginning).
|length|optional|The number of notes in the sound effect to play (0-31). The default is to play the entire sound effect.
}}
A sound effect is a sequence of tones or notes. You can design sounds in the sound effect editor. A cartridge can have up to 64 sounds, numbered 0-63. A sound effect can represent a single effect played by a call to the <code>sfx()</code> function, or can be a series of notes played in a single channel of a [[Music|music]] pattern.

The <code>sfx()</code> function plays a sound on one of PICO-8's four sound channels. If an explicit channel number is not specified, PICO-8 will attempt to select a channel automatically, giving priority to an unused channel so that two concurrent sounds may overlap.

If music is currently playing, the sound effect will attempt to honor the <span style="font-style:italic;">channel mask</span> set by the call to the [[Music|<code>music()</code>]] function to avoid channels that are important to the music. If you specify an explicit channel to <code>sfx()</code>, the music's channel mask is ignored.

It's possible to detect the current sfx being played for each channel, along with the index of the current note of each sfx. See [[Stat#.7B16.E2.80.A626.7D_Sound_and_music_status|<code>stat(16..23)</code>]] for details.<h4>Examples</h4><pre>
-- play sound 3 on any available channel
sfx(3)

-- play sound 3 starting from note position 21 on any available channel
sfx(3, -1, 21)

-- stop playing sound on channel 2
sfx(-1, 2)

-- release a looping sound on channel 2
sfx(-2, 2)
</pre><h4>See also</h4><ul><li>[[Music|<code>music()</code>]]</li><li>[[Stat#.7B16.E2.80.A626.7D_Sound_and_music_status|<code>stat(16..23)</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Music</h2>{{ApiReference
|name=music
|shortdesc=Plays a music pattern, or stops playing.
|n||The pattern number to start playing (0-63), or -1 to stop playing music.
|fadems|optional|If not 0, fade in (or out) the music volume over a duration, given as a number of milliseconds.
|channelmask|optional|A bitfield indicating which of the four sound channels should be reserved for music. The default is 0 (no channels reserved).
}}
A music pattern describes a part of a song to play as background music. The pattern assigns sound effects to one or more of the PICO-8's four sound channels, with instructions to proceed to the next pattern, loop, or end when the sounds end. Typically, sound effects associated with music patterns are a collection of notes played at the intended tempo.

A call to <code>music()</code> can include a <span style="font-style:italic;">channel mask</span> to declare which sound channels should not be interrupted by a sound effect played by a call to [[Sfx|sfx()]]. The channel mask is a bield, where the four channels are represented by the bit values 1, 2, 4, and 8, respectively. A call to [[Sfx|sfx()]] may still take over a channel reserved by the music pattern if it specifies an explicit channel number.

When using music and sound effects together, it is a good idea to set a channel mask that reserves some channels and leaves others open for effects. PICO-8 will prioritize the use of the unmasked channels for sound effects, giving both music and sound a chance to play.

It should be noted that it is only necessary to call <code>music()</code> once, to trigger playback. PICO-8 will continue playback independently afterwards. It is not necessary to call it every frame with the current music ID--in fact, doing so will cause the track to be stuck on the first note perpetually, as the music restarts over and over.<h4>Examples</h4><pre>
-- start music from pattern 0
music(0)

-- stop the music with a 300 ms fade out
music(-1, 300)

-- start music from pattern 4, reserving channels 2 and 3 (4 + 8)
music(4, 0, 12)
</pre><h4>See also</h4><ul><li>[[Sfx|<code>sfx()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Map</h2>{{ApiReference
|name=map
|shortdesc=Draws a portion of the map to the graphics buffer.
|celx||The column location of the map cell in the upper left corner of the region to draw, where 0 is the leftmost column.
|cely||The row location of the map cell in the upper left corner of the region to draw, where 0 is the topmost row.
|sx||The x coordinate of the screen to place the upper left corner.
|sy||The y coordinate of the screen to place the upper left corner.
|celw||The number of map cells wide in the region to draw.
|celh||The number of map cells tall in the region to draw.
|layer|optional|If specified, only draw sprites that have flags set for every bit in this value (a bitfield). The default is 0 (draw all sprites).
}}

<sup>Note: <code>mapdraw()</code> is the original name for this function, and may still be found in older carts.  Its use is [[deprecated]].</sup>

The map is a grid of sprites from the sprite sheet, where each cell in the grid is assigned a sprite number. You can edit the map using the PICO-8 map editor. You call the <code>map()</code> function to draw a region of the map (a subsection of the grid cells) onto the screen.

You can use the map to draw large pictures by reusing sprite tiles in multiple cells. This is more memory efficient than drawing large images in pixels with the sprite editor, and easier to use than storing tables of sprite numbers in code.

Any map cell set to sprite number 0 is not drawn, effectively making that cell transparent. You can use this along with using the transparent color for pixels in sprites to make regions of transparency in the image. A common technique is to layer multiple maps on top of one another, then animate the positions of these layers to produce effects such as parallax scrolling.

Another use for maps is to design interactive levels or areas of a game world. When doing this, it is often necessary to determine which sprite is at a given location on the map, such as to determine whether a location next to the player is an obstruction. See [[Mget|mget()]].

<span style="font-weight:bold;">Note:</span> The sprite data region and the map data region overlap in memory. If you are using this shared memory for sprite data and you specify map coordinates for that memory (<code>cely > 31</code>), <code>map()</code> will attempt to interpret the sprite data as map data. See [[Graphics]] and [[Memory]].<h4>Examples</h4><pre>
-- fill the screen with the map region starting at row 0 column 16
map(16, 0, 0, 0, 16, 16)
</pre>

<code>map()</code> works well in conjunction with [[Camera|camera()]] to pan over a large region, such as in a platform game. Here is a full-screen map viewer that demonstrates the use of [[Camera|camera()]] in this way. Use cursor keys to move the camera.
<pre>
-- the coordinates of the upper left corner of the camera
cam_x = 0
cam_y = 0

function _update()
  if (btn(0) and cam_x > 0) cam_x -= 1
  if (btn(1) and cam_x < 895) cam_x += 1
  if (btn(2) and cam_y > 0) cam_y -= 1
  if (btn(3) and cam_y < 127) cam_y += 1
  -- (the camera stops with the bottom of
  -- the screen at row 32.)
end

function _draw()
  cls()
  -- set the camera to the current location
  camera(cam_x, cam_y)

  -- draw the entire map at (0, 0), allowing
  -- the camera and clipping region to decide
  -- what is shown
  map(0, 0, 0, 0, 128, 32)

  -- reset the camera then print the camera
  -- coordinates on screen
  camera()
  print('('..cam_x..', '..cam_y..')', 0, 0, 7)
end
</pre>

[[Jelpi]], a game included with PICO-8, uses <code>mapdraw()</code>, which is the [[deprecated]] name for <code>map()</code>.  Jelpi draws the background in multiple layers, and to define the level layout. A moving image of clouds is drawn behind the fixed image of a mountain, with both images defined in the map data by sprites. The cloud layer is animated by adjusting the <code>sx</code> value for <code>map()</code>.<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Mget|<code>mget()</code>]]</li><li>[[Mset|<code>mset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Mget</h2>{{ApiReference
|name=mget
|shortdesc=Gets the sprite number assigned to a cell on the map.
|celx||The column (x) coordinate of the cell.
|cely||The row (y) coordinate of the cell.
}}
The <code>mget()</code> function returns the sprite number assigned to a cell on the map. If a cell was modified by a call to [[Mset|mset]], <code>mget()</code> returns the updated value.

When using the map to store level designs, a common technique is to keep track of the player's effective cell position on the map, then use <code>mget()</code> to look for adjacent level features such as obstructions. This can be combined with sprite flags (read with [[Fget|fget()]]) to indicate which sprite tiles represent obstructions, so a general purpose test for obstructions only needs to read the flags.<h4>Examples</h4><pre>
to_the_right = mget(player.celx + 1, player.cely)
</pre><h4>Notes</h4>This function works only when the tiles are drawn by map() function.<h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Map|<code>map()</code>]]</li><li>[[Mset|<code>mset()</code>]]</li><li>[[Fget|<code>fget()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Mset</h2>{{ApiReference
|name=mset
|shortdesc=Sets a cell on the map to a new sprite number.
|celx||The column (x) coordinate of the cell.
|cely||The row (y) coordinate of the cell.
|snum||The new sprite number to store.
}}
The <code>mset()</code> function modifies the map data.

A simple use of <code>mset()</code> is to place or remove objects on the map, such as a treasure that the player can pick up. This allows for the level designer to set the initial locations of objects.

In a more sophisticated version of this technique, the program can scan the map for objects with [[Mget|mget()]], store their locations in a table, then erase them from the map data and draw them separately. This may make the objects easier to animate or participate in physics simulation.

Advanced techniques that use <code>mset()</code> include generating levels procedurally, or storing very large maps as compressed data and decompressing it into the map region as needed. In both cases, once the maps are written to memory, the game engine can use [[Map|map()]] to draw the level to the screen.

Setting values on the map changes the data in memory, but does not change the cartridge. A program can restore the original data from the cartridge with [[Reload|reload()]], and can save the modified data to the cart with [[Cstore|cstore()]]. See [[Memory]] for information about the memory addresses to use.<h4>Examples</h4><pre>
gems = {}

-- scan a region of the map for gems
-- (sprite 16), store their locations
-- in the gems table, then delete them
-- from the map data
for x=0,15 do
  for y=0,15 do
    if mget(x, y) == 16 then
      add(gems, {x, y})
      mset(x, y, 0)
    end
  end
end
</pre><h4>See also</h4><ul><li>[[Graphics]]</li><li>[[Map|<code>map()</code>]]</li><li>[[Mget|<code>mget()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Peek</h2>{{ApiReference
|name=peek
|shortdesc=Reads a byte from a memory location.
|addr||The address of the memory location.
}}
The <code>peek()</code> function reads a byte from the addressable memory region (0x000-0x7fff). See [[Memory]] for information about the memory layout.

See <code>[[Peek2|peek2()]]</code> for a way to read a 16-bit value from two consecutive memory addresses, and <code>[[Peek4|peek4()]]</code> to read a 32-bit value from four consecutive memory addresses.<h4>Examples</h4><pre>
b = peek(0x4300)
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Peek2|<code>peek2()</code>]]</li><li>[[Poke2|<code>poke2()</code>]]</li><li>[[Peek4|<code>peek4()</code>]]</li><li>[[Poke4|<code>poke4()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Poke</h2>{{ApiReference
|name=poke
|shortdesc=Writes a byte to a memory location.
|addr||The address of the memory location.
|val||The byte value.
}}
The <code>poke()</code> function writes a byte to the addressable memory region (0x000-0x7fff). See [[Memory]] for information about the memory layout.

See <code>[[Poke2|poke2()]]</code> for a way to write a 16-bit value to two consecutive memory addresses, and <code>[[Poke4|poke4()]]</code> to write a 32-bit value to four consecutive memory addresses.<h4>Examples</h4><pre>
poke(0x4300, 255)
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Peek2|<code>peek2()</code>]]</li><li>[[Poke2|<code>poke2()</code>]]</li><li>[[Peek4|<code>peek4()</code>]]</li><li>[[Poke4|<code>poke4()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Memcpy</h2>{{ApiReference
|name=memcpy
|shortdesc=Copies a region of memory to another location in memory.
|destaddr||The address of the first byte of the destination.
|sourceaddr||The address of the first byte of the memory to copy.
|len||The length of the memory region to copy, as a number of bytes.
}}
The <code>memcpy()</code> function quickly copies one region of addressable memory to another. The origin region and the destination region may overlap.

See [[Memory]] for information about the memory layout.<h4>Examples</h4><pre>
memcpy(0x5e00, 0x4300, 128)
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Reload</h2>{{ApiReference
|name=reload
|shortdesc=Loads a region of data from the cartridge, or from another cartridge, into memory.
|destaddr||The address of the first byte of the destination in memory.
|sourceaddr||The address of the first byte in the cartridge data.
|len||The length of the memory region to copy, as a number of bytes.
|filename|optional|If specified, the filename of a cartridge from which to read data. The default is to read from the currently loaded cartridge.
}}
The <code>reload()</code> function copies data from the cartridge into a location in memory.

Cartridge data is copied to memory addresses 0x0000-0x4300 when the cartridge is loaded for the first time. After that point, the program is allowed to modify memory with [[Memcpy|memcpy()]], [[Poke|poke()]], [[Mset|mset()]], [[Sset|sset()]], or [[Fset|fset()]]. These operations do not modify the original cartridge data. You can use <code>reload()</code> to restore modified data, or otherwise access data that has been overwritten in memory.

If the optional filename argument is provided, <code>reload()</code> will attempt to load from that cartridge file, which does not need to be the currently loaded cartridge. You can use this to store large amounts of game data over multiple cartridges.

<code>reload()</code> is equivalent to <code>reload(0, 0, 0x4300)</code>.

The memory layout for cartridge data is identical to PICO-8 memory for the address region 0x0000-0x4300. See [[Memory]] for an explanation of memory and cartridge data, and for a description of the memory layout.

Note: When loading data from a named file, the current cart must be saved to disk. If <code>reload()</code> is called with a filename but it appears to be loading from the current cart instead, try saving the current cart with a name, rebooting, and reloading the cart.<h4>Examples</h4>Consider a game that stores the locations of collectible treasures in the map data, and removes them from the map with [[Mset|mset()]] when the player collects them. To reload the original map data from the cartridge:
<pre>
reload(0x2000, 0x2000, 0x1000)
</pre>

Consider a game that uses very large maps stored in multiple cartridges. To load the map for a new area from cartridges stored in carts named <code>"biggame_lvl1.p8"</code>, <code>"biggame_lvl2.p8"</code>, etc.:
<pre>
function load_area(lvl)
  reload(0x2000, 0x2000, 0x1000, 'biggame_lvl'..lvl..'.p8')
end

load_area(2)
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Cstore</h2>{{ApiReference
|name=cstore
|shortdesc=Store a region of memory in the cartridge file, or another cartridge file.
|destaddr||The address of the first byte of the destination in the cartridge.
|sourceaddr||The address of the first byte in memory to copy.
|len||The length of the memory region to copy, as a number of bytes.
|filename|optional|If specified, the filename of a cartridge to which data is written. The default is to write to the currently loaded cartridge. 
}}
The <code>cstore()</code> function copies a region of memory to the cartridge, modifying the cartridge file.

This is useful for building PICO-8 development tools inside PICO-8, such as a specialized graphics editor that saves sprite or map data to another cartridge.

You can load data from an arbitrary cartridge file using the [[Reload|reload()]] function.

If a filename is provided and there exists a cartridge with that name, the data is patched into the appropriate location. If there is no file with the given name, a new empty cartridge is created with the data patched in. Unlike [[Reload|reload()]], the filename must end in <code>.p8</code> or <code>.p8.png</code> if the intended cartridge file has that extension. (The filename extension is not inferred from existing files.)

This feature only works in the PICO-8 app, and does not work in the web player or [[Forum]].

The memory layout for cartridge data is identical to PICO-8 memory for the address region 0x0000-0x4300. See [[Memory]] for an explanation of memory and cartridge data, and for a description of the memory layout.

<span style="font-weight:bold;">Caution:</span> The <code>cstore()</code> function modifies the cartridge file. This operation cannot be undone. Be sure to keep a copy of your original cartridge files, and test to make sure data is written to the correct file and memory location.<h4>Examples</h4>Consider a utility cartridge that generates map data and saves it to a different cartridge:
<pre>
-- generate some map data
generate_map()

-- save the map data to a separate cartridge
cstore(0x2000, 0x2000, 0x1000, 'mygame.p8')
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Memset</h2>{{ApiReference
|name=memset
|shortdesc=Writes a byte value to every address in a region of memory.
|destaddr||The address of the first memory location to write.
|val||The byte value to write.
|len||The length of the region of memory to write, as a number of bytes.
}}
The <code>memset()</code> function is a fast way to fill a region of memory with one byte value.<h4>Examples</h4><pre>
-- clear all user data
memset(0x4300, 0, 0x1b00)

-- fill the screen with white
-- (equivalent to rectfill(0,0,128,128,7))
memset(0x6000, 0x77, 0x2000)
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Max</h2>{{ApiReference
|name=max
|shortdesc=Returns the maximum of two numbers.
|first||The first number.
|second|optional|The second number. (default 0)
}}<h4>Examples</h4><pre>
print(max(40, 20))    -- 40

print(max(2.7, -3.5)) -- 2.7

print(max(8, 8))      -- 8

print(max(5))         -- 5

print(max(-5))        -- 0
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Min|<code>min()</code>]]</li><li>[[Mid|<code>mid()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Min</h2>{{ApiReference
|name=min
|shortdesc=Returns the minimum of two numbers.
|first||The first number.
|second|optional|The second number. (default 0)
}}<h4>Examples</h4><pre>
print(min(40, 20))    -- 20

print(min(2.7, -3.5)) -- -3.5

print(min(8, 8))      -- 8

print(min(5))         -- 0

print(min(-5))        -- -5
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Max|<code>max()</code>]]</li><li>[[Mid|<code>mid()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Mid</h2>{{ApiReference
|name=mid
|shortdesc=Returns the middle of three numbers. Also useful for clamping.
|first||The first number.
|second||The second number.
|third||The third number.
}}

This function is designed simply to give you the middle value out of three.

However, one of its best uses is frequently overlooked: it can clamp a value to a range.

If you call <code>mid(min_val,val_to_clamp,max_val)</code>, it acts exactly like the similarly-formatted <code>clamp()</code> function in other languages.  The result will be <code>min_val</code> if val is too low, <code>max_val</code> if val is too high, and <code>val</code> itself if it is in range.<h4>Examples</h4><pre>
print(mid(8, 2, 4))           -- 4

print(mid(-3.5, -3.4, -3.6))  -- -3.5

print(mid(6, 6, 8))           -- 6

-- clamp to 0..1
print(mid(0, v, 1))

-- sort three values
v0 = min(min(a,b),c)
v1 = mid(a,b,c)
v2 = max(max(a,b),c)
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Max|<code>max()</code>]]</li><li>[[Min|<code>min()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Flr</h2>{{ApiReference
|name=flr
|shortdesc=Returns the integer portion (the "floor") of a number.
|num||The number.
}}

If the given number is a fractional value between integers, the next lowest integer is returned.

If the given number is an integer already, it is returned as-is.<h4>Examples</h4><pre>
print(flr(5.9))   -- 5

print(flr(-5.2))  -- -6

print(flr(7))     -- 7

print(flr(-7))    -- -7
</pre><h4>See also</h4><ul><li>[[Ceil|<code>ceil()</code>]]</li></ul><ul><li>[[Math]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Abs</h2>{{ApiReference
|name=abs
|shortdesc=Returns the absolute value of a number.
|num||The number.
}}
The absolute value of a number is a number with the same magnitude, ignoring the sign.<h4>Examples</h4><pre>
print(abs(3.1))   -- 3.1

print(abs(-3.1))  -- 3.1

print(abs(0))     -- 0
</pre><h4>See also</h4><ul><li>[[Math]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sqrt</h2>{{ApiReference
|name=sqrt
|shortdesc=Calculates the square root of a number.
|num||The number. Must be positive.
}}
The <code>sqrt()</code> function calculates the square root of a positive number.

When given a negative number, <code>sqrt()</code> returns a result, but it isn't useful.<h4>Examples</h4><pre>
print(sqrt(9))     -- 3

print(sqrt(0.25))  -- 0.5
</pre><h4>See also</h4><ul><li>[[Math]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rnd</h2>{{ApiReference
|name=rnd
|shortdesc=Generates a random number between 0 and the given maximum.
|max||The range, non-inclusive.
}}
The <code>rnd()</code> function returns a random number in a range. The result ranges from 0 up the given <code>max</code>, but will never be the <code>max</code> value itself. For instance, <code>rnd(10)</code> can return from 0 up to 9.99999, but will never return 10.

The random number includes a fractional part. To get a random integer, use <code>flr(rnd(max))</code>.

The random number generator is initialized with an unpredictable seed value when PICO-8 starts. You can reinitialize the generator with an explicit seed (such as to test random behaviors with a known sequence) using [[Srand|srand()]].<h4>Working with ranges</h4>To select a random number between a minimum and a maximum, call <code>rnd()</code> with the size of the range, then add the minimum:
<pre>
x = rnd(32) + 64       -- a random number between 64 and 96
scale = rnd(20) - 10   -- a random number between -10 and 10
die = flr(rnd(6)) + 1  -- a random integer between 1 and 6
</pre>

To select a random fraction with a fixed number of decimal digits, use <code>flr(rnd(...))</code> with the range times the precision, then divide by the precision:
<pre>
earnings = flr(rnd(50 * 100)) / 100  -- between 0.00 and 50.00
</pre><h4>Alternate ranges</h4>{{UndocumentedFeature}}

<code>rnd()</code> called with a negative value for <code>max</code> returns a random value in the range of all numbers, from -32768.0 (0x8000.0000) up to +32767.99999 (0x7fff.ffff).

<code>rnd()</code> called without a <code>max</code> value (<code>nil</code>) returns a random value in the range from 0.0 up to 0.99999 (0x0.ffff).

<code>rnd()</code> appears to accept a negative <code>max</code> value, treating the number as if it is unsigned when it computes the range for the output, thus the result may overflow the range and wrap to negative.<h4>Examples</h4><pre>
print(rnd(20))       -- for example, 3.837

print(flr(rnd(20)))  -- for example, 17

-- note this is the same as rnd(0xffff)
print(rnd(-1))       -- for example, -1734.56 or 13744.63
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Srand|<code>srand()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Srand</h2>{{ApiReference
|name=srand
|shortdesc=Initializes the random number generator with an explicit seed value.
|val||The seed value.
}}
The random number generator used by [[Rnd|rnd()]] is initialized with an unpredictable seed value when PICO-8 starts. You can reinitialize the generator with an explicit seed using <code>srand()</code>.

This is mostly useful for testing random behaviors in your game with a known sequence. You can call <code>srand()</code> before a call to <code>rnd()</code> and get a predictable result.<h4>Examples</h4><pre>
print(rnd(20))   -- unpredictable, for example 3.837
print(rnd(20))   -- unpredictable, for example 19.089

srand(1)
print(rnd(20))   -- 7.081
print(rnd(20))   -- 1.989
print(rnd(20))   -- 16.593

srand(1)
print(rnd(20))   -- 7.081
print(rnd(20))   -- 1.989
print(rnd(20))   -- 16.593
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Rnd|<code>rnd()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Band</h2>{{ApiReference
|name=band
|shortdesc=Calculates the bitwise and of two numbers.
|first||The first number.
|second||The second number.
}}<h4>Examples</h4><pre>
--     0x7 = 0111 binary
-- and 0xd = 1101 binary
-- -------
--     0x5 = 0101 binary
print(band(0x7, 0xd))  -- 5
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Bor</h2>{{ApiReference
|name=bor
|shortdesc=Calculates the bitwise or of two numbers.
|first||The first number.
|second||The second number.
}}<h4>Examples</h4><pre>
--     0x5 = 0101 binary
--  or 0x9 = 1001 binary
-- -------
--     0xd = 1101 binary
print(bor(0x5, 0x9))  -- 13 (0xd)
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Bxor</h2>{{ApiReference
|name=bxor
|shortdesc=Calculates the bitwise exclusive or of two numbers.
|first||The first number.
|second||The second number.
}}<h4>Examples</h4><pre>
--     0x5 = 0101 binary
-- xor 0x9 = 1001 binary
-- -------
--     0xc = 1100 binary
print(bxor(0x5, 0x9))  -- 12 (0xc)
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Bnot</h2>{{ApiReference
|name=bnot
|shortdesc=Calculates the bitwise not of a number.
|num||The number.
}}
The <code>bnot()</code> function inverts all of the bits of a number.

Numbers in PICO-8 are stored using a 32-bit <span style="font-style:italic;">fixed point</span> format, with 16 bits for the integer portion, 16 bits for the fractional portion, and a twos complement representation for negative and positive values. As a result, the bitwise-not of a number tends to be its negative. (<code>bnot(0)</code> is almost 0, but not quite.)

In cases where you're using <code>bnot()</code> you probably only care about specific bits and not the entire number. You can <code>band()</code> the result to mask out the bits you don't care about.<h4>Examples</h4><pre>
--               0xb = 000...1011
--           not 0xb = 111...0100
--               0xf = 000...1111
-- (not 0xb) and 0xf = 000...0100 (0x4)
print(band(bnot(0xb), 0xf))  -- 4

print(bnot(0xb))             -- -11 (0 - 0xb)
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Shl</h2>{{ApiReference
|name=shl
|shortdesc=Shifts the bits of a number to the left.
|num||The number.
|bits||The number of bits to shift.
}}
The <code>shl()</code> function takes a number and a bit count, and returns the result of shifting the bits of the number to the left by that count.

Numbers in PICO-8 are stored using a 32-bit <span style="font-style:italic;">fixed point</span> format, with 16 bits for the integer portion, 16 bits for the fractional portion, and a twos complement representation for negative and positive values. Bit shifting uses the entire number representation. (See examples below.)<h4>Examples</h4><pre>
-- 1 = 00000001 binary
-- 8 = 00001000 binary
print(shl(1, 3))      -- 8

-- 0.125 = 0000.0010 binary
-- 1.000 = 0001.0000 binary
print(shl(0.125, 3))  -- 1
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Shr</h2>{{ApiReference
|name=shr
|shortdesc=Shifts the bits of a number to the right.
|num||The number.
|bits||The number of bits to shift.
}}
The <code>shr()</code> function takes a number and a bit count, and returns the result of shifting the bits of the number to the right by that count.

Numbers in PICO-8 are stored using a 32-bit <span style="font-style:italic;">fixed point</span> format, with 16 bits for the integer portion, 16 bits for the fractional portion, and a [https://en.wikipedia.org/wiki/Two%27s_complement Two's Complement] representation for negative and positive values. Bit shifting uses the entire number representation. (See examples below.)

<code>shr()</code> performs an "arithmetic shift," which means that the sign of the number is preserved. Arithmetic right shift preserves the highest bit while also shifting a copy of it to the right, which effectively preserves the sign in Two's Complement representation.

The alternative to arithmetic shift is "logical shift." See [[Lshr|lshr()]].<h4>Examples</h4><pre>
-- 8 = 0b00001000 binary
-- 1 = 0b00000001 binary
print(shr(8, 3))  -- 1

-- 1.000 = 0b0001.0000 binary
-- 0.125 = 0b0000.0010 binary
print(shr(1, 3))  -- 0.125

-- -1.000 = 0b1111111111111111.0 binary (two's complement)
-- -0.125 = 0b1111111111111111.111 binary
print(shr(-1,3))  -- -0.125
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sin</h2>{{ApiReference
|name=sin
|shortdesc=Calculates the sine of an angle.
|angle||The angle, using a full circle range of 0.0-1.0 measured clockwise (0.0 to the right).
}}
The <code>sin()</code> function calculates the sine of an angle.

PICO-8 uses an input range of 0.0 to 1.0 to represent the angle, a percentage of the unit circle. Some refer to these units as "turns". For instance, 180° or π (3.14159) radians corresponds to 0.5 turns in PICO-8's representation of angles. In fact, for fans of τ (tau), it's just a matter of dropping τ from your expression.

<span style="font-weight:bold;">Important:</span> PICO-8 measures the angle in a <span style="font-style:italic;">clockwise</span> direction on the Cartesian plane, with 0.0 to the right, 0.25 downward, and so on. This is inverted from the convention used in traditional geometry, though the inversion only affects <code>sin()</code>, not [[Cos|<code>cos()</code>]].
[[File:Pico8sincos v2.png|center|319x242px]]

The inversion is useful because PICO-8's screen (like most graphics engines) uses inverted y coordinates: an increase in y goes downward. Many uses of <code>sin()</code> would need to be inverted anyway, so PICO-8 does it by convention.

(The clockwise direction of the angle is equivalent to going counterclockwise and negating <code>sin()</code>. This is how it is described in the official documentation.)<h4>Examples</h4><pre>
for t=0,1,0.125 do
  print('sin('..t..') = '..sin(t))
end
</pre>

prints:

<pre>
sin(0) = 0
sin(0.125) = -0.7071
sin(0.25) = -1
sin(0.375) = -0.7071
sin(0.5) = 0
sin(0.625) = 0.7071
sin(0.75) = 1
sin(0.875) = 0.7071
sin(1) = 0
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Cos|<code>cos()</code>]]</li><li>[[Atan2|<code>atan2()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Cos</h2>{{ApiReference
|name=cos
|shortdesc=Calculates the cosine of an angle.
|angle||The angle, using a full circle range of 0.0-1.0.
}}
The <code>cos()</code> function calculates the cosine of an angle.

PICO-8 uses an input range of 0.0 to 1.0 to represent the angle, a percentage of the unit circle. Some refer to these units as "turns". For instance, 180° or π (3.14159) radians corresponds to 0.5 turns in PICO-8's representation of angles. In fact, for fans of τ (tau), it's just a matter of dropping τ from your expression.

<span style="font-weight:bold;">Important:</span> PICO-8 measures the angle in a <span style="font-style:italic;">clockwise</span> direction on the Cartesian plane, with 0.0 to the right, 0.25 downward, and so on. This is inverted from the convention used in traditional geometry, though the inversion only affects [[Sin|<code>sin()</code>]], not <code>cos()</code>.
[[File:Pico8sincos v2.png|center|319x242px]]<h4>Examples</h4><pre>
for t=0,1,0.125 do
  print('cos('..t..') = '..cos(t))
end
</pre>

prints:

<pre>
cos(0) = 1
cos(0.125) = 0.7071
cos(0.25) = 0
cos(0.375) = -0.7071
cos(0.5) = -1
cos(0.625) = -0.7071
cos(0.75) = 0
cos(0.875) = 0.7071
cos(1) = 1
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Sin|<code>sin()</code>]]</li><li>[[Atan2|<code>atan2()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Atan2</h2>{{ApiReference
|name=atan2
|shortdesc=Calculates the arctangent of dy/dx, the angle formed by the vector on the unit circle. The result is adjusted to represent the full circle.
|dx||The horizontal component.
|dy||The vertical component.
}}
The <code>atan2()</code> function calculates the arctangent (the inverse tangent) of the ratio of two numbers, dy/dx. Where dx is a change in horizontal position and dy is a change in vertical position, the arctangent is the angle formed by the line from the center of the circle to that position.

PICO-8 adjusts the arctangent value based on the signs of dx and dy such that every angle of the circle is represented. For example, <code>atan2(1, 1)</code> is <code>0.875</code> (7/4 pi radians, or 315 degrees), and <code>atan2(-1, -1)</code> is <code>0.375</code> (3/4 pi radians, or 135 degrees). Similarly, <code>atan2(0, 1)</code> is <code>0.75</code>.

The Wikia articles on [[Sin|sin()]] and [[Cos|cos()]] establish a convention where the angle runs clockwise and sine values maintain the traditional orientation, e.g. <code>sin(0.125)</code> is <code>-0.7071</code> (negative goes down):
[[File:Pico8sincos v2.png|center|319x242px]]

Using this convention, you must invert the sign of dy to understand the result of <code>atan2()</code>.

The official PICO-8 documentation use the alternative convention, where angles run counterclockwise and <code>sin()</code> is simply understood to return the negative of the traditional result. This convention allows the arguments to <code>atan2()</code> to be understood as changes in screen coordinates (increasing y values go down). The two conventions are mathematically equivalent.<h4>Examples</h4><pre>
print(atan2(1, 0))    -- 0
print(atan2(1, 1))    -- 0.875
print(atan2(0, 1))    -- 0.75
print(atan2(-1, 1))   -- 0.625
print(atan2(-1, 0))   -- 0.5
print(atan2(-1, -1))  -- 0.375
print(atan2(0, -1))   -- 0.25
print(atan2(1, -1))   -- 0.125

-- longer vector uses the ratio
print(atan2(99, 99))  -- 0.875

-- special case: dx=0, dy=0
print(atan2(0, 0))  -- 0.75
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Cos|<code>cos()</code>]]</li><li>[[Sin|<code>sin()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Assert</h2>{{ApiReference
|name=assert
|shortdesc=Causes a runtime error if a conditional expression is false.
|cond||The conditional expression to assert.
|message|optional|A message to print when the assertion fails.
}}
You use <code>assert()</code> to confirm that your program is behaving as you expect it to at a specific point in the code. If the conditional expression evaluates to false, <code>assert()</code> triggers a runtime error, and PICO-8 stops the program and reports the error and line number of the assert.

As of PICO-8 v0.1.11, <code>assert()</code> can take an optional message that replaces the default message "assertion failed".

<span style="font-weight:bold;">Caution:</span> As of PICO-8 v0.1.6, a runtime error in a coroutine aborts the coroutine but does not report the error. See [[Coresume|<code>coresume()</code>]].<h4>Examples</h4><pre>
function divide(num, denom)
  assert(denom != 0, 'cannot divide by zero')
  return num/denom
end

print(divide(12, 4))  -- 3
print(divide(7, 0))   -- runtime error, assertion failed
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Stop|<code>stop()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Yield</h2>{{ApiReference
|name=yield
|shortdesc=Yields control back to the caller from within a coroutine.
}}
A coroutine is a special kind of function that can yield control back to the caller without completely exiting. The caller can then resume the coroutine as many times as needed until the function exits.

The coroutine calls <code>yield()</code> to suspend the coroutine and return control back to the caller in this way. It does not accept any values. (Lua and other languages support yielding and returning values from coroutines, but PICO-8 does not.)

<code>yield()</code> returns all extra arguments passed to the <code>coresume()</code> that resumed it.

To terminate the coroutine, the function returns with the <code>return</code> statement. After this point, the coroutine is considered dead and cannot be resumed.<h4>Examples</h4>See [[Cocreate|cocreate()]] and [[Coresume|coresume()]] for examples.<h4>See also</h4><ul><li>[[Cocreate|<code>cocreate()</code>]]</li><li>[[Coresume|<code>coresume()</code>]]</li><li>[[Costatus|<code>costatus()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Costatus</h2>{{ApiReference
|name=costatus
|shortdesc=Tests whether a coroutine is suspended (returns true) or dead (returns false).
|cor||The coroutine to test.
}}
A coroutine is a special kind of function that can yield control back to the caller without completely exiting. The caller can then resume the coroutine as many times as needed until the function exits.

The <code>costatus()</code> function takes a coroutine object and returns its status as a string value, either <code>'running' 'suspended'</code> or <code>'dead'</code>. You can use this to test whether the most recent call to [[Coresume|<code>coresume()</code>]] yielded or terminated.<h4>Technical notes</h4>When a coroutine dies unexpectedly, this status merely goes to <code>'dead'</code>, but additional information is also available about the reason and the location. See [[Coresume|<code>coresume()</code>]] and [[Trace|<code>trace()</code>]] for details.<h4>Examples</h4>See [[Cocreate|<code>cocreate()</code>]] for an example.<h4>See also</h4><ul><li>[[Cocreate|<code>cocreate()</code>]]</li><li>[[Coresume|<code>coresume()</code>]]</li><li>[[Yield|<code>yield()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Coresume</h2>{{ApiReference
|name=coresume
|shortdesc=Starts a coroutine, or resumes a suspended coroutine.
|cor||The coroutine, as created by [[Cocreate|<code>cocreate()</code>]].
|...|optional|The arguments to pass to the coroutine's function or the coroutine's subsequent yields.}}
A coroutine is a special kind of function that can yield control back to the caller without completely exiting. The caller can then resume the coroutine as many times as needed until the function exits.

The <code>coresume()</code> function starts or resumes a coroutine created by [[Cocreate|<code>cocreate()</code>]]. Control returns to the coroutine function until the function yields or exits.

<code>coresume()</code> returns <code>true</code> if the given coroutine was active (suspended) when <code>coresume()</code> was called, or <code>false</code> if it was given a dead coroutine (and no code was executed by resuming). If a resumed coroutine function exits (rather than yields), the coroutine goes from suspended to dead, and a subsequent call to <code>coresume()</code> with the same coroutine will return <code>false</code>. It is more typical to use the [[Costatus|<code>costatus()</code>]] function to test the status of a coroutine, but the return value from <code>coresume()</code> may be used instead.

In the event that <code>coresume()</code> returns <code>false</code>, it <span style="font-style:italic;">may</span> also return a second value containing a string describing an exception that caused the routine to die unexpectedly, e.g. "attempt to index a nil value". A full stack trace can also be obtained by passing the dead coroutine to [[Trace|<code>trace()</code>]]. In fact, the code below is a very simple way to [[Stop|<code>stop()</code>]] with full stack trace when a coroutine dies unexpectedly:
<pre>
local active, exception = coresume(co)
if exception then
  stop(trace(co, exception))
end
</pre>

<code>coresume()</code> may also return <code>true</code> if the coroutine did not finish executing in time, even if it didn't return or yield. In this case, the coroutine remains in the suspended state and can be resumed later, just as if it explicitly yielded.

PICO-8's <code>coresume()</code> does not return a value from the coroutine function, nor can [[Yield|<code>yield()</code>]] accept a value. If the function exits by returning a value, this value is ignored. (Lua and other languages support yielding and returning values from coroutines, but PICO-8 does not.)

<code>coresume()</code> may pass extra arguments to the coroutine. These arguments will be mapped to the coroutine's function arguments on the first call, and will be used as return values for [[Yield|<code>yield()</code>]] on subsequent calls.<h4>Examples</h4><pre>
function foo(a, b, c)
  print(a)
  print(b)
  print(c)
  a, _, c = yield()
  print(a)
  print(b)
  print(c)
end

local thread = cocreate(foo)
coresume(thread, 1, 2, 3) --> prints: 1 2 3
coresume(thread, 4, 5, 6) --> prints: 4 2 6
</pre>

See [[Cocreate|<code>cocreate()</code>]] for a general example.<h4>See also</h4><ul><li>[[Cocreate|<code>cocreate()</code>]]</li><li>[[Costatus|<code>costatus()</code>]]</li><li>[[Yield|<code>yield()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Cocreate</h2>{{ApiReference
|name=cocreate
|shortdesc=Creates a coroutine from a function.
|func||The coroutine function.
}}
A coroutine is a special kind of function that can yield control back to the caller without completely exiting. The caller can then resume the coroutine as many times as needed until the function exits.

To create a coroutine, call <code>cocreate()</code> with a function. This function is expected to take no arguments, to return no value, and to call [[Yield|<code>yield()</code>]] to temporarily return control to the caller. <code>cocreate()</code> returns the coroutine value that can be used to control execution of the function.

<code>cocreate()</code> does not call the coroutine function. Instead, the caller is expected to call [[Coresume|<code>coresume()</code>]] with the coroutine to start or resume execution of the function.

The coroutine function calls [[Yield|<code>yield()</code>]] to suspend execution and return control to the caller of [[Coresume|<code>coresume()</code>]]. The function can also call another function that calls [[Yield|<code>yield()</code>]], and the entire call stack will be preserved. The coroutine function continues from where it left off the next time you call <code>coresume()</code> with the coroutine object.

If the coroutine function returns instead of yields (such as by allowing control to reach the end of the function body, or by using <code>return</code>), the coroutine dies and cannot be revived by <code>coresume()</code>. You can test the status of a coroutine object by calling the [[Costatus|<code>costatus()</code>]] function.

Coroutines are useful for preserving the state of a function in progress for later continuation. It is a way to preserve state, and is well suited to pausing and resuming a sequence of actions that terminates. This works especially well with the PICO-8 [[GameLoop|game loop]] as a way to initiate an action that takes place over multiple frames.

<span style="font-weight:bold;">Caution:</span> As of PICO-8 v0.1.10, if a runtime error occurs inside a coroutine function, the function aborts, but instead of stopping the program and printing an error message, the coroutine dies and execution continues. This can make debugging coroutines difficult, as many common errors (such as incorrect nil values) manifest as runtime errors.<h4>Examples</h4>The following example uses a coroutine to animate a circle moving across the screen. The animation is initiated by pressing button 5.

<pre>
x=4
y=4
cor = nil

function anim()
  for i=4,124,4 do
    x=i
    y=i
    yield()
  end
end

function _update()
  if btnp(5) then
    cor = cocreate(anim)
  end
  if cor and costatus(cor) != 'dead' then
    coresume(cor)
  else
    cor = nil
  end
end

function _draw()
  cls()
  circfill(x, y, 4, 7)
end
</pre><h4>See also</h4><ul><li>[[Coresume|<code>coresume()</code>]]</li><li>[[Costatus|<code>costatus()</code>]]</li><li>[[Yield|<code>yield()</code>]]</li><li>[https://docs.google.com/document/d/14HzJnqKdVtBjN2vN9-rZHLR3rlgwWwDym8ehzhKRqFo/edit?usp=sharing Cutscenes and Coroutines] by dddaaannn</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Cartdata</h2>{{ApiReference
|name=cartdata
|shortdesc=Sets up cartridge data for the cart.
|id||A string that is likely to be unique across all PICO-8 carts.
}}
A cartridge can store 64 numbers (256 bytes) of data to persistent storage. This data is available the next time the user runs the cart, and persists in the player even if the cartridge is replaced with a new version of the same cartridge.

The <code>cartdata()</code> function sets up PICO-8's persistent cartridge data feature. It must be called once (and only once) by the cart before using [[Dset|<code>dset()</code>]] or [[Dget|<code>dget()</code>]].

The function takes a string ID that uniquely identifies the cartridge among all PICO-8 cartridges that might have persistent data. There is no central registry for cartdata IDs, and you're expected to not willfully overwrite data belonging to other carts. Likewise, you can purposefully use the same ID across multiple carts to share persistent data between carts, such as to implement a very large adventure game that requires multiple carts.

One reasonable way to derive a unique ID for your cart is to use the following pattern:

<code>username_title_version</code>

... where <code>username</code> is your PICO-8 BBS username, <code>title</code> is the title of the cartridge, and <code>version</code> is an optional version ID. You would only increment the version ID if a new version of the cart stores cart data in a format incompatible with previous versions.

Once <code>cartdata()</code> has been called, the data bytes can be accessed directly at memory locations 0x5e00 to 0x5eff. Using [[Poke|<code>poke()</code>]] to update these values persists the new value automatically, similar to [[Dset|<code>dset()</code>]].<h4>Examples</h4><pre>
function _init()
  cartdata("zep_jelpi_1")
  player_pos = dget(0)
  player_inventory = dget(1)
end

function save_game()
  dset(0, player_pos)
  dset(1, player_inventory)
end
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Dget|<code>dget()</code>]]</li><li>[[Dset|<code>dset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Dget</h2>{{ApiReference
|name=dget
|shortdesc=Gets a value from persistent cartridge data.
|index||The index of the value, 0 to 63.
}}
A cartridge can store 64 numbers (256 bytes) of data to persistent storage. This data is available the next time the user runs the cart, and persists in the player even if the cartridge is replaced with a new version of the same cartridge.

The <code>dget()</code> function retrieves the value for the given index (0 to 63).<h4>Examples</h4>See [[Cartdata|cartdata()]] for an example.<h4>See also</h4><ul><li>[[Cartdata|<code>cartdata()</code>]]</li><li>[[Dset|<code>dset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Dset</h2>{{ApiReference
|name=dset
|shortdesc=Sets a value in persistent cartridge data.
|index||The index of the value.
|value||The new value to set.
}}
A cartridge can store 64 numbers (256 bytes) of data to persistent storage. This data is available the next time the user runs the cart, and persists in the player even if the cartridge is replaced with a new version of the same cartridge.

The <code>dget()</code> function retrieves the value for the given index (0 to 63).<h4>Examples</h4>See [[Cartdata|cartdata()]] for an example.<h4>See also</h4><ul><li>[[Cartdata|<code>cartdata()</code>]]</li><li>[[Dget|<code>dget()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Setmetatable</h2>{{ApiReference
|name=setmetatable
|shortdesc=Updates the [[Metatables|metatable]] for a table.
|tbl||The table whose metatable to modify.
|metatbl||The new metatable.
}}
In [[Lua]], [[Tables|tables]] are general purpose objects that contain values and can be manipulated with operators. The default behaviors of operators on a table value are stored in its <span style="font-style:italic;">metatable</span>, using keys such as <code>__index</code> that refer to functions that perform the operator's task.

The <code>setmetatable()</code> function updates the metatable for a table, allowing you to customize the built-in operations. This has several useful applications for creating custom value types in Lua. For example, you can:<ul><li>Define a vector data type that supports arithmetic operators for addition and subtraction</li><li>Set comparison operators on a new value type to use it with a generic sorting routine, such as sorting displayable objects by their display depth</li><li>Implement inheritance: construct objects (tables) that refer to another table as a <span style="font-style:italic;">prototype</span> (or class) by setting the <code>__index</code> operator to access the prototype's properties</li></ul>As of v0.1.6, PICO-8 does <span style="font-style:italic;">not</span> support overwriting the <code>__tostring</code> metamethod. Tables cannot be concatenated with strings, nor can they be printed directly. You must explicitly convert your custom value types to a string before using them in this way.

PICO-8 includes Lua's [[Rawget|<code>rawget()</code>]], [[Rawset|<code>rawset()</code>]], [[Rawlen|<code>rawlen()</code>]], and [[Rawequal|<code>rawequal()</code>]] functions, which ignore custom <code>__index</code>, <code>__newindex</code>, <code>__len</code>, and <code>__eq</code> metamethods, respectively.

Note: The return value is just the input, <code>tbl</code>, given back to you, which can be convenient in pseudo-constructors. See <code>pixel:new()</code> in the example below for a demonstration.<h4>Metamethods</h4>A summary of the lua metamethods, as they pertain to pico-8.{| class="article-table"
|__index
|function(table, key) 

Can also be a table.
|Used when reading a non-existing key from the table.
Can be bypassed via [[Rawget|rawget()]]
|-
|__newindex
|function(table, key, value)
Can also be a table.
|Used when writing a non-existing key to the table.
Can be bypassed via [[Rawset|rawset()]]
|-
|__len
|function(table) 
|Called when getting the length of the table (via #).
Can be bypassed via [[Rawlen|rawlen()]]
|-
|__eq
|function(table1, table2) 
|Called when comparing two distinct tables via == or !=,
but only if both have the same __eq metamethod.

Can be bypassed via [[Rawequal|rawequal()]]
|-
|__lt
|function(value1, value2) 
|Called when comparing the table via < or >.
Also called when comparing via <= or >=, if __le isn't defined.
|-
|__le
|function(value1, value2) 
|Called when comparing the table via <= or >=.
|-
|__add
__sub

__mul

__div

__mod

__pow
|function(value1, value2) 
|Called when performing arithmetic on the table.
(Respectively: +, -, *, /, %, ^)
|-
|__unm
|function(table)
|Called when negating the table (via -).
|-
|__concat
|function(value1, value2) 
|Called when concatenating the table (via ..).
|-
|__call
|function(table, ...) 
|Called when calling the table as if it were a function.
|-
|__tostring
|function(table)
|Only implemented in 0.1.12d and up (not released yet!)
Called when calling [[Tostr|tostr()]], [[Print|print()]] and [[Printh|printh()]] on the table.

(Undocumented) bypassed by _tostr, _print and _printh.
|-
|__pairs
|function(table)
|Called when calling [[Pairs|pairs()]] on the table.
Can be bypassed by using [[Next|next()]] directly.
|-
|__ipairs
|<nowiki>-</nowiki>
|Not implemented in pico-8.
|-
|__metatable
|any value
|Returned instead of the real metatable when calling [[Getmetatable|getmetatable()]].
Also, its presence causes [[Setmetatable|setmetatable()]] to fail with an error.
|-
|__gc
|<nowiki>-</nowiki>
|Appears to not be implemented in pico-8.
|-
|__mode
|"k"/"v"/"kv"
|Specifies the table has weak keys/values.
(See lua reference manual for more details)
|}<h4>Examples</h4>The [https://www.lua.org/pil/13.1.html Lua documentation on metatables] includes an example of implementing a set container type, using metamethods to implement set unions and intersections with the <code>+</code> and <code>*</code> operators.

The [https://www.lua.org/pil/16.html Lua documentation on objects] demonstrates how to use the <code>__index</code> metamethod to implement inheritance.

geckojsc posted [http://www.lexaloffle.com/bbs/?tid=3342 a metatable tutorial demonstrating adding and subtracting vector values].

<pre>
-- default attribute values for a "pixel" class
pixel = {
  x = 0,
  y = 0,
  c = 7
}

-- the pixel class constructor
function pixel:new(o)
  self.__index = self
  return setmetatable(o or {}, self)
end

-- using the pixel class
p1 = pixel:new()
print(p1.x)   -- 0
print(p1.y)   -- 0

-- use an instance of pixel to subclass it
-- (prototypical inheritance)
newpixel = pixel:new({y=100})

p2 = newpixel:new()
print(p2.x)   -- 0
print(p2.y)   -- 100
</pre><h4>See also</h4><ul><li>[[Getmetatable|<code>getmetatable()</code>]]</li><li>[[Rawset|<code>rawset()</code>]]</li><li>[[Rawget|<code>rawget()</code>]]</li><li>[[Rawlen|<code>rawlen()</code>]]</li><li>[[Rawequal|<code>rawequal()</code>]]</li><li>[[Metatables]]</li><li>[[Tables]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Type</h2>{{ApiReference
|name=type
|shortdesc=Returns the basic type of a given value as a string.
|value||The value whose type to test.
}}
The <code>type()</code> function is similar to the corresponding Lua built-in function.<h4>Examples</h4><pre>
print(type(1))        -- "number"
print(type("hello"))  -- "string"
print(type(false))    -- "boolean"
print(type({}))       -- "table"
print(type(nil))      -- "nil"

function print_is_number(v)
  if type(v) == "number" then
    print("it's a number")
  else
    print("it's not a number")
  end
end
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Tostr|<code>tostr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sub</h2>{{ApiReference
|name=sub
|shortdesc=Gets the substring of a string.
|str||The string.
|start||The starting index, counting from 1 at the left, or -1 at the right.
|end|optional|The ending index, counting from 1 at the left, or -1 at the right. (default -1)
}}

The <code>start</code> and <code>end</code> indices are inclusive, which is to say the characters at both indices will be included in the result.  To extract a single character, use the same value for both, e.g. <code>sub(s,i,i)</code>.

Note that negative indices can be very useful. For instance, to get the rightmost four characters of a string, one simply writes <code>sub(s,-4)</code>.<h4>Examples</h4><pre>
print(sub("hello there", 1, 5))    -- hello
print(sub("hello there", -5))      -- there
</pre>

PICO-8 has no built-in way to associate characters with numbers. You can simulate this using a string as a look-up table:

<pre>
-- this example uses a limited subset, but 
-- you could also use escape codes to 
-- include all chars from '\1' to '\255'.
chars = ' !"#%\'()*+,-./0123456789:;<=>?abcdefghijklmnopqrstuvwxyz[]^_{~}'

function numtochar(v)
  return sub(chars, v, v)
end
</pre>

Converting a character back to a number is a bit more cumbersome but can be done by creating a reverse-lookup table from the string:

<pre>
charnums = {}
for i=1,#chars do
  charnums[sub(chars, i, i)] = i
end

function chartonum(c)
  return charnums[c] or 0
end
</pre><h4>See also</h4><ul><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Time</h2>{{ApiReference
|name=time
|shortdesc=Returns the amount of time since PICO-8 was last started, as a fractional number of seconds.
}}
The <code>time()</code> function returns the fractional number of seconds since PICO-8 was started.

<span style="font-weight:bold;">Note:</span> This uses the built-in number type to represent the number of seconds, which has an upper limit of 32,767. (roughly 9h 6m)

<code>t()</code> is a short alias for <code>time()</code>.<h4>Examples</h4><pre>
function _init()
  last = time()
end

function _update()
  -- (empty update to use game loop)
end

function _draw()
  cls()
  if (time() - last) > 10 then
    print("time's up!", 44, 60, 7)
  end
end
</pre><h4>See also</h4><ul><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Keyconfig</h2>{{CommandReference
|name=keyconfig
|shortdesc=Opens the interactive key configuration tool.
}}
You can use the <code>keyconfig</code> tool to change which keyboard keys correspond with the player 1 and player 2 buttons, as well as the pause key.

[[File:Keyconfig-0.png|thumb|220x220px]]

When you run the command, the list of keys appears. When you press a key (other than Delete or Escape), that key is assigned to the highlighted button, and the highlight moves down. Once you have configured all of the buttons, PICO-8 saves the configuration.

The configuration persists between runs of the PICO-8 app. It is stored in the [[Configuration|configuration]] file <code>config.txt</code>, as the <code>button_keys</code> property.

You can abort without saving by pressing the Escape key any time before the last key.

To reset a button to use its default key, press the Delete key when that key is highlighted. To reset all buttons to default keys, run <code>keyconfig</code>, then press Delete for every key.<h4>Examples</h4><pre>
> keyconfig
</pre><h4>See also</h4><ul><li>[[Config|<code>config</code>]]</li><li>[[Configuration]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Stop</h2>{{ApiReference
|name=stop
|message|optional|An optional message to print before stopping.
|x|optional|The x coordinate of the upper left corner to start printing.
|y|optional|The y coordinate of the upper left corner to start printing.
|col|optional|The color to use for the text.
|shortdesc=Stops the program's execution and returns to the [[CommandPrompt|command prompt]].
}}
{{UndocumentedFeature}}
The <code>stop()</code> function stops the program at the point where the function is called, returning to the [[CommandPrompt|command prompt]]. This is similar to pressing the Escape key at a specific point in the code.

Note that the format of the optional arguments is identical to the more-familiar [[Print|print()]]. This can be useful for explaining why the app has exited, especially if combined with information from [[Trace|trace()]].

If your program uses the [[GameLoop|game loop]], you can resume execution of the program using the [[Resume|resume]] command. This does <span style="font-style:italic;">not</span> resume from the call to <code>stop()</code>. Instead, it starts the next loop iteration with a call to [[Update|_update()]]. If your program does not use the game loop, [[Resume|resume]] raises an error.<h4>Examples</h4><pre>
v = 1

function _update()
  v += 1
  if (v % 5) == 0 then stop() end
end

function _draw()
  cls()
  print(v, 0, 0, 8)
end
</pre>

Running this program stops when <code>v</code> is a multiple of 5. From the command prompt:

<pre>
> print(v)
5
> resume
</pre>

The program stops again at the next multiple of 5:

<pre>
> print(v)
10
</pre><h4>See also</h4><ul><li>[[GameLoop|Game loop]]</li><li>[[Resume]]</li><li>[[Assert|<code>assert()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Trace</h2>{{ApiReference
|name=trace
|shortdesc=Returns a description of the current call stack as a string.
|coroutine|optional|Optionally get the stack trace for a coroutine. Defaults to the current one or the main thread.
|message|optional|Adds the given string to the top of the trace report. Defaults to blank.
|skip|optional|Number of levels of the stack to skip. Defaults to 1, to skip the trace() call's own level.
}}
{{UndocumentedFeature}}

The <code>trace()</code> function returns a description of the current call stack as a string. This string is long, and is only useful when printed to a terminal window with [[Printh|<code>printh()</code>]].

Note that, despite the expected Lua practice of only being able to leave out trailing arguments, the first argument, for the coroutine, can be left out while still supplying the message and skip arguments.

Note that the message argument is useful for inserting the exception string returned from a failed coroutine. See [[Coresume|<code>coresume()</code>]] for details on how to do this.

As of PICO-8 v0.1.6, the string includes useless information referring to internal details. For example, if the cart uses the [[GameLoop|game loop]], this stack trace includes the hidden <code>_mainloop</code> function.<h4>Examples</h4>Here's a simple program that counts up to 30, prints the stack trace to the host console, then calls [[Stop|<code>stop()</code>]].

<pre>
v = 0

function next_tick()
  if v > 30 then
    printh(trace("final tick reached!"))
    stop()
  end
  return v + 1
end 

function _update()
  v = next_tick()
end

function _draw()
  cls()
  print(v, 0, 0, 7)
end
</pre>

As of PICO-8 v0.1.12c, the host console shows the trace as follows:

<pre>
final tick reached!
stack traceback:
	[string "-- pico-8 header..."]:7: in function 'next'
	[string "-- pico-8 header..."]:14: in function '_update'
	[string "-- pico-8 header..."]:31: in function '_mainloop'
	[string "-- pico-8 header..."]:38: in main chunk
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Assert|<code>assert()</code>]]</li><li>[[Stop|<code>stop()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Forum</h2>The [http://www.lexaloffle.com/bbs/?cat=7 PICO-8 forum], or BBS (bulletin board system), is the official community center for PICO-8. This is where PICO-8 developers share games, discuss techniques, and get technical support. You can also use the forum to maintain a blog, where blog posts appear in the main activity stream.

The forum has special features for publishing PICO-8 games. When you upload a cartridge, everyone can play the game in a web browser, discuss the game, give the game a star, mark it as a favorite, and download it for offline play or examination in the PICO-8 app.

PICO-8's [[Splore]] feature can browse cartridges published to the forum over the Internet, directly from within PICO-8.

In addition to uploading and downloading cartridge files, you can copy and paste sprites and entire cartridges between the PICO-8 app and forum posts via your operating system's clipboard.

The forum is hosted by [[LexaloffleGames|Lexaloffle Games]] and uses custom forum software.<ul><li>[http://www.lexaloffle.com/bbs/?cat=7 The PICO-8 forum]</li></ul><h4>Starting a discussion</h4>To start a new discussion thread:<ol><li>Sign in or register for an account, if you are not already signed in.</li><li>Select one of the following categories by clicking its button: Collaboration, Discussion, Editor, or Support.</li><li>Click "Start New Thread in ..." for the category.</li></ol>A new thread can have a title and any number of tags (key words that associate multiple threads on the same subject). Text formatting is available (bold, italics, code blocks, headers, links), and you can attach images and YouTube videos.<h4>Publishing a cartridge</h4>Before you can publish a cartridge, you must prepare the cartridge file. First, give your cart a title and byline by writing them as the first two comments in the Lua code:

<pre>-- jelpi
-- by zep
</pre>

Next:<ol><li>Run the cart in PICO-8, then press F7 to capture the current screen as the cartridge label.</li><li>Press Escape to return to the PICO-8 [[CommandPrompt|command prompt]].</li><li>Use the [[Save|save]] command, and provide a filename ending in <code>.p8.png</code>.</li></ol>To publish the cartridge to the forum:<ol><li>Sign in or register for an account, if you are not already signed in.</li><li>Select one of the following categories by clicking its button: Cartridges (for finished works), Work in Progress, or Collaboration.</li><li>Click "Submit a cartridge to ..." for the category.</li><li>Under "Post a Cartridge," click Continue. Follow the prompts to upload the <code>.p8.png</code> file.</li><li>On the following screen, press the button to create a new thread for the cartridge.</li></ol><h4>Posting a cartridge as a response to another thread</h4>When viewing any thread, you can post a comment using the form at the bottom of the page. To include a cartridge in a comment on an existing thread:<ol><li>Prepare the cartridge and follow the steps above to publish the cartridge. On the final screen, do not click the button to create a new thread. Instead, note the tag assigned to the uploaded cartridge, such as <code>[#1234#]</code>.</li><li>Go to the discussion thread where you want to post the cartridge response. In the response text, include the cartridge tag.</li></ol><h4>Copying and pasting graphics</h4>You can copy sprites from the PICO-8 app and paste them into a forum post or comment.

To copy a sprite, open the sprite editor, select the sprite, then press Control-c (or Command-c in Mac OS X). To copy a rectangle of sprites, hold Shift, click-drag a selection box around the sprites, then press Control-c (or Command-c). This puts an encoded string on the clipboard that looks something like this:

<pre>[gfx]2808000000 ... 00000f000[/gfx]</pre>

You can paste this string directly into the forum post or comment. After you publish, the sprite will appear in graphical form in the message.
[[File:Screen Shot 2016-09-15 at 1.06.05 PM.png|thumb|220x220px]]
You can also copy a sprite (or rectangle of sprites) from a forum post to PICO-8. The sprite appears in the post with its size indicated. Click the size to show the <code>[gfx]</code> string, then press Control-c (or Command-c) to copy it to the clipboard. In the PICO-8 sprite editor, select the top-left corner sprite location to use, then press Control-v (or Command-v).
[[File:Screen Shot 2016-09-15 at 1.06.14 PM.png|thumb|460x460px]]
<span style="font-weight:bold;">Note:</span> Pasting a sprite overwrites the sprites already in that location. To undo the paste operation, press Control-z (or Command-z).<h4>Copying and pasting cartridges</h4>You can copy entire cartridges from the PICO-8 app and paste them into a forum post or comment. To copy a cartridge to the clipboard, exit to the Console, then enter this command:

<pre>save @clip</pre>

This copies a string value to the clipboard that looks something like this:

<pre>[cart]89504e470d0a1a0a00 ... 9454e44ae426082[/cart]</pre>

This string may be very long. As with sprites, you can paste this string into a forum post or comment, and it will appear as a playable cartridge in the message.

To copy a cartridge from the forum to PICO-8, locate the word "Copy" below the cartridge, then click on it. This copies the <code>[cart]</code> string to the clipboard.
[[File:Screen Shot 2016-09-15 at 1.07.13 PM.png|thumb|424x424px]]
At the PICO-8 Console, enter the following command:

<pre>load @clip</pre><h4>Posting a blog entry</h4>To post a blog entry, start a new discussion thread in the Blog category.

Blog entries are like other discussion threads, except they also appear on your user profile page.
<hr style="height: 0.0625em;background-color: #888;" /><h2>Pico8Slack</h2>The PICO-8 community uses Slack for real-time discussion and collaboration. The "pico-8" Slack group has active users and multiple channels.

http://pico-8.slack.com/

To join this Slack group, sign up for Slack, then enter your email address in this form:

https://slofile.com/slack/pico-8

You will be invited to the Slack group automatically.

Discussion: http://www.lexaloffle.com/bbs/?tid=2732

There is also another Slack group called "picocity": https://slofile.com/slack/picocity http://www.lexaloffle.com/bbs/?tid=3157

The Fantasy Consoles Discord server has a PICO-8 channel, as well as channels for other fantasy consoles inspired by PICO-8 and otherwise. The community runs regular game jams: http://discord.gg/sFeDxWK
<hr style="height: 0.0625em;background-color: #888;" /><h2>IRC</h2>Some PICO-8 developers use IRC (Internet Relay Chat) for real-time discussion and collaboration. The "pico8" channel is hosted by Freenode:

irc://freenode/pico8

You can use any IRC client to connect, or you can use [https://webchat.freenode.net/ Freenode's webchat] from within a web browser.

See also: [[Pico8Slack]]
<hr style="height: 0.0625em;background-color: #888;" /><h2>Pico8Zine</h2>The PICO-8 Zine is a periodical of articles about PICO-8 written by members of the community. The zine is organized and published by arnaud_debock. Issues are available for free as a downloadable PDF, or in print in limited quantities for a small fee.

http://pico8fanzine.bigcartel.com/<h4>Issue #1</h4>[http://sectordub.itch.io/pico-8-fanzine-1 PDF], [http://pico8fanzine.bigcartel.com/product/pico-8-fanzine-1 print], [http://www.lexaloffle.com/bbs/?tid=2106 forum discussion]

Contents:<ul><li>A Brief History of PICO-8, by zep</li><li>Squashy, by Alex Mole (@TheRealMolen)</li><li>Let's Make Some Music, by Feliks Balzer</li><li>Toy Train, by James (PROGRAM_IX)</li><li>Geodezik, by @aliceffekt</li><li>Smoke Particle, by Mozz</li><li>Welcome to PICO-8!, by @terrycavanagh</li></ul><h4>Issue #2</h4>[http://sectordub.itch.io/pico-8-fanzine-2 PDF], [http://pico8fanzine.bigcartel.com/product/pico-8-fanzine-2 print], [http://www.lexaloffle.com/bbs/?tid=2524 forum discussion]

Contents:<ul><li>Hello everyone, by Arnaud DE BOCK</li><li>Game Of Life, by dddaaannn (@dan_sanderson)</li><li>3d demo, by @NoahRosamilia</li><li>Shrinking your code, by Jonathan Stoler (@jonstoler)</li><li>Shodo, by @oinariman</li><li>Water Waves, by Matthew Klundt</li><li>Screensaver, by Devine Lu Linvega (@aliceffekt)</li><li>PicoJump, by Johannes Richter</li><li>Color palette, by Gabby DaRienzo</li></ul><h4>Issue #3</h4>[http://sectordub.itch.io/pico-8-fanzine-3 PDF], [http://pico8fanzine.bigcartel.com/product/pico-8-fanzine-3 print], [http://www.lexaloffle.com/bbs/?tid=2382 forum discussion]

Contents:<ul><li>Minimalism Pays Double, by Matt (@MattThorson)</li><li>Notes on Creating Succer, by Laury MICHEL (@RylauChelmi)</li><li>Dom8verse, by @schminitz</li><li>Minigame Collection, by Jack Harrison (@jhrrsn)</li><li>Blasteroids, by Lulu Blue (@luluisbluetoo)</li><li>Sumo Pico, by Cullen Dwyer (@cullenddwyer)</li><li>Cheat Sheet, by @obono</li></ul><h4>Issue #4</h4>[http://sectordub.itch.io/pico-8-fanzine-4 PDF], [http://pico8fanzine.bigcartel.com/product/pico-8-fanzine-4-special-roguelike print], [http://www.lexaloffle.com/bbs/?tid=2628 forum discussion]

Contents:<ul><li>DON'T WAIT, by Michael Brough (@smestorp)</li><li>AI MOVE SPECIAL ROGUELIKE, by Benjamin Soule (@benjamin_soule_)</li><li>A* pathfinding in PICO-8, by Richard Adem (@richy486)</li><li>Traps For Absolutely Every Imaginable Occasion, by Kyle Reimergartin (@mooonmagic)</li><li>The Roguelike *shiny* game-feel, by Dog Trasevol (@TRASEVOL_DOG)</li><li>Dungeon walls, by Rodrigo Franco (@caffo)</li><li>Sharing music between carts, by Robby (@RobbyDuguay)</li><li>DONUT MAZE, by zep (@lexaloffle)</li></ul><h4>Issue #5</h4>Issue #5 is currently in progress ([http://www.lexaloffle.com/bbs/?tid=3266 forum discussion]).
<hr style="height: 0.0625em;background-color: #888;" /><h2>PicoChat</h2>Pico Chat is an audio podcast "about Pico-8 and other tiny games" by tony (@tone_def).

http://pico.electrobureau.com/

Episodes:<ul><li>#1: handholding</li><li>#2: just jammin'</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Asteroids</h2>{{Game|title = Asteroids|imagecaption = Title screen|first = Vlek|second = Shooter|third = One|image = Asteroidspico.jpg|imagewidth = 224}}<h4>Description</h4>Shoot as many asteroids as possible while avoiding being destroyed by them.<h4>Rules</h4><ul><li>Shoot asteroids!  Shooting a large one will split into two medium-sized ones, shooting a medium asteroid will split into two small ones, then shooting a small asteroid will destroy it.</li><li>Being hit by an asteroid will cost the player a ship and the game will end when there are no more ships left in reserve.</li><li>An extra ship is awarded at 5000 points.</li><li>Along with turning, the player can also thrust their ship around the screen to avoid asteroids.</li></ul><h4>Controls</h4><ul><li>Use any key (Z, X and arrow keys) to start a game.</li><li>Use the left/right arrow keys to turn ship and the up arrow key to thrust.</li><li>Use the Z button to shoot.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Pico8</h2>PICO-8 (or "Pico-8") is a <span style="font-style:italic;">fantasy console</span> by [[LexaloffleGames|Lexaloffle Games]] for making, sharing, and playing small computer games and programs.

PICO-8 is available for purchase as an app for Windows, Mac OS X, Linux (Intel), and Raspberry Pi. It also comes bundled with the [[PocketChip|PocketC.H.I.P.]] portable computer. See [http://www.lexaloffle.com/pico-8.php the PICO-8 website] for purchasing information.

PICO-8 intends to capture the fun and creativity of writing programs for the small personal computers of the 1980's, without the hassles of an arcane platform. The specifications are purposefully limited so that making games is easy and fun. The console has built-in tools for creating graphics, sound, music, and code, all of which run within the console's 128-by-128 pixel screen. You program PICO-8 using the [[Lua]] programming language.

Games are saved as <span style="font-style:italic;">cartridges</span> (or "carts"), which are just small files that can be shared over the Internet. You can publish a cartridge to the [[Forum|PICO-8 forum]], where anyone can play it directly in a web browser without the PICO-8 app, discuss it, and download it to examine it in the app's tools. Publishing a cart also makes it accessible from within the app's [[Splore]] cartridge explorer.

You can also export cartridges with a standalone player that can be embedded into any web page, suitable for commercial publication on game networks such as [https://itch.io/ itch.io].

PICO-8 has an active developer community, with hundreds of games, tools, and resources for learning how to make games.<h4>Specifications</h4><ul><li>Display<ul><li>128 x 128 pixel resolution</li><li>16 colors</li></ul></li><li>Sound<ul><li>4 channels</li><li>8 waveforms</li></ul></li><li>Controls<ul><li>two 6-button controllers (up, down, left, right, x, o) available from a PC keyboard</li><li>connect up to eight 6-button controllers via [[SDL]]</li></ul></li><li>Cartridge size<ul><li>32 kilobytes per cartridge</li><li>128 x 128 pixel sprite sheet</li><li>128 x 32 tile map</li><li>64 sound patterns, 64 music patterns</li><li>[[Lua]] code space limited by characters and tokens</li></ul></li><li>Memory<ul><li>addressable memory regions for graphics, sound, and general use</li><li>separate RAM for the Lua call stack</li><li>64 values (256 bytes) persistent memory per cart</li><li>Raspberry Pi GPIO pins mapped to memory</li></ul></li></ul><h4>See also</h4><ul><li>[[PlayingGames]]</li><li>[[GettingStarted]]</li></ul>[[zh:]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Alien Abduction</h2>{{Game|title = Alien Abduction|imagecaption = Title screen|first = dj_pale|second = Action|third = One|image = Aabduction.jpg|imagewidth = 224}}<h4>Description</h4>“Fetch" as many "puny humans” as you can “for...gruesome experiments etc.” for your High Commander XL'ARGH!<h4>Rules</h4><ul><li>Abduct humans!  The player must maneuver their U. F. O. down towards Earth while avoiding projectiles launched from buildings and later planes that travel the skies.  Once the player is close enough to a human, they must use their tractor beam to suck it up, then take them high into the atmosphere so the alien mothership can collect the human from there.</li><li>Being hit by a plane or building projectile will cost the player a U. F. O. and the game will end when there are no more U. F. O.s in reserve.</li><li>If a plane's fire hits a human or if a human dies after being dropped by the U. F. O. (if it is too high up) being shot down then the player will be penalized 100 points for each lost human.</li></ul><h4>Controls</h4><ul><li>Use the Z or X keys to start a game.</li><li>Use the arrow keys to move U. F. O.s.</li><li>Use the Z key to activate the tractor beam.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>PlayingGames</h2>The easiest way to start playing games is to visit [[Forum|the PICO-8 forum]] in a web browser. All cartridges published to the forum can be played in a web browser without the PICO-8 app.

From the PICO-8 app or a network-connected device (such as [[PocketChip|PocketC.H.I.P.]]), you can use the built-in [[Splore]] utility to browse and play all carts published to the forum. Type <code>splore</code> at [[CommandPrompt|the PICO-8 prompt]] and hit enter.
[[File:Splore.gif|center|521x519px]]

PICO-8 includes a small set of demonstration carts built in. To access these carts, you must first run the <code>install_demos</code> command at the PICO-8 prompt. This creates a <code>demos/</code> folder in the PICO-8 file system with carts that can be loaded, run, and edited.
[[File:Install demos.gif|center|521x519px]]

You can download carts from the forum by clicking on the "Cartridge" link and saving the file. The file is a <code>.p8.png</code> file and appears as an image of a cartridge in a web browser. Use the [[Folder|folder]] command to open the PICO-8 file system location in your operating system's file browser, then move the file to that location to make it accessible to PICO-8.

To save a cartridge discovered within Splore, load and run the cart, hit Escape to open the pause menu, select Splore, then hit Escape again to return to the PICO-8 prompt. The loaded cart is still in memory. Use the [[Save|save]] command to save it as a local file.
[[File:Save from splore.gif|center|521x519px]]

[[zh:PlayingGames]]
<hr style="height: 0.0625em;background-color: #888;" /><h2>Invasion</h2>{{Game|title = Invasion|imagecaption = Title screen|first = Joe Rodriguez|second = Shooter|third = One|image = Invasion.jpg|imagewidth = 224}}<h4>Description</h4>Shoot as many invaders as possible while avoiding their fire.<h4>Rules</h4><ul><li>Shoot invaders!  Clearing a screen of invaders will take the player to the next level.</li><li>The invaders move in a formation from side to side; once they reach the edge of a screen the formation will drop down a notch closer to the player’s laser base.  The invaders move faster as their numbers are whittled down.</li><li>The invaders start shooting, which being hit by an invader’s fire will cost the player a laser base and the game will end when there are no more bases left in reserve. If any invader reaches the very bottom of the screen, this will also end the game.</li><li>Bunkers can be used as protection from invader fire, although they start taking damage when hit by the player's or alien fire.</li><li>A bonus U. F. O. flies overhead a few times during a level which is worth big points.</li></ul><h4>Controls</h4><ul><li>Use the Z or X keys to start a game.</li><li>Use the arrow keys to move the laser base.</li><li>Use the Z or X keys to fire.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>The Stroll</h2>{{Game|title = The Stroll|imagecaption = Title screen|first = Parlor|second = Puzzle|third = One|image = Thestroll.jpg|imagewidth = 224}}<h4>Description</h4>Go for a walk!  However, is this just a normal "stroll", or does the drab background/colors and blood-spattered bodies littering the landscape suggest that something much more sinister is afoot?<h4>Rules</h4><ul><li>Just move!  The player will mostly move to the right during the entire game.</li><li>Barriers impede the player's progress; buildings must be entered in order to defeat them.  The player can either take an additional exit to bypass a barrier or they will run across one or more consoles complete with one or more red lights.  Interacting with the consoles will turn the lights to green; once this has been accomplished, the barriers will be removed, the player can exit the building and continue on their way.</li><li>Once the player encounters the monster, they must get close enough for it to realize the player is near so it can attack and kill the player, thus completing the game.  There is no way to avoid or defeat the monster.</li></ul><h4>Controls</h4><ul><li>Use the right arrow key to start a game.</li><li>Use the left/right arrow keys to move the player.</li><li>Use the up and down arrow keys to enter and exit buildings (respectively) while standing in a doorway.</li><li>Use the up arrow key to interact with a console while standing in front of it.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Magnetoids</h2>{{Game|title = Magnetoids|imagecaption = Title screen|first = dj_pale|second = Shooter|third = One|image = Magnetoids.jpg|imagewidth = 224}}<h4>Description</h4>It's [[Asteroids]] in reverse!  The player shoots squares, but must combine them all together this time around, rather than break them up.<h4>Rules</h4><ul><li>Shoot the boxes.  This has two effects: one, it changes the course of the box, and two, it briefly creates a magnetic shield.</li><li>When there are two or more boxes in the vicinity of each others' shields (when active), this will cause one or more boxes to be absorbed into one box (which will grow with each box it absorbs).  The player must combine all boxes to form one giant box (which will then “collapse due to it's unbearable mass”) in order to proceed to the next level.</li><li>Getting hit by a box will cost the player a ship and the game will end when they have no more ships left in reserve.</li></ul><h4>Controls</h4><ul><li>Use the X or Z keys to start a game.</li><li>Use the left/right arrow keys to turn your ship.</li><li>Use the X or Z keys to shoot.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Earth Was a Bad Choice</h2>{{Game|title = Earth Was a Bad Choice|imagecaption = Title screen|first = zatyka|second = Action|third = One|image = Earthwasabad.jpg|imagewidth = 224}}<h4>Description</h4>An alien has become separated from his space ship after stopping on Earth for some “R and R”. Unfortunately the Earthlings are treating him like a “monster”, so he must make it back to his ship and flee the planet by running and becoming airborne.<h4>Rules</h4><ul><li>The player's alien is constantly running, which takes up energy.  Steering the alien into earth vehicles (cars, planes, bombs) will cause the alien to become airborne and not use up energy.  If the player runs out of energy during a level the game will end, although the player is allowed unlimited continues.  Making it to the end of a level refills the alien's energy level to its maximum amount.</li><li>Destroying as many earth vehicles/weapons as possible without touching the ground will add to the player’s combo score (along with how much time the player was in the air max), which is displayed if the player is able to hit at least 10 vehicles and/or projectiles in a row without touching the ground.</li></ul><h4>Controls</h4><ul><li>Use the X or Z or any arrow key to start a game.</li><li>Use the left/right arrow keys to move the alien.</li><li>Use the left/right arrow keys to read text at the end of a level.</li><li>Use the X + Z keys to toggle the music.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>LexaloffleGames</h2>Lexaloffle Games is a computer game company based on Kichijouji, Tokyo, Japan, founded by Joseph White (aka [[Zep|zep]]). Lexaloffle is the maker of the PICO-8 fantasy console, the Voxatron fantasy console, and PC games such as Jasper's Journeys and Zen Puzzle Garden.

Lexaloffle is located at Pico Pico Cafe in Kichijouji, just north of Inokashira Park (home of the Ghibli Museum). The cafe is open to the public on weekends and hosts a monthly show-and-tell event for designers called [http://www.picopicocafe.com/index.php?id=picotachi-jp Picotachi].<ul><li>Website: http://www.lexaloffle.com/</li><li>Contact: [mailto:hey@lexaloffle.com hey@lexaloffle.com]</li><li>Twitter: [https://twitter.com/lexaloffle @lexaloffle]</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Zep</h2>Joseph White, aka zep, is the owner of [[LexaloffleGames|Lexaloffle Games]] and the creator of PICO-8 and Voxatron. He lives in Tokyo, Japan.<ul><li>Twitter: [https://twitter.com/lexaloffle @lexaloffle]</li><li>Email: [mailto:hey@lexaloffle.com hey@lexaloffle.com]</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Pico-Man</h2>{{Game|title = Pico-Man|imagecaption = Title screen|first = UrbanMonk|second = Action|third = One|image = Picomanwiki.jpg|imagewidth = 224}}<h4>Description</h4>It's Pac-Man, you should know what to do!  Clear out mazes of dots and avoid the pursuing monsters for the most part.<h4>Rules</h4><ul><li>The player controls Pico-Man, who must clear out mazes of dots by eating them.  Pico-Man moves slightly faster when the corridors are dot-free.  Eating all dots in a maze leads to the next more difficult level.  Bonus prizes appear up to two times during a level below the monster pen if Pico-Man can eat them before they disappear.</li><li>Four monsters start pursuing Pico-Man throughout a level; if one of them catches him they will lose a life and the game will end when there are no more remaining lives.  An escape tunnel located on the center sides of the maze will slow down a pursuing monster, however, along with one of four energizers in the corners of each maze will temporarily make the monsters vulnerable to the point where Pico-Man can eat them.  Once they start flashing, however, they are about to turn back into their dangerous state.</li></ul><h4>Controls</h4><ul><li>Use the X or Z keys to start a game.</li><li>Use the arrow keys to control Pico-Man.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>PocketChip</h2>PocketCHIP (or "PocketC.H.I.P.") is a handheld computer produced by Next Thing Co. It is based on the CHIP platform, and includes a 480 x 272 LED backlit touchscreen and a membrane keyboard. The removable CHIP computer provides a 1 Ghz ARMv7 processor, 512 MB of RAM, wireless Internet, Bluetooth, one USB port, one headphone/video jack (a TRRS jack). PocketCHIP is powered by a 5-hour rechargeable battery.

PocketCHIP includes a full version of PICO-8 preinstalled, tailored to the hardware to support using the touchscreen with the built-in editing tools (as a substitute for the mouse). You can use the wireless Internet connection with [[Splore]] to browse and play published carts.

[[File:PICO-8 on PocketC.H.I.P. - Play Games. Change Games. Make your own Games.|center|500x500px]]

PcoketCHIP (and CHIP) run the CHIP Operating System, which is based on Debian Linux. The CHIP includes GPIO (general purpose input/output) pins for building hardware extensions, and the PocketCHIP case extends these pins to through-hole pads along the top of the unit.

PocketCHIP retails for $69 USD. As of June 2016, it is available for pre-order at the special price of $49 USD, shipping in July. The CHIP computer sells separately as a development platform for $9.

CHIP and PocketCHIP originated as [https://www.kickstarter.com/projects/1598272670/chip-the-worlds-first-9-computer a Kickstarter campaign].<ul><li>PocketCHIP website: https://getchip.com/pages/pocketchip</li><li>CHIP technical documentation: http://docs.getchip.com/chip.html</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Rey's Scavenger Run</h2>{{Game|title = Rey's Scavenger Run|imagecaption = Title screen|first = Tassilo|second = Action|third = One|image = Reysscavenger.jpg|imagewidth = 224}}<h4>Description</h4>Taking place in the Star Wars The Force Awakens movie, the player controls one of the lead characters, Rey, who must scavenge "junk" to sell to her boss.<h4>Rules</h4><ul><li>At the beginning of a game, Rey's boss instructs her what junk to pick up for him.  The player then controls Rey in a speeder over a scrolling desert area as various objects appear.  Rey must pick up several various junk pieces and reach the end of the level in order to progress to the next one.</li><li>Along with junk pieces, various speeders need to be avoided that also appear throughout the game.  Colliding with one will cause damage to Rey's speeder and if the player suffers too many collisions the game will end.</li></ul><h4>Controls</h4><ul><li>Use the X key to start a game and a level.</li><li>Use the arrow keys to control Rey/her speeder.</li><li>Use the Escape or Enter keys to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Lua</h2>Lua is a programming language designed primarily for embedded systems. It is popular in the video game industry as a language that can be embedded in a larger game engine.

PICO-8 implements a subset of Lua for writing game cartridges. Because it is a subset, not all features of Lua are supported. Most notably, PICO-8 does not include the Lua standard library, and instead provides a proprietary collection of global functions.<ul><li>[https://www.lua.org/docs.html Official Lua documentation]</li><li>[https://en.wikipedia.org/wiki/Lua_(programming_language) Lua (Wikipedia)]</li></ul><h3>Features of PICO-8 Lua</h3>The following are the major language features of Lua as implemented by PICO-8.<h4>Comments</h4>PICO-8 code comments are preceded by two hyphens (<code>--</code>) and go to the end of the line. They also support a multi-line syntax using double-brackets (<code><nowiki>--[[ ... ]]</nowiki></code>).

<pre>
-- one-line comment
--[[ multi-line
comment ]]
</pre><h4>Values</h4>PICO-8 supports these fundamental types of values:<ul><li>Numbers, in the range supported by signed 16.16 bit fixed point:<ul><li>Minimum value: hex <code>0x8000.0000</code>, decimal <code>-32768.0</code></li><li>Maximum value: hex <code>0x7fff.ffff</code>, decimal <code>32767.9999847412109375</code></li><li>Number literals can use decimal (<code>17.25</code>) or hexadecimal (<code>0x11.4</code>).</li><li>Things to be aware of:<ul><li>PICO-8 prints and converts numbers to decimal strings by rounding off to four decimal places. This has the side effect that the maximum number rounds up to <code>32768.0</code>, which is actually not a valid PICO-8 number. It also means that the tiniest negative fraction below 0 displays as the somewhat-unintuitive <code>-0</code>.</li><li>This range is narrow in comparison to modern platforms. Be aware of situations where you might overflow, e.g. calculating the distance between corners of the screen requires calculating 128*128+128*128, which will overflow and wrap to -32768.</li></ul></li></ul></li><li>Booleans (<code>true</code> and <code>false</code>)</li><li>Strings<ul><li>String literals can use single quotes (<code>'hello'</code>) or double quotes (<code>"hello"</code>), and the quote character can appear in the string escaped with a leading backslash (<code>"you said \"hello\", yes?"</code>).</li></ul></li><li>Nil (<code>nil</code>)</li><li>Functions (see below)</li><li>Coroutines (see below)</li><li>Tables<ul><li>Sequences, indexed from 1: <code>x = {2, 3, 5, 7, 11}</code>; <code>x[1] == 2</code></li><li>Mappings: <code>x = {a=1, b=2, c=3}</code>; <code>x.a == x['a'] == 1</code></li><li>Unset indexes evaluate to <code>nil</code>: <code>x[0] == nil</code></li></ul></li></ul>As in Lua, all composite and custom data types are based on tables.<h4>Arithmetic operators</h4>PICO-8 supports these arithmetic operators:<ul><li>addition: <code>a + b</code></li><li>subtraction: <code>a - b</code></li><li>multiplication: <code>a * b</code></li><li>division: <code>a / b</code></li><li>modulo: <code>a % b</code></li><li>exponentiation: <code>a ^ b</code></li></ul>Arithmetic operators take numbers as arguments and return a number.<h4>Relational operators</h4>PICO-8 supports these relational operators:<ul><li>less than: <code>a &lt; b</code></li><li>greater than: <code>a &gt; b</code></li><li>less than or equal to: <code>a &lt;= b</code></li><li>greater than or equal to: <code>a &gt;= b</code></li><li>equal: <code>a == b</code></li><li>not equal: <code>a ~= b</code>; PICO-8 synonym: <code>a != b</code></li></ul>Relational operators take numbers as arguments and return either <code>true</code> or <code>false</code>.<h4>Logical operators</h4>PICO-8 supports the following logical operators:<ul><li>and: <code>a and b</code></li><li>or: <code>a or b</code></li><li>not: <code>not a</code></li></ul>In logical expressions, both <code>false</code> and <code>nil</code> are treated as false, and all other values are treated as true.

Logical expressions "short circuit," which is to say they stop evaluating expressions left to right as soon as the value of the expression is known. For example, "<code>is_alive() and can_shoot()"</code> will first call <code>is_alive()</code>, and will only call <code>can_shoot()</code> afterwards if <code>is_alive()</code> returns true.

<span style="font-weight:bold;">"Is there logical xor operator?"</span>

If your operands are <span style="font-style:italic;">guaranteed</span> to be boolean values, i.e. <span style="font-style:italic;">only</span> true or false, then the <code>==</code> operator does what an xor operator does. If they are <span style="font-style:italic;">not</span> guaranteed, then an ugly-but-functional alternative is <code>not b == not c</code>.

<span style="font-weight:bold;">"Is there a ternary operator?"</span>

A useful equivalent of the choice-making [[wikipedia:?:|<code>?:</code> "ternary operator"]] from the C-family languages is <code>a and b or c</code>, which evaluates to <code>b</code> if <code>a</code> is true, or <code>c</code> if <code>a</code> is false. One important and useful aspect of a ternary operator is that it uses the short-circuiting feature of logical operators to avoid invoking unwanted side effects or costs. <span style="font-weight:bold;">There is one caveat:</span> if <code>b</code> is false or nil, the expression will fall through and choose <code>c</code>.

Much more detail and additional approaches can be found in [http://lua-users.org/wiki/TernaryOperator the official Lua documentation]. Among them is the suggestion to use a ternary <span style="font-style:italic;">function</span>, and it is good to note here that a ternary function uses the same number of PICO-8 tokens per invocation as the logical-operator approach, while also removing the need for isolating complex expressions with parentheses, but with the downsides that short-circuiting is lost and performance is a bit poorer.<h4>String operators</h4><code>PICO-8 supports the string concatenation operator: <code>a..b</code>

<code>a</code> must be a string. <code>b</code> can be a string or a number (which is coerced into a string).

No other type of value can be concatenated with a string. You can use the [[Tostr|<code>tostr()</code>]] function to convert other values to strings:

<pre>
print("a > b: "..tostr(a > b))
</pre>
You can determine the length of a string using the sequence length operator (#):

<pre>

x = "hello there"
print(#x)            -- 11
</pre>

See also [[Sub|<code>sub()</code>]].<h4>Assignment operators</h4>As in Lua, you can assign a value to a variable or table slot

<code>myvar = value</code>

PICO-8 adds shortcut assignment operators for the arithmetic operators, often found in other languages like C:

<pre>
myvar += value       -- myvar = myvar + value
myvar -= value       -- myvar = myvar - value
myvar *= value       -- myvar = myvar * value
myvar /= value       -- myvar = myvar / value
myvar %= value       -- myvar = myvar % value
</pre>

(There are no <code>^=</code> or <code>..=</code> assignment operators.)<h4>Variables</h4>PICO-8 supports global variables accessible to the entire program, and local variables accessible only within the function where they are declared. If a variable is not declared as local, then it is global.

<pre>
-- a global variable
player_pos = {20, 60}

function move_player(newx, newy)
  player_pos = {newx, newy}
end

function circumference(r)
  -- a local variable
  local pi = 3.14
  return 2 * pi * r
end
</pre>

<span style="font-weight:bold;">Caution:</span> A mistyped variable name is often interpreted as a global variable with no value assigned, which evaluates to <code>nil</code>. Most uses of unexpectedly <code>nil</code> values result in a runtime error, but these are not always easy to find.

Note that, unlike vanilla Lua, there is no access to the hidden <code>_G</code> table containing all global values.

However, the table of all global values can still be accessed via the <code>_ENV</code> variable. (Be warned - this is undocumented, though an integral part of the lua language. It can also only be typed in via an external editor due to the caps).<h4>Functions</h4>A function is a collection of statements that can be executed by calling it. The behavior of a function can be parameterized, and a function may return a value as a result.

<pre>
function distance(x1, y1, x2, y2)
  return sqrt((x2 - x1)^2 + (y2 - y1)^2)
end
</pre>

PICO-8 includes many built-in global functions, such as <code>sqrt()</code> in this example. See [[APIReference]].

If control reaches a <code>return</code> statement, then the function exits. If <code>return</code> includes a value, then the function call evaluates to that value. If control reaches the end of the function's statement block without seeing a <code>return</code> statement, then the function returns <code>nil</code>.

A function in Lua is a "first class" value, just like other values. A named function in the outermost block is equivalent to a global variable whose value is a function. A named function can also appear inside another function, which is equivalent to a local variable.

A function can omit the name if it is called right away or otherwise used as a value (an "anonymous function").

<pre>
x = {2, 3, 5, 7, 11}
foreach(x, function(v) print(x^2) end)
</pre>

Parentheses can be omitted when there is only one argument and it is a table or a literal string:

<pre>
add_particle{type=snow, x=rnd(128), y=0, c=7}
print"hello, winter!"
</pre>

Lua functions are [https://en.wikipedia.org/wiki/Scope_(computer_science) lexically scoped].<h4>Conditional statements</h4>The Lua <code>if</code> statement takes a condition and a block of statements, and executes the statements only if the condition is true:

<pre>
if score >= 1000 then
  print("you win!")
  score = 0
end
</pre>

An <code>if</code> statement can include any number of <code>elseif</code> sections to test multiple conditions until one is found true, and an optional final <code>else</code> section to evaluate if none of the conditions were true. The general form is:

<pre>
if cond1 then
  ...
elseif cond2 then
  ...
else
  ...
end
</pre>

PICO-8 extends standard Lua with an abbreviated, single-line <code>if</code> statement, differentiated by having parentheses around the condition and no <code>then</code> or <code>end</code> keywords. You may use <code>else</code>, but it must be on the same line. There is no support for <code>elseif</code>. Some examples:

<pre>
if (cond1) print("cond1")

if (cond2) print("cond2") else print("not cond2")
</pre>

A common misconception is that you must compare a boolean variable to <code>true</code> or <code>false</code> in an <code>if</code> statement, but a condition <span style="font-style:italic;">is</span> a boolean, so you can drop any boolean variable straight into an <code>if</code> statement:

<pre>
-- these two blocks are functionally identical

if cond == true then
  print("cond")
elseif cond == false then
  print("not cond")
end

if cond then
  print("cond")
else
  print("not cond")
end
</pre>

The only time you might need to compare a boolean variable to a value is when it may not be initialized yet. When variables are uninitialized, their value will be <code>nil</code>. When a <code>nil</code> value is used as a conditional expression, it is treated the same as <code>false</code>. Thus, if you have a boolean variable that may not be set yet, you should check for <code>nil</code> and initialize it before testing it as a boolean.<h4>while and repeat loops</h4>The <code>while</code> statement executes a block of statements repeatedly as long as a given conditional expression is true:

<pre>
x = 0
while x < 5 do
  print(x)
  x += 1
end
</pre>

The <code>repeat</code> statement executes a block of statements repeatedly until a given conditional expression is true:

<pre>
x = 0
repeat
  print(x)
  x += 1
until x > 4
</pre>

<code>while</code> does not execute its block if the condition is already false. <code>repeat</code> always executes its block at least once, then tests the condition.

The <code>break</code> statement anywhere in a loop terminates the loop immediately without testing the condition. If the loop is nested inside another loop, only the innermost loop is terminated.<h4>for loops</h4>There are two kinds of for loops in Lua. The numeric for loop traverses a numeric sequence from start to end, using an optional "stride" (with a default stride of 1).

<pre>
-- draws 16 color bars
for c=0,15 do
  rectfill(c*8, 0, c*8+7, 127, c)
end

-- prints 1, 3, 5, 7, 9
for i=1,10,2 do
  print(i)
end
</pre>

The other kind of for loop is the "generic for." In PICO-8, this is most commonly used with the [[All|<code>all()</code>]] and [[Pairs|<code>pairs()</code>]] built-ins for traversing tables:

<pre>
tbl = {2, 3, 5, 7, 11}
for v in all(tbl) do
  print(v)
end

tbl = {a=1, b=2, c=3}
for k,v in pairs(tbl) do
  print(k.."="..v)
end
</pre>

The generic for statement expects the "in" expression to return a special kind of value called an <span style="font-style:italic;">iterator</span>. The built-ins [[All|<code>all()</code>]] and [[Pairs|<code>pairs()</code>]] return iterators. For information on how to create your own iterators, see [https://www.lua.org/pil/7.html Iterators and the Generic for] in the Lua manual.

As with <code>while</code> and <code>repeat</code>, you can use the <code>break</code> statement to terminate a for loop immediately.<h4>Tables</h4>Tables are the primary composite data structure in Lua. They are used as containers, especially sequences (like lists or arrays) and mappings (also known as dictionaries or hashtables). Tables can be used as general purpose objects, and when combined with metatables (see below) can implement object-oriented concepts such as inheritance.

See [[Tables]] for a complete introduction to using tables in PICO-8.<h4>Methods</h4>A method is a function that is stored as a value in a table. Lua has special syntax for defining and calling methods that cause the table itself to be passed to the method as a parameter named <code>self</code>.

<pre>
ball = {
  xpos = 60,
  ypos = 60
}

function ball:move(newx, newy)
  self.xpos = newx
  self.ypos = newy
end

print(ball.xpos)           -- 60

ball:move(100, 120)
print(ball.xpos)           -- 100
</pre>

In both the definition and the method call, using the colon (<code>:</code>) instead of the dot (<code>.</code>) implies the <code>self</code> behavior. If you define the method as a simple property of the table, you must remember to explicitly mention the <code>self</code> argument. This is equivalent:

<pre>
ball = {
  xpos = 60,
  ypos = 60,

  -- without the colon syntax, must mention self argument explicitly
  move = function(self, newx, newy)
    self.xpos = newx
    self.ypos = newy
  end
}

-- using the colon, ball is passed as self automatically
ball:move(100, 120)

-- using the dot, must pass self explicitly
ball.move(ball, 100, 120)
</pre><h4>Metatables</h4>The metatable for a table defines the behavior of using the table as a value with Lua operators. You can customize a table's metatable to specify custom operator behaviors.

The most common use of metatables is to implement object-oriented inheritance by redefining the <code>__index</code> operator. The new definition tells Lua to check for a given property on a parent prototype object if the property is not set on the current object.

<pre>
function myclass:new(o)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  return o
end
</pre>

PICO-8 supports the [[Setmetatable|<code>setmetatable()</code>]], [[Getmetatable|<code>getmetatable()</code>]], [[Rawset|<code>rawset()</code>]], [[Rawget|<code>rawget()</code>]], [[Rawlen|<code>rawlen()</code>]], and <code>[[Rawequal|rawequals()]]</code> built-ins. It does not support any other related Lua functions.

See [[Setmetatable|<code>setmetatable()</code>]] for more information, links to references, and a more complete example.<h4>Coroutines</h4>A coroutine is a special kind of function that can yield control back to the caller without completely exiting. The caller can then resume the coroutine as many times as needed until the function exits.

PICO-8 supports coroutines using built-in global functions instead of Lua's <code>coroutine</code> library. See [[Cocreate|<code>cocreate()</code>]], [[Coresume|<code>coresume()</code>]], [[Costatus|<code>costatus()</code>]], and [[Yield|<code>yield()</code>]].

See [[Cocreate|<code>cocreate()</code>]] for more information, links to references, and a complete example.<h3>Differences from Lua</h3>PICO-8 does not include the Lua standard library. See [[Math]] for a description of the PICO-8 mathematical functions. See [[APIReference]] for a complete list of PICO-8 built-in functions.

josefnpat wrote a list of technical differences between PICO-8's Lua and the official Lua 5.2.<ul><li>List of differences: https://gist.github.com/josefnpat/bfe4aaa5bbb44f572cd0</li><li>Discussion: http://www.lexaloffle.com/bbs/?tid=2611</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>The Wee Dungeon</h2>{{Game|title = The Wee Dungeon|imagecaption = Title screen|first = Parlor|second = Platformer|third = Two|image = Weedungeon.jpg|imagewidth = 224}}<h4>Description</h4>Players must clear out dungeon rooms of creatures while collecting gold and various other items.<h4>Rules</h4><ul><li>Players start at the bottom corner of a dungeon room.  Due to having "impractical architecture", they must jump from platform to platform in order to make their way around.  If they are able to make their way through a room, they will come to a door, which entering it will lead them to another room.</li><li>Players fight various creatures along the way, which they can stab with their weapon.  Defeating a creature will yield gold, possibly a health power-up and/or an item.  Making contact with a creature will cost the player part of a heart meter (at the bottom of the screen) and the game will end when they are out of health.  Making contact with a spike will also end the game if the player does not have a special item in their possession.  A tally is then shown at the end of a game of how much gold was gathered and how many rooms were cleared.</li><li>Most creatures just automatically move from side to side, although with the more rooms players clear, tougher monsters will start appearing that carry shields to block attacks with that are harder to defeat.</li><li>Upon winning a battle, players will collect gold and possibly various items, such as a health power-up, which will increase their health.  Special items include shields (which can block attacks), helmets, armor and a better weapon.  These items can stop several attacks costing players their health, although they will disappear over time after they absorb too much damage.  Landing on a spike will cost the player an item and give them a split second to try and make their way out of their current trap.  Once a player obtains a stronger weapon and then loses it after it takes too much damage, they will revert back to their weaker default sword they started the game out with, whereas shields, armor and helmets will disappear entirely.</li><li>Two players can play simultaneously.</li></ul><h4>Controls</h4><ul><li>Use the Z key to start a game.</li><li>Use the left/right arrow keys to move player one and the S and F keys to move player two.</li><li>Use the up arrow key to make player one jump and the E key to make player two jump.</li><li>Use the Z key for player one to attack and the W key for player two to do the same.</li><li>Use the X key for player one to use a shield (if applicable) and the Q key for player two's shield.</li><li>Use the down arrow key for player one to enter a door and the D key for player two to do the same.</li><li>Use the escape or Enter key to pause the game.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>RunningPico8</h2>To run the PICO-8 app, you either double-click on the PICO-8 app icon, or you run it from a command console (aka terminal window). There are minor differences depending on which operating system you use.

Opening the app with the icon starts PICO-8 at the [[CommandPrompt|command prompt]] with default options.

When you run PICO-8 from the command line, you can specify command line flags to control certain behaviors. For example, you can specify the name of a cartridge file, and PICO-8 will load and run the cart immediately.

See the entry on [[Printh|<code>printh()</code>]] for information about how to locate the PICO-8 command for each operating system.

Command flags:

<code><nowiki>[switches] [filename.p8]</nowiki></code><ul><li><code>-run filename</code> : automatically load and run a cartridge</li><li><code>-x</code> : load the given cart, run it without a display, sound, or input, then exit when the cart exits</li><li>- p [param] : pass the given parameter into the cart. Can be accessed with [[Stat|<code>stat(6)</code>]] similar to [[Load|<code>load()</code>]]</li><li><code>-width n</code> : set the window or screen width and adjust scale to fit if not specified</li><li><code>-height n</code> : set the window or screen height and adjust scale to fit if not specified</li><li><code>-windowed n</code> : set windowed mode off (0) or on (1)</li><li><code>-sound n</code> : sound volume 0..256</li><li><code>-music n</code> : sound volume 0..256</li><li><code>-joystick n</code> : joystick controls starts at player n (0..7)</li><li><code>-pixel_perfect n</code> : 1 for unfiltered screen stretching at integer scales (on by default)</li><li><code>-draw_rect x,y,w,h</code> : absolute window coordinates and size to draw PICO-8's screen</li><li><code>-splore</code> : boot in splore mode</li><li><code>-home path</code> : set the path to store config.txt and other user data files</li><li><code>-desktop path</code> : set a location for screenshots and gifs to be saved</li><li><code>-screenshot_scale n</code> : scale of screenshots.  default: 3 (384x384 pixels)</li><li><code>-gif_scale n</code> : scale of gif captures. default: 2 (256x256 pixels)</li><li><code>-gif_len n</code> : set the maximum gif length in seconds (1..120)</li><li><code>-gui_theme n</code> : use 0 for the default background, 1 for a dark blue background, 2 for a black background, and 3 for a dark gray background in the code editor.</li><li><code>-tab_width n</code> : number of spaces in a tab in the code editor (default: 1)</li><li><code>-timeout n</code> : how many seconds to wait before downloads timeout (default: 30)</li><li><code>-software_blit n</code> : use software blitting mode off (0) or on (1)</li></ul>For example, to open PICO-8 and automatically start [[Splore]] in Mac OS X:

<pre>
/Applications/PICO-8.app/Contents/MacOS/pico8 -splore
</pre>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Configuration</h2>You can configure several aspects of how PICO-8 runs by editing a file called <code>config.txt</code>. The location of this file depends on which operating system you use.<ul><li>Windows: <code>C:/Users/Yourname/AppData/Roaming/pico-8/config.txt</code></li><li>Mac OS X: <code>/Users/Yourname/Library/Application Support/pico-8/config.txt</code></li><li>Linux: <code>~/.lexaloffle/pico-8/config.txt</code></li></ul>The file includes comments about the various options. If a line begins with <code>//</code> then it is treated as a comment line.

<span style="font-weight:bold;">Note:</span> PICO-8 overwrites the <code>config.txt</code> file each time you exit the app. If you open PICO-8, edit the config file, then exit (or restart) PICO-8, you will lose your changes. Close PICO-8 before editing <code>config.txt</code>.
Settings may be changed during runtime using the <code>[[config]]</code> command.

For information on configuring game controllers, see [[Controllers]].

See also [[RunningPico8|Running PICO-8]].<h4>Video settings</h4>; <code>video_mode width height bitdepth</code>
: Sets the width, height, and bit depth. For PICO-8, width and height adjust the window size (when not in full screen mode) and the PICO-8 display is a square of the smaller dimension, centered. Bit depth is ignored.
; <code>show_fps n</code>
: If n is 1, displays the current frame rate in the corner of the screen. The default is 0 (no display).<h4>Window settings</h4>; <code>windowed n</code>
: If n is 1, PICO-8 starts up in windowed mode. Set to 0 to start up in full screen mode.
; <code>window_position x y</code>
: The initial position of the window, or -1 -1 to use the window manager default.
; <code>frameless n</code>
: If n is 1, try to use a window with no frame.
; <code>fullscreen_method n</code>
: 0 = "safe", 1 = borderless desktop-sized window, 2 = OS full screen<h4>System settings</h4>; <code>frame_sleep_ms n</code>
: An amount of time to sleep each frame, in milliseconds.
; <code>sessions n</code>
: The number of times PICO-8 has been run. PICO-8 updates this value automatically.
; <code>rmb_key n</code>
: The scan code for a key that you can hold down while left-clicking the mouse to simulate right clicking. Good for laptops with one-button trackpads, like MacBooks. 224 is left Control, 226 is left Alt, 0 is none.<h4>Audio settings</h4>; <code>sound_volume n</code>
: The sound effects volume, 0 to 256.
; <code>music_volume n</code>
: The music volume, 0 to 256.
; <code>mix_buffer_size n</code>
: The memory size of the audio mixing buffer. 1024 or 2048.<h4>Other settings</h4>; <code>version n</code>
: The version of PICO-8 that is installed. PICO-8 manages this value.
; <code>root_path path</code>
: The filesystem path of the PICO-8 cartridge folder. This is the location of the files you can access from the [[CommandPrompt|command prompt]].
; <code>cdata_path path</code>
: The filesystem path of where PICO-8 stores persistent cartridge data.
; <code>joystick_index n</code>
: "Specify which player index joystick control begins at (0..7)"
; <code>button_keys p1_0 p1_1 p1_2 p1_3 p1_4 p1_5 p2_0 p2_1 p2_2 p2_3 p2_4 p2_5</code>
: Scan codes for the player 1 and player 2 controller keys on the keyboard. 0 uses the built-in default. The [[Keyconfig|keyconfig]] command updates this line.
; <code>live_notes n</code>
: If n is 1, the sound editor's frequency mode plays the note as it is being adjusted. The default is 0 (no sound).
; <code>aspect n</code>
: Sets the aspect ratio of the display. 420 is 1:1 (square, the default), 560 is 4:3, 525 is 5:4. Wider aspect ratios stretch the pixels. You may need to adjust <code>video_mode</code>.
; <code>cursor_snap n</code>
: If n is 1, the keyboard-driven cursor snaps to the closest pixel or map cel. ''(TK: how to move the cursor with the keyboard?)''
; <code>gif_len n</code>
: Set the maximum movie recording length to n seconds. If not set, the default is 8 seconds. PICO-8 is always recording so that you can save a video at any time, so larger values of n use more memory. (Press F8 to clear the video recording buffer. Press F9 to save the previous n seconds of video to a file as an animated GIF.)
; <code>tab_width n</code>
: Set the width of tab characters in the code editor.<hr style="height: 0.0625em;background-color: #888;" /><h2>Memory</h2>PICO-8 has 32 kilobytes of addressable memory, used for graphics, map, sound, music, and direct access to hardware features such as persistent cartridge data and GPIO pins. Programs can read from and write to this data using [[Peek|<code>peek()</code>]] and [[Poke|<code>poke()</code>]].

While many games can use the built-in functions for graphics and sound, memory access enables advanced techniques such as repurposing memory regions or generating graphics and sound data algorithmically. For features such as the GPIO pins, [[Peek|<code>peek()</code>]] and [[Poke|<code>poke()</code>]] are currently the only way to access the feature.

The first 16 kilobytes are copied from the cartridge into memory when the cartridge is loaded. When the cartridge changes a value in memory, it is only changed in memory and not in the cartridge itself.

The [[Cstore|<code>cstore()</code>]] function can be used to write memory data to the cartridge file. The [[Reload|<code>reload()</code>]] function can also be used to load cartridge data back into memory, or load a region of memory from another cartridge file.

The Lua program stack (variables, etc.) is not stored in addressable memory and cannot be accessed directly by the program.

See also [[P8FileFormat]], [[P8PNGFileFormat]].<h4>Memory map</h4>This is the high-level memory map for addressable memory:{|
| Start || End || Purpose
|-  
| 0x0 || 0x0fff || Sprite sheet (0-127)
|-  
| 0x1000 || 0x1fff || Sprite sheet (128-255) / Map (rows 32-63) (shared)
|-  
| 0x2000 || 0x2fff || Map (rows 0-31)
|-  
| 0x3000 || 0x30ff || Sprite flags
|-  
| 0x3100 || 0x31ff || Music
|-  
| 0x3200 || 0x42ff || Sound effects
|-  
| 0x4300 || 0x5dff || General use (or work RAM)
|-  
| 0x5e00 || 0x5eff || Persistent cart data (64 numbers = 256 bytes)
|-  
| 0x5f00 || 0x5f3f || [[DrawState|Draw state]]
|-  
| 0x5f40 || 0x5f7f || Hardware state
|-  
| 0x5f80 || 0x5fff || GPIO pins (128 bytes)
|-  
| 0x6000 || 0x7fff || Screen data (8k)
|}The in-memory data formats for each section are described below.<h4>Sprite sheet</h4>The sprite sheet is represented in memory as one large image, 128 x 128 pixels. Each sprite tile is an 8 x 8 region in this image. Each sprite tile gets an ID, counting from 0, left to right, top to bottom.

Each pixel can be one of 16 colors, and is represented by 4 bits. An 8-bit byte represents two pixels, horizontally adjacent, where the most significant (leftmost) 4 bits is the <span style="font-style:italic;">right</span> pixel of the pair, and the least significant 4 bits is the <span style="font-style:italic;">left</span> pixel. Pixels are stored from left to right, top to bottom.

Other than this swapping within the byte, pixels are arranged in memory going left to right, top to bottom, for the entire 128 x 128 pixel image (using 128 * 64 = 8,192 bytes).

The bottom half of the sprite sheet and the bottom half of the map region overlap in memory. Typically, a game uses this region for only one purpose or the other.

<span style="font-weight:bold;">0x0000-0x0fff / 0-4095</span>:The upper 64 rows in the sprite sheet. Each 64-byte row contains 128 pixels. Each byte contains two adjacent pixels, with the lo 4 bits being the left/even pixel and the hi 4 bits being the right/odd pixel.<span style="font-weight:bold;">0x1000-0x1fff / 4096-8191</span>:The lower 64 rows in the sprite sheet. Same format as above. Overlaps ''lower'' half of Map (see below).<h4>Map</h4>The map is 128 tiles wide by 64 tiles high. Each tile is one of the 256 tiles from the sprite sheet, one byte per tile (using 128 * 64 = 8,192 bytes). The value is the sprite ID.

The map is read from left to right, top to bottom order.

<span style="font-weight:bold;">0x1000-0x1fff / 4096-8191</span>:The ''lower'' 32 rows of the map. Each row contains 128 tiles. Each byte contains one tile index. Overlaps lower half of Sprite Sheet (see above).<span style="font-weight:bold;">0x2000-0x2fff / 8192-12287</span>:The upper 32 rows of the map. Each row contains 128 tiles. Each byte contains one tile index.<h4>Sprite flags</h4>Each sprite tile has 8 flags, each of which can be on or off. One byte stores the flags for a sprite tile. Bytes are arranged by sprite ID, for a total of 256 bytes.

In the graphics editor, the flags are arranged left to right from LSB to MSB: red=1, orange=2, yellow=4, green=8, blue=16, purple=32, pink=64, peach=128.

<span style="font-weight:bold;">0x3000-0x30ff / 12288-12543</span>:Each byte represents the flags for the associated sprite.<h4>Music</h4>There are 64 music patterns. Each music pattern uses four bytes to assign a sound effect or silence to each of four channels. (4 * 64 = 256 bytes.)

If a sound effect is assigned to a channel, bit 6 is 0, and bits 5-0 are the sound ID (0 through 63). If the channel is silent, bit 6 is 1, and bits 5-0 are not used.

Bit 7 is used to describe the flags for the music pattern. Bit 7 of the first byte (channel 1) is "begin pattern loop." Bit 7 of the second byte (channel 2) is "end pattern loop." Bit 7 of the third byte (channel 3) is "stop at end of pattern." (Bit 7 of the fourth byte is unused.)<h4>Sound effects</h4>There are 64 sound effects. Each sound effect is 68 bytes, with two bytes for each of 32 notes and then one byte for the editor mode, one byte for the speed, two bytes for the loop range (start, end). (64 * 68 = 4,352 bytes.)

The effect speed is a value between 0 and 255, representing the duration of each note in the effect, as a multiple of 1/128 seconds. Using the full effect length of 32 notes, with a speed of 1, the full effect plays in 1/4 second. With a speed of 4, the full effect plays in 1 second.

In an effect used for a music pattern, beats per minute can be calculated based on how many notes per "beat." For example, if an effect plays a "beat" every four notes in an effect, a speed of 15 is equivalent to 15/128 seconds per note, 15*4/128 seconds per four notes (one beat), (15*4)/(128*60) minutes per beat, or (128*60)/(15*4) = 128 beats per minute.

Each note is encoded in 16 bits, in [https://en.wikipedia.org/wiki/Endianness Little Endian] style, with the low 8 bits in the first byte, and the hi 8 bits in the second, formatted like so:

<div align=center>{| class="article-table" style="display: inline-table;"
!colspan=8 align=center|Second byte / Hi 8 bits
|-
|c
|e
|e
|e
|v
|v
|v
|w
|}{| class="article-table" style="display: inline-table;"
!colspan=8 align=center|First byte / Lo 8 bits
|-
|w
|w
|p
|p
|p
|p
|p
|p
|}</div><ul><li><code>c</code>: when c is 1, waveform is a custom instrument corresponding to sfx 0-7; otherwise it is one of the eight built-in waveforms (PICO-8 0.1.11+)</li><li><code>eee</code>: effect (0-7)</li><li><code>vvv</code>: volume (0-7)</li><li><code>www</code>: waveform (0-7)</li><li><code>pppppp</code>: pitch (0-63)</li></ul>For example, a note's pitch and effect can be seen using <code>peek(0x3200 + 68*track + 2*time)</code>, and instrument and volume by <code>peek(0x3200 + 68*track + 2*time + 1)</code>. So if 30 was seen for instrument and volume, they are stored in bits <code>0b0011110</code> so the instrument is <code>0b001</code> (1) and volume is <code>0b111</code> (7); the last bit is used for sfx instrument flag, 0 if off, 1 if on. <!-- TODO: This bit really needs to be re-worded. It's kind of hard to follow. --><h4>General use</h4><span style="font-weight:bold;">0x4300-0x5dff / 17152-24063</span>
This memory region is available for the program to use for any purpose.

This region is not loaded from the cartridge, though the [[Reload|<code>reload()</code>]] function can be used to copy data into this region from a cartridge file.

(Undocumented?) This region is not reset when loading another cart via [[Load|load()]], so can be used for passing data to and from the loaded cart.<h4>Persistent cart data</h4><span style="font-weight:bold;">0x5e00-0x5eff / 24064-24319</span>
After persistent data is initialized with the [[Cartdata|<code>cartdata()</code>]] function, the 256-byte region from 0x5e00 to 0x5eff represents the 64 number values accessible by [[Dset|<code>dset()</code>]] and [[Dget|<code>dget()</code>]]. These numbers are stored in the same 4-byte, [https://en.wikipedia.org/wiki/Endianness little endian], 16.16 fixed-point format used by [[Peek4|<code>peek4()</code>]] and [[Poke4|<code>poke4()</code>]].

Note that using <code>dset()</code> and <code>dget()</code> partitions this memory into 64 standard PICO-8 numbers, but these are just helper functions and they are not mandatory. This memory region can be formatted in any desired manner. For instance, a bar chart with up to 51 bars could be encoded by saving a width for each bar and its color index, with the width being a full PICO-8 number and the color just being a byte:

<pre>
function bar_set(index, width, color)
  local addr = 0x5e00 + index*5
  poke4(addr, width)
  poke(addr+4, color)
end

function bar_get(index)
  local addr = 0x5e00 + index*5
  return peek4(addr), peek(addr+4)
end
</pre><h4>Draw state</h4>This memory region represents the current [[DrawState|draw state]]. The values are as follows:

<span style="font-weight:bold;">0x5f00-0x5f0f / 24320-24335</span>:Draw palette look-up table ([[Pal|<code>pal()</code>]], [[Palt|<code>palt()</code>]]). When PICO-8 is asked to draw a certain 4-bit color index, it looks up the color's index in this table to decide which ''actual'' 4-bit color index to write to screen memory. The 16 values in this table should have their lower 4 bits set to 0-15, to indicate which index is actually written to screen memory, while bit 5 should be either 0 for normal operation, or 1 (i.e. add 16 to the index) if the color index is to be transparent.<span style="font-weight:bold;">0x5f10-0x5f1f / 24336-24351</span>:Screen palette look-up table ([[Pal|<code>pal(...,1)</code>]]). PICO-8 reads this table while converting the color indices in screen memory into system ("hardware") colors to be shown on its display. As of this writing, there are ''officially'' only 16 system colors available, whose values range from 0 to 15. However, an additional, but undocumented, 16 colors appear to be available at values from 128 to 143, and [https://twitter.com/lexaloffle/status/1169094824474992640 zep appears to be fine with us knowing this].<span style="font-weight:bold;">0x5f20-0x5f23 / 24352-24355</span>:Clipping rectangle ([[Clip|<code>clip(x,y,w,h)</code>]])::*0x5f20 / 24352: x_begin (no pixels < x_begin will be drawn)
:*0x5f21 / 24353: y_begin (no pixels < y_begin will be drawn)
:*0x5f22 / 24354: x_end (no pixels >= x_end will be drawn)
:*0x5f23 / 24355: y_end (no pixels >= x_end will be drawn):These are somewhat different from the <code>clip(x,y,w,h)</code> arguments. Use <code>clip(xb,yb,xe-xb,ye-yb)</code> to set a clip rectangle using values like these.:Note: Inside <code>clip()</code> the rectangle is clamped to the edges of the display before the GPU is configured. Expect x,y begin values to be in the range 0..127, and x,y end values to be in the slightly-larger range 0..128.<span style="font-weight:bold;">0x5f24 / 24356</span>:''(unknown, please update this if you know)''<span style="font-weight:bold;">0x5f25 / 24357</span>:Pen color ([[Color|<code>color()</code>]]). The bottom 4 bits are the current color index, from 0-15. The top 4 bits are typically 0 and unused, but when using fill patterns, they will be the secondary color index.<span style="font-weight:bold;">0x5f26-0x5f27 / 24358-24359</span>:Print cursor ([[Cursor|<code>cursor()</code>]]). 0x5f26=x, 0x5f27=y.<span style="font-weight:bold;">0x5f28-0x5f2b / 24360-24363</span>:Camera position ([[Camera|<code>camera()</code>]]). The x and y offsets are stored as 16-bit signed integers with the least significant byte first. 0x5f28-0x5f29=x offset, 0x5f2a-0x5f2b=y offset.<span style="font-weight:bold;">0x5f2c / 24364</span>:This value sets the draw mode to normal, stretching, mirroring, flipping, or rotating.
:* 0 = normal mode
:* 1 = horizontal stretch, 64x128px screen, left half of normal screen
:* 2 = vertical stretch, 128x64px screen, top half of normal screen
:* 3 = both stretch, 64x64px screen, top left quarter of normal screen
:* 5 = horizontal mirroring, left half copied and flipped to right half
:* 6 = vertical mirroring, top half copied and flipped to bottom half
:* 7 = both mirroring, top left quarter copied and flipped to other quarters
:* 65-71 = same as 1-7?The following modes are introduces in 0.1.12d which is currently available on the BBS but not as a binary download yet.:* 129 = horizontal flip
:* 130 = vertical flip
:* 131 = both flip
:* 133 = clockwise 90 degree rotation
:* 134 = 180 degree rotation (effectively equivalent to 131)
:* 135 = counterclockwise 90 degree rotation
:* 193-199 = same as 129-235?<span style="font-weight:bold;">0x5f2d / 24365</span>:If set to 1, devkit mode is enabled, allowing mouse coordinates and keyboard status to be checked via the [[Stat#.7B30.E2.80.A636.7D_Mouse_and_keyboard_in_.22devkit_mode.22|<code>stat()</code>]] command.<span style="font-weight:bold;">0x5f2e / 24366</span>:(undocumented, but confirmed by zep) If set to 1, causes the current palette scheme (see [[Pal|<code>pal()</code>]] and/or the 0x5f00-0x5f1f memory range, above) to persist instead of being reset at the end of the program.<span style="font-weight:bold;">0x5f2f / 24367</span>:(undocumented) If set to 1, pause the music and SFX playback engine, until 0 is written back to it. If set to 2, allow music to continue when the pause menu is displayed.<span style="font-weight:bold;">0x5f30 / 24368</span>:(undocumented) If set to 1, suppresses the ''next'' attempt to bring up the pause menu. This can be done as late as discovering the pause button has been pressed this frame:
::<syntaxhighlight lang="lua">
  if(btn(6)) poke(0x5f30,1)
</syntaxhighlight><span style="font-weight:bold;">0x5f31-0x5f33 / 24369-24371</span>:Fill pattern ([[Fillp|<code>fillp()</code>]]). 0x5f31-0x5f32 contain the fill pattern as a 16-bit unsigned integer with the least significant byte first. 0x5f33's bit 0 is the related transparency bit.<span style="font-weight:bold;">0x5f34 / 24372</span>:If set to 1, changes the PICO-8 drawing API to accept color values that incorporate not just one or two colors, but optionally include information about both the fill pattern and transparency right in the color value. From the manual:<pre style="margin-left: 24px">
-- bit  0x1000.0000 means the non-colour bits should be observed
-- bit  0x0100.0000 transparency bit
-- bits 0x00FF.0000 are the usual colour bits
-- bits 0x0000.FFFF are interpreted as the fill pattern
</pre>

<span style="font-weight:bold;">0x5f35-0x5f3b / 24373-24379</span>:''(unknown, please update this if you know)''<span style="font-weight:bold;">0x5f3c-0x5f3f / 24380-24383</span>:Ending position of the previous line drawn using  <code>[[Line|line()]]</code>. If no line has been drawn, these values will be 0. The x and y coordinates are stored as 16-bit signed integers with the least significant byte first. 0x5f3c-0x5f3d=x coordinate, 0x5f3e-0x5f3d=y coordinate. (Note: This was added in PICO-8 0.1.12b.)<h4>Hardware state</h4>These memory addresses represent or control various aspects of the hardware. These are undocumented.

0x5f40-0x5f43 are control registers for the audio hardware. They're encoded with the following format:

xxxx-ch3-ch2-ch1-ch0

Setting bit 0 (ch0, value 1) enables the effect for channel 0, bit 1 (ch1, value 2) is for channel 1, etc. The "x" bits are unused. The features that each register control are as follows:

<span style="font-weight:bold;">0x5f40 / 24384</span>:Halves an audio channel's clock rate. The main rate is 22.05 KHz, and enabling the feature for a channel will cause it to be 11.025 KHz instead. This causes SFX and arp speeds to be halved, and the note pitch to be an octave lower.<span style="font-weight:bold;">0x5f41 / 24385</span>:Enables reverb (echo) for a channel.<span style="font-weight:bold;">0x5f42 / 24386</span>:Distorts the output of a channel. The audio becomes 3-bit (8 linear levels) without any dithering.<span style="font-weight:bold;">0x5f43 / 24387</span>:Enables a lowpass filter for a channel.:The priorities of the features are as follows, from left (lowest priority) to right (highest priority)::Reverb < Distortion < Lowpass < Half-Clock<span style="font-weight:bold;">0x5f44-0x5f7f / 24388-24447</span>:The remaining registers up to 0x5f7f are undocumented.<h4>GPIO pins</h4>This experimental feature provides programs access to the [[GPIO]] (general purpose input/output) hardware pins of a Raspberry Pi or CHIP device. These addresses can be used to accept digital input from or write digital output to devices connected to the pins. JavaScript code that runs in a browser can also access them by defining a global array named <span style="font-style:italic;">pico8_gpio</span>. There are up to 128 pins, depending on the platform.

<span style="font-weight:bold;">0x5f80-0x5fff / 24448-24575</span>:Each byte represents the value of 1 pin. The possible values vary depending on the platform.<h4>Screen data</h4>This 8,192-byte (8 kilobyte) region contains the graphics buffer. This is what is modified by the built-in drawing functions, and is what is copied to the actual display at the end of the [[GameLoop|game loop]] or by a call to [[Flip|<code>flip()</code>]].

<span style="font-weight:bold;">0x6000-0x7fff / 24576-32767</span>:All 128 rows of the screen, top to bottom. Each row contains 128 pixels in 64 bytes. Each byte contains two adjacent pixels, with the lo 4 bits being the left/even pixel and the hi 4 bits being the right/odd pixel.<h4>Lua Memory</h4>The Memory used by Lua (global variables, local variables, tables, etc.) is entirely separate from the Pico-8 memory discussed above and is limited to 2 [[MiB]].

The amount of memory currently used by the program can be checked with [[Stat|stat(0)]] and adds up as follows (all numbers are in bytes):<ul><li><span style="font-weight:bold;">nil / boolean / number</span> - no extra cost.</li><li><span style="font-weight:bold;">string</span> - 17 + 1 * (# of characters)</li></ul>Strings of length <= 40 are always interned, meaning creating such a string again (through any means) will simply use the previously created string and cost nothing.

On the other hand, interned strings are also stored in a global hash table, which grows whenever the number of interned strings reaches a new power of 2. Here, each interned string costs an additional ~4-8 bytes, though this cost is only observable - in bulk - whenever the hash table grows.<ul><li><span style="font-weight:bold;">table</span> - 32 + 8 * nextpow2(# of 'array' entries) + 20 * nextpow2(# of 'hash' entries)</li></ul>Here, nextpow2 gives the next power of 2 (e.g. 2 -> 2, 3 -> 4, 4 -> 4, 5 -> 8, 130 -> 256).

For example, {1,2,a=3,b=4,c=5} takes 128 bytes: 32 + 8 * 2 + 20 * 4<ul><li><span style="font-weight:bold;">function </span>- 16 + 4 * (# of captured variables) + 32 * (# of newly captured variables)</li></ul>A captured variable is any local variable declared outside the function, that's accessed inside the function.

A "newly" captured variable is merely one that wasn't captured before by other functions.

A function that uses any globals automatically captures _ENV, and this counts as a captured variable. (Unless _ENV is explicitly re-declared, it never counts as a newly captured variable, though.)

If a function is created multiple times, the previously created instance is reused if possible, thus costing nothing. The previous instance can be reused if it has no captured variables, or if it has captured variables but they're all the same variables as the captured variables of the new function.<ul><li><span style="font-weight:bold;">thread</span> (created by cocreate) - 352 bytes.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>PicoLove</h2>PicoLove is a third-party implementation of the PICO-8 runtime environment based on Lua and the [https://love2d.org/ Löve] game engine. PicoLove can be used to run PICO-8 games on platforms not currently supported by PICO-8 or the PICO-8 web player, such as mobile devices.

PicoLove was created by impbox, and has been forked and extended by gamax92.<ul><li>impbox original on Github: https://github.com/picolove/picolove</li><li>gamax92 fork on Github: https://github.com/gamax92/picolove</li><li>Discussion: http://www.lexaloffle.com/bbs/?tid=2444</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>AwesomePico8List</h2>The "Awesome Pico-8 List" is a list of Pico-8 developer resources, created and maintained by felipebueno.<ul><li>Github: https://github.com/felipebueno/awesome-PICO-8</li><li>Announcement: http://www.lexaloffle.com/bbs/?tid=2604</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>CheatSheet</h2>The PICO-8 cheat sheet is an interactive web page summary of the PICO-8 API and features intended as a quick reference for PICO-8 developers. It was created and is maintained by Neko250, with contributions from the community.<ul><li>Link: http://neko250.github.io/pico8-api/</li><li>Discussion: http://www.lexaloffle.com/bbs/?tid=2687</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>P8Coder</h2>P8Coder is a third-party development tool for Windows for making games for the PICO-8 platform. It includes a code editing environment that lets you organize the code for a cartridge in multiple tabs, as well as a sprite sheet viewer. P8Coder was created and is maintained by movAX13h.<ul><li>Link: http://blog.thrill-project.com/p8coder-pico-8-programming-tool/</li><li>Discussion: http://www.lexaloffle.com/bbs/?tid=3351</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>P8Jam</h2>P8Jam is a game jam hosted by Lexaloffle Games focused on the Pico-8 platform. There have been two rounds of the game jam. Each round lasted nine days and was based on a theme. A "winner" was chosen by community voting using a special feature of the [[Forum|forum]] built for the jams.<ul><li>p8jam #1, November 21-29, 2015, theme: "Rain"<ul><li>Announcement: http://www.lexaloffle.com/bbs/?tid=2769</li><li>Theme reveal: http://www.lexaloffle.com/bbs/?tid=2794</li><li>Entries: http://www.lexaloffle.com/bbs/?cat=7&tag=p8jam1</li><li>Results: http://www.lexaloffle.com/bbs/?tid=2870</li></ul></li></ul><ul><li>p8jam #2, May 21-29, 2016, theme: "Chain Reaction"<ul><li>Announcement: http://www.lexaloffle.com/bbs/?tid=3330</li><li>Theme reveal: http://www.lexaloffle.com/bbs/?tid=3399</li><li>Entries: http://www.lexaloffle.com/bbs/?cat=7&tag=p8jam2</li><li>Results: http://www.lexaloffle.com/bbs/?tid=3558</li></ul></li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>CommandPrompt</h2>The PICO-8 command prompt lets you interact with PICO-8 and the currently loaded cartridge using typed commands. By default, the command prompt is the first thing you see when starting PICO-8. 
[[File:Commandprompt.png|thumb|220x220px]]
You use the command prompt to load and save cartridges, manage PICO-8 files, organize them into folders ("directories"), and perform other actions such as starting [[Splore]].

<pre>
> install_demos
> load demos/jelpi
> run
</pre>

For a list of available commands, see [[CommandReference]].

You can type Lua statements (such as [[Print|print()]]) at the prompt to execute them. This is a good way to experiment with the PICO-8 [[APIReference|built-in functions]] and try [[Lua]].

<span style="font-weight:bold;">Note:</span> The PICO-8 prompt only accepts commands and statements. To see the value of an expression, you must use the [[Print|print()]] statement.<h4>Getting back to the command prompt</h4>When playing a cartridge, you can interrupt the program and return to the command prompt by pressing the Escape key. You can enter Lua statements at the prompt to examine or change the program's global variables. In many cases, you can use the [[Resume|resume]] command to continue the program (though see [[Resume|resume]] for caveats).

If you started the cartridge from [[Splore]], pressing Escape opens the Splore pause menu. To get to the command prompt from here, select Splore from this menu, then press Escape again.

At the command prompt, pressing Escape opens the cartridge editor interface. To return to the command prompt from here, press Escape again.

The command prompt is exclusive to the PICO-8 app, and is not available from the PICO-8 web player.

<hr style="height: 0.0625em;background-color: #888;" /><h2>I'm Not Santa!</h2>{{Game|title = I'm Not Santa!|imagecaption = Screenshot|first = Lokno|second = Shooter|third = One|image = Imnotsanta.jpg|imagewidth = 224}}<h4>Description</h4>The player controls a "shitty wizard" who just wants to drink his coffee in peace, but children mistake him for Santa and won't leave him alone!<h4>Rules</h4><ul><li>If left idle for a few seconds at a time without moving, the wizard will rack up points by drinking his coffee.</li><li>Children start appearing and making their way towards the wizard; if any of them make contact with him, the game will end.</li><li>The wizard can shoot and temporarily stun children by turning them into snowmen, which will start cluttering up the playfield with the more children he shoots.</li></ul><h4>Controls</h4><ul><li>Click on the play icon to start a game.</li><li>Use the arrow keys to move the wizard.</li><li>Use the Z key to shoot.</li><li>Use the escape or Enter key to pause the game.</li></ul><h4>Links</h4>[http://www.lexaloffle.com/bbs/?tid=2895 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>DarkLBA</h2>{{Game|title = DarkLBA|imagecaption = Title screen shot|first = FRedShift|second = Simulation|third = One|image = Darklba.jpg|imagewidth = 224}}<h4>Description</h4>Children must be saved during a game.  They must be freed, led to safety, and not let them be caught by zombies.<h4>Rules</h4><ul><li>Zombies drop down from the sky; making contact with one will drain the player (named Twinsen) of a life point.  If the player runs out of life points the game will end.  Twinsen can shoot zombies with balls, however.</li><li>15-25 children (depending on difficulty level setting) are scattered about a level kept in cages.  Touching a cage will free a child.  Once attacked by a zombie, Twinsen has seven seconds to kill the zombie or else the child will die.</li><li>Freed children will follow Twinsen around, which they must be influenced towards the exit (a blue square).  Once all children have been led to the exit (not counting any that were killed during the game), Twinsen must then enter it as well in order to end the game.</li><li>Game maps, difficulty level, cursor and camera settings can be tweaked.</li></ul><h4>Controls</h4><ul><li>Use the arrow keys to move Twinsen.</li><li>Use the Z key to shoot.</li><li>Use the escape, X, or Enter key to pause the game.</li></ul><h4>Links</h4>[http://www.lexaloffle.com/bbs/?tid=2952 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>GameLoop</h2>The game loop is the mechanism that drives a game's logic and rendering processes. Because each cycle of the loop updates the display, it is important for the loop to run at regular intervals to keep the animation smooth and the game feeling responsive to user input.

PICO-8 has a built-in game loop that runs 30 times per second. You use this in your code by defining three functions: [[Init|_init()]], [[Update|_update()]], and [[Draw|_draw()]].

Both <code>_update()</code> and <code>_draw()</code> must be defined for PICO-8's game loop to execute. <code>_init()</code> is optional.

<pre>
-- initialize the position to be the center of the screen
function _init()
  xpos = 64
  ypos = 64
end

-- update the position based on the player pressing buttons
function _update()
  if (btn(0) and xpos > 0) xpos -= 1
  if (btn(1) and xpos < 127) xpos += 1
  if (btn(2) and ypos > 0) ypos -= 1
  if (btn(3) and ypos < 127) ypos += 1
end

-- clear the screen, then draw a circle at the current position
function _draw()
  cls()
  circfill(xpos, ypos, 10, 8)
end
</pre><h4>Init</h4>The [[Init|_init()]] function is called once when the cartridge is initialized. It is not part of the main game loop. However, it is a good practice when using the game loop to put all statements that initialize the cartridge in this function, instead of using statements at the top level of your code.

PICO-8 calls <code>_init()</code> automatically before starting the game loop if the game loop is being used.<h4>Update</h4>The [[Update|_update()]] function is where the game performs all of its logic for the next frame. This is where you read user input, update the game world simulation, and start (asynchronous) music and sound events.<h4>Draw</h4>The [[Draw|_draw()]] function is where the game does all of the work to draw the current state of the game to the screen.

PICO-8 attempts to call both <code>_update()</code> and <code>_draw()</code> 30 times per second. If the code takes longer than 1/30th of a second to execute, PICO-8 will skip the occasional call to <code>_draw()</code> so that the game world simulation has a chance to "catch up" to real time. The player is less likely to notice a missing <code>_draw()</code> call than slowness in the game simulation.<h4>Writing your own game loop</h4>If for some reason you want different behavior for your game loop than is provided by [[Update|_update()]] and [[Draw|_draw()]], you can implement a custom loop in your own code.

At the end of each frame, the PICO-8 game loop copies the graphics buffer to the screen, then waits until the next tick of the frame timer. To do this in your code, call the [[Flip|flip()]] function.

You can use the [[Stat|stat()]] function to measure the amount of time between ticks of the frame timer is spent executing your code. If <code>stat(1)</code> returns a value greater than 1, that means you passed a frame deadline without calling <code>flip()</code>, and you might need to do less work during the next frame (such as skipping draw calls) to catch up. This is how the built-in game loop determines whether to skip a call to <code>_draw()</code>.<h4>See Also:</h4><ul><li>[[Init|<code>_init()</code>]]</li><li>[[Update|<code>_update()</code>]]</li><li>[[Draw|<code>_draw()</code>]]</li></ul><h8><nowiki/></h8>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Butlerian Jihad</h2>{{Game|title = Butlerian Jihad|imagecaption = Title screen shot|first = joshmillard|second = Strategy|third = One|image = Jihad.jpg|imagewidth = 224}}<h4>Description</h4>The player controls humanitarian rebel Jehanne Butler that must avoid robots that are out to kill her and enslave humanity by influencing them to destroy each other.<h4>Rules</h4><ul><li>Being a turn-based game, with every time Butler moves, the robots will also make a move.  Butler can also skip a turn and let the robots advance.</li><li>One of the few defenses Butler has is to influence the robots to collide with each other, or the debris of a former robot.  For instance, there could be still-functioning robots to the left of the screen with a space of robot debris in the same path in the middle and Butler is on the right side of the screen.  She can just wait out her turns as the functioning robots keep on advancing until they all plow into the square holding the robot debris and end up being destroyed.</li><li>Butler has a displacement belt that can be used to relocate her to a random screen area during a level.</li><li>Butler also has a shield function that can destroy one or more robots; one extra shield unit is gained with every level cleared.  However, if Butler relocates to an area of a level that has a robot right next to it and she has at least one shield unit left, the robots will then take a turn, the robot where she landed next to will advance, be destroyed by her shield and she will use up a shield.  If a robot touches her with no shield units remaining the game will end.</li></ul><h4>Controls</h4><ul><li>Use the arrow keys plus the Z key to move Butler.</li><li>Use the Z key to wait out a turn/advance the robots without moving.</li><li>Use the X key to displace to a different area.</li><li>Use the Enter key to pause the game.</li></ul><h4>Links</h4>[http://www.lexaloffle.com/bbs/?tid=2266 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Magic Jewelry: The Tale of 1000 Gems</h2>{{Game|title = Magic Jewelry: The Tale of 1000 Gems|imagecaption = Title screen shot|first = adrian09_01|second = Puzzle|third = One|image = Magicjewelrywiki.jpg|imagewidth = 224}}<h4>Description</h4>The player must move and place puzzle pieces however they best see fit in order to score as high as possible and keep the game going for as long as possible.<h4>Rules</h4><ul><li>Puzzle pieces drop down from the top towards the bottom of the screen.  They are comprised of one to three colors; the player must arrange them so the same color makes a straight line that is at least three pieces of the same color together.  This will make rows of the same puzzle pieces disappear.</li><li>The next upcoming piece (i. e. not the one currently in play) is displayed at the top right area of the screen.</li><li>If puzzle pieces stack up to the top of the screen without being disposed of then the game will end.</li><li>At various intervals, a piece will appear that is beige and its pieces comprise the letter X.  Placing this anywhere on the puzzle pieces in the playing area will cause several of them to be removed.  This also indicates that the next level has been reached.</li></ul><h4>Controls</h4><ul><li>Use the X key to start a new game.</li><li>Use the left/right arrow keys to move the current piece in play.</li><li>Use the X or Z keys to change up the order of the current piece in play.</li><li>Use the down arrow key to pull the current puzzle piece down to the bottom of the screen.</li><li>Use the Enter or P key to pause the game.</li></ul><h4>Links</h4>[http://www.lexaloffle.com/bbs/?tid=3417 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Hydra</h2>{{Game|title = Hydra|imagecaption = Title screen shot|first = scgrn|second = Adventure|third = One|image = Hydra.jpg|imagewidth = 224}}<h4>Description</h4>Starting off on a large island, the player must find, enter, and make their way through three dungeons before facing a hydra boss in hopes of defeating the game.<h4>Rules</h4><ul><li>The player must walk around the countryside until they find a dungeon entrance, then enter it.</li><li>While inside, the player must swipe at enemies with their sword.  Each one will take a few hits until they are killed; meanwhile, if they make contact with the player’s character, that will cause damage to the player (as shown on the player’s strength meter at bottom left of screen).  If the player takes enough damage then the game will end, although the player has unlimited continues.  Also, some enemies, upon being slain, will leave behind some “life essence that could be absorbed” by the player, which will partially heal them.</li><li>A compass is included at the top part of the screen, along with a map at the bottom right corner, showing the layout of the current dungeon the player is in.</li><li>All dungeons have two save areas that the player can continue their game with if they want to go back to it later, along with areas that will state that the dungeon was cleared, even if there are still rooms that the player has not yet encountered.</li><li>Green creatures make up all dungeons, evil mages appear with the second dungeon, and the hydra appears during the final dungeon.</li></ul><h4>Controls</h4><ul><li>Use the x or z key to start a new game.</li><li>Use the p or Enter keys to pause a game.</li><li>Use the arrow keys to move and enter/exit dungeons and doors.</li><li>Use the x key to attack.</li><li>Use the z key to strafe.</li><li>Face each statue in the final dungeon in order to light them up to continue to the hydra.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=3191 Play game]
		


<hr style="height: 0.0625em;background-color: #888;" /><h2>Puzzle Cave - Raiders Of The Lost Potato</h2>{{Game|title = Puzzle Cave - Raiders Of The Lost Potato|imagecaption = Title screen shot|first = hackefuffel|second = Puzzle|third = One|image = Puzzlecave.jpg|imagewidth = 224}}<h4>Description</h4>Potatomonsters stole all potatoes from Pinkbunnyland.  Help Pinkbunny to collect all stolen potatoes and save Pinkbunnyland!<h4>Rules</h4><ul><li>Once Pinkbunny has collected all potatoes in a level, a key will appear; collecting the key will cause a door to disappear, leading to the next level.  Collect the key to move to the next level.</li><li>Diamonds start appearing in levels that block Pinkbunny's access to potatoes and certain areas of a level.  Pinkbunny can push the single diamonds out of the way, however, to gain access to potatoes.  Two diamonds together cannot be moved if there are no other paths around them.</li><li>After several levels, green creatures begin appearing that will shoot off lasers if Pinkbunny enters their line of sight.  These bring instantaneous death.  However, they can be blocked by diamonds.</li><li>If Pinkbunny gets stuck in a level with no way to solve it, the level can be reset.</li><li>All levels, including the game, can be beaten..</li></ul><h4>Controls</h4><ul><li>Use the x or z key to start a new game.</li><li>Use the p or Enter keys to pause a game.</li><li>Use the arrow keys to move, push diamonds, collect potatoes and keys and exit levels.</li><li>Use the x or z key to restart a level.</li><li>Use the p or enter key to pause the game.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=2039 Play game]
		


<hr style="height: 0.0625em;background-color: #888;" /><h2>Shoot Stuff!</h2>{{Game|title = Shoot Stuff!|imagecaption = Title screen shot|first = starvingindie|second = Shooter|third = One|image = Shootstuff.jpg|imagewidth = 224}}<h4>Description</h4>The pollen wars are in full effect and it's up to you to destroy the robots that seek to eradicate all pollen from your planet.<h4>Rules</h4><ul><li>The player's character can either jump over or shoot robots.</li><li>Robots come in three variations: a fast-moving small blue robot, a slow-moving small red robot that fires projectiles upwards and a large red robot that moves slowly but takes five hits to be destroyed.  All robots have an indicator as to how many hits they will take before being destroyed (one to two for small robots and five for the large ones).  At top center of the screen is a tally as to how many robots need to be destroyed in order to win the game (with a count total of 100 is required).</li><li>Along with robots, fireballs also start falling from the sky, which, if they hit the ground they will explode and cause damage to the player if they're too close to it.  Coming into contact with robots and the red robots' projectiles will take off a health unit (as indicated at top right) and the game will end when the player runs out of health.</li><li>The player starts off a game with 20 rounds of ammunition; occasionally a destroyed robot will leave behind extra ammo.  Crates fall down from the sky which will restore health if they land without being shot and the player picks them up, or they can be used to totally refill the player's ammo level to maximum (20 rounds) if the crate lands and the player shoots it.  However, if the crate lands on a robot it will be destroyed and a bonus health unit or ammo will be lost.  If the player runs out of ammo the game will end.</li></ul><h4>Controls</h4><ul><li>Use the x + c keys to start a new game.</li><li>Use the x key to shoot.</li><li>Use the left/right arrow keys to move.</li><li>Use the up arrow key to jump.</li><li>Use the p or Enter key to pause the game.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=3276 Play game]
		


<hr style="height: 0.0625em;background-color: #888;" /><h2>Matt Versus Slenderman</h2>{{Game|title = Matt Versus Slenderman|imagecaption = Title screen shot|first = meeblue|second = Puzzle|third = One|image = Mattversus.jpg|imagewidth = 224}}<h4>Description</h4>The player controls Matt, who must collect several pages while avoiding Slenderman.<h4>Rules</h4><ul><li>Matt must explore several locations in order to find several pages.  Places can be accessed by walking, jumping, entering/exiting doors and collecting keys.</li><li>Slenderman is one of the several hazards of the game; the player is alerted to his presence by appearing via split-second cutscene.  Slenderman will then usually appear onscreen in the game.  If Matt continues facing him for a couple of seconds that will end the game, along with coming into contact with him and a grim reaper character if all pages are found.  Falling into pits, water and being impaled on spikes will also end the game.  There is also several multi-colored objects in the castle that, if Matt makes contact with one of them, will turn all onscreen platforms into water, which will end the game if Matt falls into them (especially if any of the areas have spikes underneath them).</li><li>Turning away from Slenderman for 1.5 seconds will cause him to disappear.</li><li>There are three ways to play: regular, turbo (with Matt, the grim reaper and the crawling Slenderman moving at a very fast pace), and starting a game where Matt is positioned at a different starting place.</li><li>Once the fifth page is collected, beware!  Slenderman will appear in a different, fast-moving form and could head straight for Matt.</li><li>Unlike how the game states, there are actually nine pages to be found in order to get to the end of the game.</li></ul><h4>Controls</h4><ul><li>At the title screen, use the z (normal play mode), x (turbo) or arrow keys (start game in different area) to start a new game.</li><li>Use the x key to view last page collected.</li><li>Use the z key to jump.</li><li>Use the arrow keys to move.</li><li>Use the up or down arrow keys to enter a door or below ground area.</li><li>Use the p or Enter key to pause the game.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=3828 Play game]
		


<hr style="height: 0.0625em;background-color: #888;" /><h2>Lander on Planet Cheese</h2>{{Game|title = Lander on Planet Cheese|imagecaption = Title screen shot|first = boomlinde|second = Action|third = One|image = Lander.jpg|imagewidth = 224}}<h4>Description</h4>You are stuck on planet cheese. You could slice your way out if only you had a slicer. Luckily you have a slicer detector...<h4>Rules</h4><ul><li>The game starts with the player's lander sitting on a surface.  They must guide the lander throughout the planet in order to find their slicer.</li><li>The slicer detector points in the direction of the player's cheese slicer.  Moving the lander in the direction of the slicer will bring the player closer to it.</li><li>Fuel is constantly being used once the lander is airborne; however, the player can land softly on any flat surface in order to refuel.</li><li>Colliding with any surface, running out of fuel, landing on a surface too hard or not landing directly on most surfaces (i. e. if a landing pad is not on a surface) will end the game.</li><li>The player wins the game by finding and making contact with the slicer.</li></ul><h4>Controls</h4><ul><li>At the title screen, press z or x to start a new game.</li><li>Use the x key to use the slicer detector.</li><li>Use the z key to thrust.</li><li>Use the arrow keys to turn your ship left and right.</li><li>Use the p or Enter key to pause the game.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=4020 Play game]
		


<hr style="height: 0.0625em;background-color: #888;" /><h2>BuzzKill</h2>{{Game|title = BuzzKill|imagecaption = Title screen shot|first = morningtoast|second = Shooter|third = One|image = Buzzkill.jpg|imagewidth = 224}}<h4>Description</h4>The player must clear out 10 levels’ worth of “bees, hives and honeycombs to advance [through] 10 levels” of gameplay while avoiding various dangers.<h4>Rules</h4><ul><li>Honeycombs appear overhead at the beginning of every level, which start releasing killer bees after a few seconds. They can only be removed once the player first freezes them with smoke from their blaster, then shoots them, although two power-ups, when caught, will also enable the player to remove them as well. When not destroyed quickly enough they can multiply.</li><li>Regular bees can be shot with fireballs and can be hindered by smoke.  Large bees (not as common) take many more hits to kill and they fire large shots at the player and at a larger volume than with regular bees and they, nor their shots are hindered by smoke.  The bee boss (which doesn’t appear until late in the game) takes many hits until it is destroyed, it fires the same kind of shots as large bees and it can produce honeycombs.</li><li>Nests start appearing after several levels and take many shots to bring down and they produce large bees.</li><li>Whenever the player uses a weapon, it takes up some of their power (represented by a bar at the bottom of the screen). The more power the player uses up, the more their ability to fire their weapons decreases, although the power bar will increase when the player doesn’t fire and when a certain power-up is collected.</li><li>Getting hit by a bee’s fire or a falling nest will cause the loss of a blaster and the game will end when there are no more blasters in reserve. An extra blaster is awarded at 200 bee kills, however.</li><li>There are several power-ups that appear during the game, being of Unlimited power, which the player’s firepower (fireballs and smoke usage) will not decrease for several seconds.  The    Freeze all honeycombs powerup freezes all onscreen honeycombs for several seconds, allowing them to be destroyed by fireballs, and a Honeycomb bomb causes one of the onscreen honeycombs to flash for several seconds, which shooting it will destroy it and several other surrounding honeycombs.</li><li>If all 10 levels of the game are beaten, an endless mode will be unlocked. Rather than following the screen order of the regular/Challenge mode of the game, the levels are randomized and there is no boss or end level, along with a separate high score for the mode.</li></ul><h4>Controls</h4><ul><li>At the title screen, press the x key to turn off music.</li><li>At the title screen, highlight the area to view several other options (read instructions, select Challenge or Endless mode [if applicable]) by the arrow keys and choose an option by pressing the z key.</li><li>At the title screen, press the z key once highlighted on the game of choice in order to play.</li><li>Use the left/right arrow keys to move the blaster.</li><li>Press the z key to shoot fireballs.</li><li>Press the x key to blow smoke.</li><li>Press the Enter or p key to pause the game.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=3877 Play game]
		


<hr style="height: 0.0625em;background-color: #888;" /><h2>194-8</h2>{{Game|title = 194-8|imagecaption = Title screen shot|first = LeDjinn|second = Shooter|third = One|image = 194-8.jpg|imagewidth = 224}}<h4>Description</h4>Scrolling shooter where the player controls a plane that must shoot down targets while avoiding them and/or their fire for as long as possible.<h4>Rules</h4><ul><li>Crafts move in certain patterns, initially traveling in either straight horizontal or vertical paths.  After defeating several bosses, other vehicles will also zig-zag.</li><li>Making contact with an enemy or one of its projectiles will cause the player to lose health (indicated by yellow hearts at the bottom right corner of the screen); once the player runs out of health the game will end.</li><li>The player has two weapons: a primary main gun and a secondary Lazor.  The main gun can have several shots onscreen at once but starts off weak; the Lazor is much stronger but needs to be strengthened via collecting power-ups in order to be used again.</li><li>Enemies initially take several hits to be destroyed, although they often release power-ups.  Once collected by the player, pink globes are used to build up the Lazor power (represented by a bar at the bottom left of the screen), whereas the less common yellow orbs will strengthen the player’s main gun, along with increasing the size of its projectiles.  It can also replenish the player’s health.</li><li>After the player reaches certain point thresholds they will find themselves in a boss battle, which fires many shots at once and takes many hits to be destroyed.  If the player is able to defeat it then they will continue the game at a higher difficulty level, as ground targets that fire appear on level 2 (which none of the enemy aircraft fires at the player during the first level), one type of airborne target fires and another moves in a zig-zagging pattern appears on level 3, etc.</li></ul><h4>Controls</h4><ul><li>At the title screen, press the x key to play game.</li><li>Use the arrow keys to move.</li><li>Use the x key to fire main guns.</li><li>Use the z key to shoot the Lazor (when available).</li><li>Press the Enter or p key to pause the game.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=2289 Play game]
	
				

<hr style="height: 0.0625em;background-color: #888;" /><h2>Astero</h2>{{Game|title = Astero|imagecaption = Title screen shot|first = Alex Morris (grumpus)|second = Shooter|third = One|image = Astero.jpg|imagewidth = 224}}<h4>Description</h4>Scrolling space shooter where the player must destroy as many ships as possible while avoiding their fire and collecting power-ups.<h4>Rules</h4><ul><li>Each enemy has a certain attack pattern and weapon, as Sentries travel straight down vertically but fire one shot to each side at about a 45 degree angle.  Wardens only fire one vertical shot at a time but they move diagonally.  Jackals quickly move horizontally while firing up to two Missiles that rapidly travel downwards and Alphas move slowly horizontally, but then stop and fire a powerful laser for a few seconds.</li><li>Occasionally a destroyed enemy will release a power-up, which includes a Fan, which will enable the player’s shots to fire in three directions: at about a 45 degree angle from each side and straight forward.  The Tri shot will enable the player’s ship to fire forward and left and right all at once.  The Double shot fires two shots at once and the Laser will fire a continuous powerful beam.  All power-ups only last a few seconds after being collected.</li><li>Colliding with any enemy ship or its weapon will cause the player to lose a ship and the game will end when there are no more remaining ships.  The player will also lose a power-up’s ability if they are in possession of one when they lose a ship.</li><li>The game will also end if the player beats all six levels.</li></ul><h4>Controls</h4><ul><li>At the title screen, press the x or z keys to play the game.</li><li>Use the arrow keys to move.</li><li>Use the z or x keys to fire.</li><li>Use the enter or p keys to pause the game and/or reset the cart.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=4119 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Pakutto BOY</h2>{{Game|title = Pakutto BOY|imagecaption = Title screen shot|first = Konimiru|second = Action|third = One|image = Pakutto.jpg|imagewidth = 224}}<h4>Description</h4>In this maze game, the player must eat all foods (while avoiding ghosts) in each round in order to advance to the next one.<h4>Rules</h4><ul><li>The food in each maze moves, which Pakutto BOY must chase after in order to consume.</li><li>Ghosts chase BOY and if one of them catches him then a life will be lost.  The game will end when there are no more BOYs left in reserve, although extra BOYs are awarded at 2000 and 5000 points.</li><li>With each new maze, life, and with each time BOY eats a piece of food, they will be able to briefly eat a ghost, which will take it out of play for several seconds.  After several rounds, however, the effect will become shorter until it does not even work at all after eating a piece of food.</li><li>Ghosts and/or food will speed up as more rounds are cleared.</li></ul><h4>Controls</h4><ul><li>At the title screen, press the x or z keys to play the game.</li><li>Use the arrow keys to move.</li><li>Use the enter or p keys to pause the game and/or reset the cart.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=27623 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Menuitem</h2>{{ApiReference
|name=menuitem
|shortdesc=Adds a custom item to the PICO-8 menu.
|index||The item index, a number between 1 and 5.
|label|optional|The label text of the menu item to add or change.
|callback|optional|A Lua function to call when the user selects this menu item.
}}
To remove a previously added item, call <code>menuitem(i)</code> where <code>i</code> is the index of the item to remove.<h4>Examples</h4><pre>
menuitem(1, "restart puzzle", function() reset_puzzle() sfx(10) end)

function display_hints()
  hint_shown = level_id
end
menuitem(2, "show hints", display_hints)
</pre><h4>See also</h4><ul><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>DrawState</h2>PICO-8 maintains a set of variables that affect how the drawing functions work. For example, it remembers the current "pen color," and when you call functions such as [[Circ|circ()]] or [[Print|print()]] without the optional color parameter, it uses the current pen color. The pen color is changed whenever you provide a color parameter to a draw function, and you can change it directly by calling the [[Color|color()]] function.

A typical use of the draw state is to use the same feature for a series of related consecutive draw calls. For example, to draw a the cockpit of a spaceship, the game can call [[Clip|clip()]] to set the clipping region for the window, call draw functions for the objects outside the window, then call [[Clip|clip()]] again to set the clipping region for the cockpit controls, and so on.

The following features are stored in the draw state and affect how graphics features work:{|
! Feature
! Description
! Changed by
|-
| Pen color
| The default color. Used by functions that accept an optional color argument when the argument is not provided or <code>nil</code>.
| [[Color|color()]]; providing a color argument to a drawing function
|-
| Camera position
| A position offset. Modifies the position of all functions that take position arguments (x, y).
| [[Camera|camera()]]
|-
| Print cursor position
| The default position for the next call to [[Print|print()]] without position arguments. Such a call advances the cursor's y position by 8 pixels. If the cursor advances below the bottom of the screen, the screen scrolls. The cursor's x position can only be changed by [[Cursor|cursor()]] and establishes a left margin.
| [[Cursor|cursor()]]; advanced by [[Print|print()]]
|-
| Clipping region
| Limits the drawable region to a portion of the screen. Subsequent calls to draw functions will not draw outside this area even if they extend beyond the edge.
| [[Clip|clip()]]
|-
| Palette modifications
| Filters drawing so that some colors are replaced with others. There are two palettes: one used when a drawing to the graphics buffer for a specific draw call (including [[Spr|spr()]]), and one used when copying the graphics buffer to the screen (for full-screen effects).
| [[Pal|pal()]], [[Palt|palt()]]
|-
| Fill pattern
| Specifies an alternate two-color pattern to use for some drawing functions. Both 4-bit colors can be specified in the low and high bits of the color value passed to the drawing function. Alternatively, the fill pattern can set one of its colors to transparent.
| [[Fillp|fillp()]]
|}The draw state is stored in the [[Memory|addressable memory region]] 0x5f00-0x5f3f. This is useful if you want to save and restore the current draw state by copying the memory region with [[Memcpy|memcpy()]].
<hr style="height: 0.0625em;background-color: #888;" /><h2>P8FileFormat</h2>PICO-8 can save cartridges in two file formats: the .p8 format, and the [[P8PNGFileFormat|.p8.png format]]. The [[Save|save]] command will use the format that corresponds to the filename extension.

The .p8 format is a text-based format that is suitable for using in external text editors and source control repositories (like GitHub). In particular, the Lua code for the cart is stored as plaintext near the top of the file, which makes it easy to use an external text editor as a replacement for PICO-8's built-in code editor without using a third-party tool.

Non-code sections (such as graphics) are stored as strings of hexadecimal characters representing bytes. The exact format differs for each section.

The sections appear in the following order: a header, the Lua code (<code>__lua__</code>), the spritesheet (<code>__gfx__</code>), the sprite flags (<code>__gff__</code>), the cartridge label (<code>__label__</code>), the map (<code>__map__</code>), sound effects (<code>__sfx__</code>), and music patterns (<code>__music__</code>). These sections are described in more detail below.

Except for the header and <code>__lua__</code> section, any section that is empty (is identical to the default cart) is omitted from the file. For each section, trailing lines that are identical to the default cart are also omitted. For example, if a cart's spritesheet only has sprites in the first row, lines representing subsequent rows are omitted from the <code>.p8</code> file. The default (empty) cart is just a header and an empty <code>__lua__</code> section.<h4>Header</h4>Every .p8 file begins with a two-line header:

<pre>
pico-8 cartridge // http://www.pico-8.com
version 8
</pre>

The <code>version</code> number has changed over multiple versions of PICO-8. However, the actual format of the file has not changed with every version increment.<h4>Lua</h4>The Lua section begins with the delimiter <code>__lua__</code> on a line by itself. Subsequent lines up to the next delimiter (<code>__gfx__</code>) contain the cart's Lua code as plaintext.

It is possible to use an external text editor to insert characters in the Lua code section that the built-in editor does not support. Uppercase ASCII letters appear as lowercase in the built-in editor, and are converted to lowercase if the cart is saved by PICO-8. Non-ASCII characters may not appear correctly in the built-in editor.

The built-in editor stores all letter characters as lowercase. Glyphs are stored as higher byte values. For example, shift-C in the built-in editor (cat glyph) is stored as the byte value 0x82 (not an ASCII uppercase A).<h4>Spritesheet</h4>The spritesheet section begins with the delimiter <code>__gfx__</code>.

The spritesheet is represented in the .p8 file as 128 lines of 128 hexadecimal digits. Each line is a pixel row, and each hexadecimal digit is a pixel color value, in pixel order.

This differs from the [[Memory|in-memory representation]] in that the 4-bit hexadecimal digits appear in pixel order in the .p8 file, while pairs are swapped (least significant nybble first) in memory. This allows you to identify and draw images using hex digits with a text editor, if you like.

A cart is allowed to use the bottommost 128 sprites as the bottommost 128x32 tiles of the map data. That is, if the cart calls [[Map|map()]] with coordinates in that region, the data is read from the bottom of the spritesheet, and the map editor can view this memory either way.

In the .p8 file, this data is always saved in the <code>__gfx__</code> section, even if the cart uses it as map data. Note that this is encoded as a linear series of 4-bit pixels, rather than a series of 8-bit bytes. Tools reading this section and converting to byte format should treat the first hex digit of each pair as the bottom 4 bits and the second digit as the top 4 bits.<h4>Sprite flags</h4>The sprite flags section begins with the delimiter <code>__gff__</code>.

Flags are represented in the .p8 file as 2 lines of 256 hexadecimal digits (128 bytes). Each pair of digits represents the 8 flags (most significant nybble first) for each of the 256 sprites, in sprite ID order.

In the graphics editor, the flags are arranged left to right
from LSB to MSB: red=1, orange=2, yellow=4, green=8, blue=16, purple=32,
pink=64, peach=128.<h4>Label</h4>If you have stored a screenshot for the cartridge label by pressing F7, the cart is saved with the screenshot. This is used as a cartridge "label" image when you save the cart as a <code>.p8.png</code> file. The label is remembered in this way if you load a <code>.p8.png</code> file and save it as a <code>.p8</code> file.

The format for the <code>__label__</code> data is identical to that of the spritesheet, representing a square of 128 x 128 16-color pixels.<h4>Map</h4>The map section begins with the delimiter <code>__map__</code>.

Map data is stored in the .p8 file as 32 lines of 256 hexadecimal digits (128 bytes). Each pair of digits (most significant nybble first) is the sprite ID for a tile on the map, ordered left to right, top to bottom, for the first 32 rows of the map.

The map area is 128 tiles wide by 64 tiles high. Map memory describes the top 32 rows. If the cart author draws tiles in the bottom 32 rows, this is stored in the bottom of the <code>__gfx__</code> section. (See above.)<h4>Sound effects</h4>The sound effects section begins with the delimiter <code>__sfx__</code>.

Sound data is stored in the .p8 file as 64 lines of 168 hexadecimal digits (84 bytes, most significant nybble first), one line per sound effect (0-63).

The byte values (hex digit pairs, MSB) are as follows:<ul><li>byte 0: The editor mode: 0 for pitch mode, 1 for note entry mode.</li><li>byte 1: The note duration, in multiples of 1/128 second.</li><li>byte 2: Loop range start, as a note number (0-63).</li><li>byte 3: Loop range end, as a note number (0-63).</li><li>bytes 4-84: 32 notes</li></ul>Each note is represented by 20 bits = 5 nybbles = 5 hex digits. (Two notes use five bytes.) The nybbles are:<ul><li>nybble 0-1: pitch (0-63): c-0 to d#-5, chromatic scale</li><li>nybble 2: waveform (0-F): 0 sine, 1 triangle, 2 sawtooth, 3 long square, 4 short square, 5 ringing, 6 noise, 7 ringing sine; 8-F are the custom waveforms corresponding to sound effects 0 through 7 (PICO-8 0.1.11 "version 11" and later)</li><li>nybble 3: volume (0-7)</li><li>nybble 4: effect (0-7): 0 none, 1 slide, 2 vibrato, 3 drop, 4 fade_in, 5 fade_out, 6 arp fast, 7 arp slow; arpeggio commands loop over groups of four notes at speed 2 (fast) and 4 (slow)</li></ul>Note that this is very different from the [[Memory|in-memory layout]] for sound data.<h4>Music patterns</h4>The sound effects section begins with the delimiter <code>__music__</code>.

Music patterns are represented in the .p8 file as 64 lines, one for each pattern. Each line consists of a hex-encoded flags byte (two digits), a space, and four hex-encoded one-byte (MSB-first) sound effect IDs.

The flags byte has three flags on the lower bits (the higher five bits are unused):<ul><li>0: begin pattern loop</li><li>1: end pattern loop</li><li>2: stop at end of pattern</li></ul>The sound effect ID is in the range 0-63. If a channel is silent for a song pattern, its number is 64 + the channel number (0x41, 0x42, 0x43, or 0x44).

Note that this is different from the [[Memory|in-memory layout]] for music data.

<hr style="height: 0.0625em;background-color: #888;" /><h2>P8PNGFileFormat</h2>PICO-8 can save cartridges in two file formats: the [[P8FileFormat|.p8 format]], and the .p8.png format. The [[Save|save]] command will use the format that corresponds to the filename extension.

The .p8.png format is a binary format based on the [https://en.wikipedia.org/wiki/Portable_Network_Graphics PNG image format]. A .p8.png file is an image that can be viewed in any image viewer (such as a web browser). The image appears as the picture of a game cartridge. PICO-8 generates this image using the most recent screenshot taken when pressing the F7 key while the cart is running. If the first two lines of Lua code are comments (a title and byline), it also puts the text of these comments on the label image.

The cart data is stored using a [https://en.wikipedia.org/wiki/Steganography stegonographic process]. Each PICO-8 byte is stored as the two least significant bits of each of the four color channels, ordered ARGB (E.g: the A channel stores the 2 most significant bits in the bytes). The image is 160 pixels wide and 205 pixels high, for a possible storage of 32,800 bytes. Of these, only the first 32,773 bytes are used.<h4>Graphics and sound</h4>Bytes 0x0000-0x42ff are the spritesheet, map, flags, music, and sound effects data. These are copied directly into memory when the cart runs. See [[Memory]] for a complete explanation of the order and format of this data.<h4>Lua code</h4>Bytes 0x4300-0x7fff are the Lua code. If the first four bytes (0x4300-0x4303) are <code>:c:</code> followed by a null (<code>\x00</code>), then the code is stored as compressed data. Otherwise the code is stored as plaintext (ASCII), up to the first null byte. PICO-8 compresses the code if it is larger than a certain threshold.

If compressed, the next two bytes after <code>:c:\x00</code> (0x4304-0x4305) are the length of the decompressed code, stored MSB first. This is followed by two null bytes (0x4306-0x4307). The remainder (0x4308-0x7fff) is the compressed data.

The decompression algorithm processes the compressed data one byte at a time, and performs an action based on the value, until the expected length of decompressed characters has been emitted:<ul><li>0x00: Copy the next byte directly to the output stream.</li><li>0x01-0x3b: Emit a character from a lookup table: newline, space, <code>0123456789abcdefghijklmnopqrstuvwxyz!#%(){}[]<>+=/*:;.,~_</code></li><li>0x3c-0xff: Calculate an offset and length from this byte and the next byte, then copy those bytes from what has already been emitted. In other words, go back "offset" characters in the output stream, copy "length" characters, then paste them to the end of the output stream. Offset and length are calculated as:</li></ul><pre>
offset = (current_byte - 0x3c) * 16 + (next_byte & 0xf)
length = (next_byte >> 4) + 2
</pre>Note that length can not be greater than offset. (Unlike typical length-offset encodings)<h4>Version ID</h4>Byte 0x8000 encodes a version ID. This appears to have changed over multiple versions of PICO-8, but the file format has not changed.

Bytes 0x8001-0x8004 appear to encode a minor version or build number, as a 32-bit integer with the most significant byte first. It first became non-zero partway through version 8, and increased ever since. (Example values are 67959 and 70776)<h4>References</h4><ul><li>For a Python library that can read files in this format, see [[Picotool]] ([https://github.com/dansanderson/picotool GitHub]).</li><li>Forum post by asterick describing the code compression format: http://www.lexaloffle.com/bbs/?tid=2400</li><li>[https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch Lempel–Ziv–Welch compression]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Corrupt Mode (corrupt pico-8 data)</h2>This is a code snippet from Jelpi (by zep) that can be used in any game to oft hilarious effect.<pre>for i=1,5 do
 poke(rnd(0x8000),rnd(0x100))
end</pre>Here is an alternate corruptor, using a different method.<pre>function _init()
 a=1
 b=1
 c=1
end
function _update()
 b=peek(a)
 a=a+c
 poke(a,b)
</pre><pre> if a < 0 then a = 1 end
 a=a+1
 srand(c)
 c=flr(rnd(30))
end</pre><hr style="height: 0.0625em;background-color: #888;" /><h2>Treasure Hunt Submarine</h2>{{Game|title = Treasure Hunt Submarine|imagecaption = Title/instructions screen shot|first = macop|second = Action|third = One|image = Treasurehunt.jpg|imagewidth = 224}}<h4>Description</h4>You're a submarine of a worn-out article.  When ballast isn't taken, you don't sink.  You'll collect all treasures!<h4>Rules</h4><ul><li>With the start of each new game/level, the player's submarine will automatically start floating to the top of the screen.</li><li>Collecting a ballast (at the top of the screen) by making contact with it will cause the player's submarine to sink.  Once a ballast is not needed any more, it can be dropped so the submarine can float upwards again.</li><li>Collect all treasures in order to advance to the next level.</li><li>Making contact with a mine or a row of spikes at the top or bottom of the screen will destroy the submarine and cause the game to end.</li></ul><h4>Controls</h4><ul><li>At the title screen, press the z key to play the game.</li><li>Use the arrow keys to move (left/right only).</li><li>Use the down arrow key to drop the ballast.</li><li>Use the enter or p keys to pause the game and/or reset the cart.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=27652 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Graphics</h2><h4>Base colors</h4>These are the colors the screen palette is set to when PICO-8 starts up:{| class="article-table" style="text-align:center;"
!style="text-align:center;"|Index
!style="text-align:center;"|Color
!style="text-align:center;"|Hex
!style="text-align:center;"|RGB
!style="text-align:center;"|Name
|-
|0
|style="background-color: #000000;"|
|<code>#000000</code>
|<code>0, 0, 0</code>
|black
|-
|1
|style="background-color: #1D2B53;"|
|<code>#1D2B53</code>
|<code>29, 43, 83</code>
|dark-blue
|-
|2
|style="background-color: #7E2553;"|
|<code>#7E2553</code>
|<code>126, 37, 83</code>
|dark-purple
|-
|3
|style="background-color: #008751;"|
|<code>#008751</code>
|<code>0, 135, 81</code>
|dark-green
|-
|4
|style="background-color: #AB5236;"|
|<code>#AB5236</code>
|<code>171, 82, 54</code>
|brown
|-
|5
|style="background-color: #5F574F;"|
|<code>#5F574F</code>
|<code>95, 87, 79</code>
|dark-grey
|-
|6
|style="background-color: #C2C3C7;"|
|<code>#C2C3C7</code>
|<code>194, 195, 199</code>
|light-grey
|-
|7
|style="background-color: #FFF1E8;"|
|<code>#FFF1E8</code>
|<code>255, 241, 232</code>
|white
|-
|8
|style="background-color: #FF004D;"|
|<code>#FF004D</code>
|<code>255, 0, 77</code>
|red
|-
|9
|style="background-color: #FFA300;"|
|<code>#FFA300</code>
|<code>255, 163, 0</code>
|orange
|-
|10
|style="background-color: #FFEC27;"|
|<code>#FFEC27</code>
|<code>255, 236, 39</code>
|yellow
|-
|11
|style="background-color: #00E436;"|
|<code>#00E436</code>
|<code>0, 228, 54</code>
|green
|-
|12
|style="background-color: #29ADFF;"|
|<code>#29ADFF</code>
|<code>41, 173, 255</code>
|blue
|-
|13
|style="background-color: #83769C;"|
|<code>#83769C</code>
|<code>131, 118, 156</code>
|lavender
|-
|14
|style="background-color: #FF77A8;"|
|<code>#FF77A8</code>
|<code>255, 119, 168</code>
|pink
|-
|15
|style="background-color: #FFCCAA;"|
|<code>#FFCCAA</code>
|<code>255, 204, 170</code>
|light-peach
|}Names from [https://www.romanzolotarev.com/pico-8-color-palette/ Roman Zolotarev's PICO-8 palette reference], except:<ul><li>"lavender" at index 13, as "indigo" is a darker, more saturated color, and also a somewhat different hue</li><li>"light-peach" at index 15, as "peach" seemed more appropriate in the additional color range below, which contains a dark peach color as well.</li></ul><h4>Additional colors available to be swapped in</h4>These colors are not documented, but zep has indicated that he is aware of the discovery and that he is allowing their use. Still, they remain undocumented, so it can't be assumed they will never change.

These colors may be swapped into the screen palette through <code>pal(index, color, 1)</code>.

Note that the screen is still made of 4-bit pixels, so the screen palette remains limited to 16 colors per frame. These additional colors provide more candidates for that palette, but not more slots to put them in.{| class="article-table" style="text-align:center;"
!style="text-align:center;"|Index
!style="text-align:center;"|Color
!style="text-align:center;"|Hex
!style="text-align:center;"|RGB
!style="text-align:center;"|Name
|-
|128
|style="background-color: #291814;"|
|<code>#291814</code>
|<code>41,24,20</code>
|darkest-grey
|-
|129
|style="background-color: #111D35;"|
|<code>#111D35</code>
|<code>17,29,53</code>
|darker-blue
|-
|130
|style="background-color: #422136;"|
|<code>#422136</code>
|<code>66,33,54</code>
|darker-purple
|-
|131
|style="background-color: #125359;"|
|<code>#125359</code>
|<code>18,83,89</code>
|blue-green
|-
|132
|style="background-color: #742F29;"|
|<code>#742F29</code>
|<code>116,47,41</code>
|dark-brown
|-
|133
|style="background-color: #49333B;"|
|<code>#49333B</code>
|<code>73,51,59</code>
|darker-grey
|-
|134
|style="background-color: #A28879;"|
|<code>#A28879</code>
|<code>162,136,121</code>
|medium-grey
|-
|135
|style="background-color: #F3EF7D;"|
|<code>#F3EF7D</code>
|<code>243,239,125</code>
|light-yellow
|-
|136
|style="background-color: #BE1250;"|
|<code>#BE1250</code>
|<code>190,18,80</code>
|dark-red
|-
|137
|style="background-color: #FF6C24;"|
|<code>#FF6C24</code>
|<code>255,108,36</code>
|dark-orange
|-
|138
|style="background-color: #A8E72E;"|
|<code>#A8E72E</code>
|<code>168,231,46</code>
|light-green
|-
|139
|style="background-color: #00B543;"|
|<code>#00B543</code>
|<code>0,181,67</code>
|medium-green
|-
|140
|style="background-color: #065AB5;"|
|<code>#065AB5</code>
|<code>6,90,181</code>
|medium-blue
|-
|141
|style="background-color: #754665;"|
|<code>#754665</code>
|<code>117,70,101</code>
|mauve
|-
|142
|style="background-color: #FF6E59;"|
|<code>#FF6E59</code>
|<code>255,110,89</code>
|dark peach
|-
|143
|style="background-color: #FF9D81;"|
|<code>#FF9D81</code>
|<code>255,157,129</code>
|peach
|}(Note that these colors were named arbitrarily at the time this section was created and are not official in any way. Those with a more artistic eye are invited to fine-tune them if they are off-base, but please try to keep in mind their connections to other parts of the palette, as has been done with the various grays, reds, greens, and blues. Knowing the exact name for a hue may not be as helpful to a reader as knowing where it can fit into a useful gradient.)

All other unlisted colors are currently black and should probably be treated as "reserved for future expansion", which is to say: do not use them.<h4>Functions</h4><ul><li>[[Camera|<nowiki>camera([x,] [y])</nowiki>]]</li><li>[[Circ|<nowiki>circ(x, y, r, [col])</nowiki>]]</li><li>[[Circfill|<nowiki>circfill(x, y, r, [col])</nowiki>]]</li><li>[[Clip|<nowiki>clip([x,] [y,] [w,] [h])</nowiki>]]</li><li>[[Cls|<nowiki>cls()</nowiki>]]</li><li>[[Color|<nowiki>color(col)</nowiki>]]</li><li>[[Cursor|<nowiki>cursor(x, y)</nowiki>]]</li><li>[[Fget|<nowiki>fget(n, [f])</nowiki>]]</li><li>[[Fillp|<nowiki>fillp([pat])</nowiki>]]</li><li>[[Fset|<nowiki>fset(n, [f,] [v])</nowiki>]]</li><li>[[Line|<nowiki>line(x0, y0, x1, y1, [col])</nowiki>]]</li><li>[[Pal|<nowiki>pal([c0,] [c1,] [p])</nowiki>]]</li><li>[[Palt|<nowiki>palt([c,] [t])</nowiki>]]</li><li>[[Pget|<nowiki>pget(x, y)</nowiki>]]</li><li>[[Print|<nowiki>print(str, [x,] [y,] [col])</nowiki>]]</li><li>[[Pset|<nowiki>pset(x, y, [c])</nowiki>]]</li><li>[[Rect|<nowiki>rect(x0, y0, x1, y1, [col])</nowiki>]]</li><li>[[Rectfill|<nowiki>rectfill(x0, y0, x1, y1, [col])</nowiki>]]</li><li>[[Sget|<nowiki>sget(x, y)</nowiki>]]</li><li>[[Spr|<nowiki>spr(n, x, y, [w,] [h,] [flip_x,] [flip_y])</nowiki>]]</li><li>[[Sset|<nowiki>sset(x, y, [c])</nowiki>]]</li><li>[[Sspr|<nowiki>sspr(sx, sy, sw, sh, dx, dy, [dw,] [dh,] [flip_x,] [flip_y])</nowiki>]]</li></ul>See also [[APIReference#Graphics|API Reference]].
<hr style="height: 0.0625em;background-color: #888;" /><h2>Drop Down</h2>{{Game|title = Drop Down|imagecaption = Title/instructions screen shot|first = senilo|second = Action|third = One|image = Dropdown.jpg|imagewidth = 224}}<h4>Description</h4>Help Klossen get home!  Collect groceries on the way!<h4>Rules</h4><ul><li>First, a skill level must be chosen: moving Klossen into the hole in the left platform will start the game on the kids level, whereas the right hole will start the game on the normal level.  The kids setting is short and at an easier pace whereas the normal setting has a longer course and speeds up.</li><li>The screen starts scrolling once the game starts; Klossen must be moved into holes in platforms as they move upwards.  If a platform pushes Klossen all the way up to the top of the screen then the game will end.</li><li>On the way down to his home are various food items that Klossen can collect in order to add to his groceries total at the end.</li></ul><h4>Controls</h4><ul><li>At the title screen, press either arrow key towards a level selector and drop down a hole in the platform to play the game.</li><li>Use the arrow keys to move (left/right and up to jump).</li><li>Use the enter or p keys to pause the game and/or reset the cart.</li><li>Use the z or x keys to play again at the end of a game.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=27976 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Tables</h2>Tables are the primary composite data structure in the [[Lua]] programming language.  They are used as containers, especially sequences (with consecutive numeric indexes starting from 1) and mappings (also known as associative arrays, dictionaries, or hashtables). Tables can be used as general purpose objects, and when combined with metatables (see [[Lua|Lua reference]]) can implement object-oriented concepts such as inheritance. PICO-8 includes several built-in functions for using tables.<h4>Mappings</h4>Fundamentally, tables are mappings of keys to values. Key-value pairs are unordered. You can construct a new mapping using curly brackets. For example:

<pre>
x = {a=1, b=2, c="hello"}
</pre>

Values can be accessed using bracket notation, where the key is an expression (<code>tbl["key"]</code>).

<pre>
print(x["a"])              -- 1

x["a"] = 99
print(x["a"])              -- 99
</pre>

If the key is a string using the characters of a Lua identifier (letters, numbers, underscore, and begins with a letter), then the value can also be accessed using property notation (<code>tbl.key</code>).

<pre>
print(x.b)                 -- 2

x.b = 88
print(x.b)                 -- 88
</pre>

Accessing an unset key returns <code>nil</code>.

<pre>
if x.d == nil then<pre> print("x.d is nil")</pre>end
</pre>

PICO-8 provides the built-in [[Pairs|pairs()]], which iterates over all key-value pairs in a table.

<pre>
for k,v in pairs(x) do<pre> print(k.." = "..v)</pre>end
</pre><h4>Sequences</h4>A sequence is a table with a contiguous series of numeric <span style="font-style:italic;">keys</span>, starting with 1, each of which has a non-nil <span style="font-style:italic;">value</span>. Lua offers special syntax and features so that sequences behave somewhat like lists or arrays in other languages.

<pre>
-- constructor syntax for sequences
p = {2, 3, 5, 7, 11}

print(p[1])             -- should print "2"
print(p[5])             -- should print "11"
if p[0] == nil then<pre> print("p[0] is nil")  -- should print "p[0] is nil"</pre>end

-- the sequence length operator
print(#p)               -- should print "5"

for i=1,#p do<pre> print("p["..i.."] = "..p[i])</pre>end
</pre>

No key in the middle of a sequence should ever be set/cleared to nil. Only <span style="font-style:italic;">contiguous keys at the end</span> of the sequence should be cleared, in reverse order. Setting the final key(s) to nil is okay, because Lua will understand that they are being removed, and it will therefore reduce the length by by that many. Similarly, setting the next key to something non-nil will extend the sequence by 1, and this should always be done in forward order.

<pre>
-- same sequence as last time
p = {2, 3, 5, 7, 11}

print(#p)               -- should print "5"

-- add three more elements to the sequence
p[#p+1]=13
p[#p+1]=17
p[#p+1]=19

print(#p)               -- should print "8"

-- shorten the sequence by 2
p[#p]=nil
p[#p]=nil

print(#p)               -- should print "6"
</pre>


Caution: If a key <span style="font-style:italic;">other</span> than the final key is set to nil, or a key other than the next after the sequence is set to non-nil, the result is undefined. In some cases, Lua will recognize the change and will adjust the sequence. However, in others, it will not. There seems to be no consistent behavior. To avoid this problem, <span style="font-weight:bold;">only make changes at the end of a sequence.</span>

Note that a table containing a sequence is <span style="font-style:italic;">also</span> allowed to have other keys. However, those keys are not considered part of the sequence. The sequence part only consists of all numbered keys starting from 1 ascending up to the last key with a non-nil value. The # operator will only count those keys, ignoring any others present.<h5>Built-ins for sequences</h5>PICO-8 provides several built-ins that operate on sequences:<ul><li>[[All|all()]], which iterates over elements in the sequence in a table.</li></ul><pre>tbl = {2, 3, 5, 7, 11}
for v in all(tbl) do
  print(v)
end</pre><ul><li>[[Add|add()]] appends a value to the end of a sequence.</li><li>[[Del|del()]] removes the first element of the sequence that equals a given value, shifting all remaining elements down by one index to keep the sequence intact.</li><li>[[Foreach|foreach()]] calls a given function for each element in the sequence, passing the element as the sole argument to the function.</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Math</h2>PICO-8 can do mathematical operations on numbers, including arithmetic and trigonometric functions. All operations use PICO-8's number value type, a 16-bit fixed point type with a range of -32768.0 to 32676.0.

To assist with common game graphics tasks, PICO-8's trigonometric functions use an input range of 0.0 to 1.0, which is equivalent to a range of 0 to 2 PI radians, or 0 to 360 degrees.

Increasing angle values go <span style="font-weight:bold;">clockwise</span> around the circle. Another way of thinking about this is that the result of [[Sin|sin()]] is inverted to match the orientation of the y-axis, with increasing y values going down the display. See [[Sin|sin()]] and [[Atan2|atan2()]] for further explanation.

For more information:<ul><li>[[APIReference#Math|The Math section of the API reference]]</li><li>[[Lua#Arithmetic_operators|Information of operators]]</li></ul><h4>Approximating log</h4>PICO-8 does not have a built-in logarithm function. You can create one based on a lookup table, adjusted for your desired level of accuracy. Here's a simple log-base-10 function:

<pre>
log10_table = {<pre>0, 0.3, 0.475,
0.6, 0.7, 0.775,
0.8375, 0.9, 0.95, 1</pre>}

function log10(n)<pre>if (n < 1) return nil
local t = 0
while n > 10 do
 n /= 10
 t += 1
end
return log10_table[flr(n)] + t</pre>end

for x=5,500,10 do<pre>printh('log10('..x..') = '..log10(x))</pre>end
</pre>

This function takes advantage of the facts that <code>log10(a * b) = log10(a) + log10(b)</code>, and <code>log10(10^t) = t</code>. It divides the value by 10 repeatedly until the value is between 1 and 10, keeping track of the number of divisions (<code>t</code>). It uses a lookup table to approximate the log of the value in this range, then adds in the log of the 10's.

You can change the base by replacing "10" with the new base wherever you see it, and changing the table with new approximations for the integers from 1 to 10.

You can get more accuracy by extending the table to 100 entries (log(1) to log(100)), and changing the while loop to <code>while n > 100</code>.

Keep in mind that the PICO-8 number type has a positive max of 32767, so that's your effective domain. log10(32767) is 4.51543..., so that's your range. You may want more digits of accuracy if you're doing a lot of work within that domain.<hr style="height: 0.0625em;background-color: #888;" /><h2>CoinAge</h2>{{Game|title = CoinAge|imagecaption = Title screen shot|first = Demondice|second = Action|third = One|image = Coinage.jpg|imagewidth = 224}}<h4>Description</h4>Collect as many coins as possible while avoiding enemies!<h4>Rules</h4><ul><li>The player must collect as many coins as possible.  Once a coin is collected, another one will instantly appear elsewhere in the maze.  Two coins appear onscreen maximum.</li><li>An enemy appears in the pen in the center of the screen; after several seconds, it will enter the maze.  After a while, another one will appear in the pen and also enter the maze until several enemies are onscreen at once.</li><li>Enemies will change their direction once they reach an opening in their path.</li><li>The player can utilize four escape tunnels that appear onscreen (two running vertically and two horizontally), warping them to the opposite end of a tunnel when entered.</li><li>If an enemy catches the player, they will lose a life and the difficulty level will start over (i. e. with only one enemy appearing in the pen).  Once all lives are lost the game will end.</li></ul><h4>Controls</h4><ul><li>At the title screen, press the x key to play the game.</li><li>Use the arrow keys to move.</li><li>Use the enter or p keys to pause the game and/or reset the cart.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=28429 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>SDL</h2>Simple DirectMedia Layer (SDL) is a low-level software library for accessing hardware useful to games. PICO-8 is implemented using SDL.

You can use any game controllers recognized by SDL with PICO-8. See [[Controllers]].

References:<ul><li>[[Controllers]]</li><li>The SDL website: https://www.libsdl.org/</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Controllers</h2>PICO-8 supports the use of game controllers that can be connected to a computer, either with a wired USB connection or a wireless Bluetooth connection. PICO-8's controller support is based on the [[SDL]] library.

A game can have up to 8 simultaneous players. Players 1 and 2 can use game controllers or corresponding keys on the keyboard. Players 3-8 must use game controllers.<h4>Keyboard controls</h4>While a game is playing, PICO-8 recognizes keyboard presses as controls for players 1 and 2. For example, player 1 can use the cursor keys, Z, and X for the six possible inputs.

For a complete list of default key mappings for players 1 and 2, see [[Btn|btn()]].

You can customize the key mappings for players 1 and 2 interactively using the [[Keyconfig|keyconfig]] command. You can also edit [[Configuration|config.txt]] directly.<h4>Configuring controllers</h4>You can configure controller mappings by editing the <code>sdl_controllers.txt</code> file in the PICO-8 [[Configuration|configuration]] directory. Each line of the file is a controller mapping in the format used by SDL. You only need one line for each kind of controller you wish to use.

Here is an example of a mapping line:

<pre>
79000000000000001100000000000000,Retrolink Classic Controller,x:b3,a:b2,b:b1,y:b0,back:b8,start:b9,leftshoulder:b4,rightshoulder:b5,leftx:a3,lefty:a4,platform:Mac OS X,
</pre>

You can generate this line using one of these tools:<ul><li>[http://www.generalarcade.com/gamepadtool/ General Arcade's GamepadTool] for Windows, Mac and Linux</li><li>The <code>controllermap</code> tool distributed with [https://www.libsdl.org/download-2.0.php SDL2]</li><li>Find your SDL2 controller mapping in [https://github.com/gabomdq/SDL_GameControllerDB/blob/master/gamecontrollerdb.txt this list].</li></ul>The complete procedure for using GamePadTool:<ol><li>Connect a controller to your computer.</li><li>Start GamePadTool. The tool should detect the controllers and allow you to select between them.</li><li>Make sure that the controller is selected, then click "Copy Mapping String." This copies the mapping string to your clipboard.</li><li>Edit the <code>sdl_controllers.txt</code> file in the PICO-8 [[Configuration|configuration]] directory. Paste the mapping string onto its own line, then save the file.</li><li>Start (or restart) PICO-8 to use the new configuration.</li></ol><h4>Connecting controllers</h4>PICO-8 assigns controllers to players in roughly the order they are detected when PICO-8 starts up.

By default, player 1 gets the first controller. You can change which player gets the first controller by providing the <code>-joystick</code> command line argument when starting PICO-8. Its value is a number from 0 to 7 (player 1 through 8). For example, to start assigning controllers with player 3:

<code>pico8 -joystick 2</code>

There is no way to assign specific controllers to specific players.

If you connect a controller while PICO-8 is running, you must restart PICO-8 before you can use it.<h4>Testing controllers</h4>Here is code for a simple cart that lets you test controllers for all players:

<pre>
function _update()
end
function _draw()<pre> cls()
 for p=0,8 do
   print(<span style="font-style:italic;">..p..':', 0, p*7, 1)
   for b=0,6 do
     if btn(b,p) then
       print(b, b*5 + 10, p*7, p+1)
     end
   end
 end</pre>end
</pre><h4>See also</h4><ul><li>[[Configuration]]</li><li>[[Keyconfig|keyconfig]]</li><li>[[SDL]]</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Dino Run</h2>{{Game|title = Dino Run|imagecaption = In-game shot|first = PixelCod|second = Action|third = One|image = Dinorun.jpg|imagewidth = 224}}<h4>Description</h4>Keep your dinosaur running for as long as possible!<h4>Rules</h4><ul><li>The player, in this endless runner, must jump over as many cacti as possible.</li><li>Once a game starts, the player's dinosaur will begin running.  They must jump over every cactus they encounter.</li><li>Coming into contact with a cactus will cause the game to end.</li></ul><h4>Controls</h4><ul><li>Use the z or arrow up key to jump.</li><li>Use the enter or p keys to pause the game and/or reset the cart.</li><li>Use the z or arrow up key to start a new game after the previous one ends.</li></ul><h4>Link</h4>[http://www.lexaloffle.com/bbs/?tid=28856 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Yet Another Multiple States System</h2><h4>Description</h4>This will give you an easy way to keep the code separate for your game's different states (such as menu screen, gameplay, and game over screen). It's easy to manage, easy to add to, and easy to understand again when you come back to your code months later and want to figure out what does what.

This is a different method of achieving the same result as the [[Multiple States System]] guide.<h4>Instructions</h4>The basic idea is that alongside the [[APIReference#The_game_loop|built-in _init(), _update(), and _draw() functions]], you create a different set of <span style="font-weight:bold;"><code>init()</code></span>, <span style="font-weight:bold;"><code>update()</code></span>, and <span style="font-weight:bold;"><code>draw()</code></span> functions for each state you need in your game. <span style="font-weight:normal;">This system relies on the useful fact that </span>[[Lua]]<span style="font-weight:normal;"> variables can hold function names.</span>

For this example, we'll start with the <span style="font-weight:bold;"><code>menu</code></span> state, and then add the <span style="font-weight:bold;"><code>game</code></span> state so you can see how easy it is to add new states. To create your game's <span style="font-weight:bold;"><code>menu</code></span> state, write the following:
<pre>
function _init()
 menu_init()
end

function _update()
 update()
end

function _draw()
 draw()
end


function menu_init()
 update=menu_update
 draw=menu_draw
end

function menu_update()
end

function menu_draw()
end
</pre><h5>Adding Another State</h5>Now if you want to add a game state, you just add the following three functions:
<pre>
function game_init()
 update=game_update
 draw=game_draw
end

function game_update()
end

function game_draw()
end
</pre><h5>Switching States</h5>To switch to the <span style="font-weight:bold;"><code>game</code></span> state, all you need to do is call <span style="font-weight:bold;"><code>game_init()</code></span>. For example, the menu's <span style="font-weight:bold;"><code>menu_update()</code></span> function might look like this:
<pre>
function menu_update()
 if (btn(4)) game_init()
end
</pre>
When the game is over, you could just call <span style="font-weight:bold;"><code>menu_init()</code></span> to go back to the menu.<h4>Further Tweaks</h4>Since you won't ever be doing much with the built-in game loop functions, you can optionally condense them down into the following 3 lines of code:
<pre>
 function _init() menu_init() end
 function _update() update() end
 function _draw() draw() end
</pre>
(This just takes up less space in the editor. It doesn't actually do anything different)
<hr style="height: 0.0625em;background-color: #888;" /><h2>Clamp Function</h2>#redirect [[Mid]]<hr style="height: 0.0625em;background-color: #888;" /><h2>GettingStarted</h2>(I intended to put a full PICO-8 starter tutorial here. Until I or someone else does, here are links to some resources to get started.)<h4>Resources</h4>Dylan Bennett's [https://www.lexaloffle.com/bbs/?tid=30072 Game Development with PICO-8] is a zine. The first issue introduces the major topics and walks through some examples.

The [[Pico8Zine|PICO-8 Zine]] is a collection of articles and tutorials on PICO-8 subjects, written by multiple authors and edited by Arnaud DeBock. Most articles are intended for beginners.

Some people have made video tutorials and uploaded them to YouTube:<ul><li>[https://www.youtube.com/playlist?list=PLjZAika8vyZkyOjoCp0EbHeIFZ8MLlhvg Matt Tuttle's PICO-8 Tutorials]</li><li>[https://www.youtube.com/playlist?list=PLYND9uft5u_1YCkmXiMrPU7tiBG3hIKAZ TeamWorkCast's PICO-8 Hero]</li><li>[https://www.youtube.com/playlist?list=PLur95ujyAigsqZR1aNTrVGAvXD7EqywdS Gruber's PICO-8 Music Tutorials]</li></ul><h4>Books</h4>Tassilo Rau's [https://tassilo.itch.io/howtomakegames How to Make Games With PICO-8] was being worked on, and users could pre-order the book and get early access to drafts.

The [https://itch.io/t/234991/important-update-on-the-book project stopped being updated during 2018 because of family health issues], and unrelated to that [https://twitter.com/BumblebeeGames/status/1195011390303621120 the author passed away unexpectedly late 2019].<hr style="height: 0.0625em;background-color: #888;" /><h2>Another World: SURVIVAL</h2>{{Game|title = Another World: SURVIVAL|imagecaption = Title screen shot|first = Liquidream|second = Action|third = One|image = Anotherworld.jpg|imagewidth = 224}}<h4>Description</h4>Imagine the game Another World, but with endless waves of enemies to fight!<h4>Rules</h4><ul><li>On the first Wave, the player, controlling Lester Knight Chaykin, must avoid tentacles from a submerged creature nearby and kill leech-like creatures by kicking them.  Killing a certain number of creatures will end the Wave and take Chaykin to the next one.</li><li>Having a tentacle grab Chaykin or a leech creature make contact with him will kill Chaykin and the Wave will restart.</li><li>Wave 2 is identical to Wave 1, but with the addition of creatures crawling along a cavern ceiling, which they can drop down on Chaykin and kill him if allowed.  Again, killing a certain number of creatures will end the Wave and take Chaykin to the next one.</li><li>Starting with Wave 3, Chaykin becomes armed with a gun and he encounters a bunch of alien soldiers. He can shoot the soldiers, along with defending himself via creating forcefields with the gun. Creating a super shot with the gun will destroy a soldier’s force field. Killing a certain number of soldiers will start the next Wave.</li><li>If Chaykin gets shot then the Wave starts over.</li><li>Starting from Wave 4 and onwards, Chaykin will advance to the next Wave after killing leech creatures and soldiers, but coming into contact with either (or a soldier’s gun blast) will cause the Wave to restart.</li></ul><h4>Controls</h4><ul><li>At the title screen, press the z key to play the game.</li><li>Use the arrow keys to move (left/right to move and down to crouch).</li><li>To kick, press the z key.</li><li>To fire the pistol (Wave 3 and onwards), press the x key.</li><li>To create a force field, press and hold the x key briefly, then release it.</li><li>To create a super shot, hold the x key for several seconds, then release it.</li><li>Use the enter or p keys to pause the game and/or reset the cart.</li></ul><h4>Link</h4>[https://www.lexaloffle.com/bbs/?tid=29909 Play game]


		


<hr style="height: 0.0625em;background-color: #888;" /><h2>GPIO</h2>The PICO-8 builds for [[Raspberry Pi]] and [[PocketChip]] include support for reading and writing to the [https://en.wikipedia.org/wiki/General-purpose_input/output GPIO pins] on those devices (added in v0.1.9). You can also use the GPIO interface from read/write to JavaScript in web exports of PICO-8 carts (added in v0.1.7).<h4>API</h4>To access the GPIO pins, [[peek]] or [[poke]] to bytes<pre>0x5f80..0x5fff</pre>in [[memory]]. PICO-8 will automatically set a pin to read mode when you peek the memory address or write mode when you poke to the address.

In the web exports, you may use arbitrary bytes in these memory locations to be read from and written to by JavaScript code. To access it, you have to declare a new array, as following:
<pre>
var pico8_gpio = new Array(128);
</pre>
You can then write to the bytes like so :
<pre>
pico8_gpio[0] = 10;
</pre>
This allows JavaScript to communicate with PICO-8.

In the hardware implementations, the GPIO pins act digitally, with 0 representing 0 and 255 representing 1. Also, hardware implementations may not support all 128 pins. Raspberry Pi, for instance, reportedly only supports the first 8 pins.<h4>Raspberry Pi Setup</h4><h5>Raspberry Pi B+</h5>On a Raspberry Pi B+ model, no additional setup was necessary (using v0.1.10). Run the <span style="font-style:italic;">pico8</span> binary via<pre>sudo ./pico8</pre>to enable access to the GPIO pins. If you do not use sudo to run PICO-8, the program will crash with a WiringPi error when your cart tries to access the GPIO memory space.<h5>Raspberry Pi 2 and newer models</h5>On newer Raspberry Pi models, the version of WiringPi included in the statically-linked <span style="font-style:italic;">pico8</span> binary.* Instead, you will have to build and install SDL 2.0.5 from source as well as a more recent version of WiringPi. Then, use the <span style="font-style:italic;">pico8_dyn</span> binary to run PICO-8.

<span style="font-style:italic;">*Is it included? Is it not included? What is the issue here? Would appreciate someone with a Raspi 2 or newer clarifying what this means in less broken English. Feel free to delete this when done.</span><h5>Older models</h5>On older models of the Raspberry Pi than the B+ model, GPIO may not work at all with PICO-8.<h4>PocketChip Setup</h4>TODO: document experience using PocketChip with PICO-8. Example: I think we had to install a newer (unofficial?) version of PICO-8 using the Debian package manager.
<hr style="height: 0.0625em;background-color: #888;" /><h2>Getmetatable</h2>{{ApiReference
|name=getmetatable
|shortdesc=Gets the metatable for a table.
|tbl||The table.
}}
Returns the table's metatable.<h4>Examples</h4>Based on the <code>pixel</code> class example in [[Setmetatable|setmetatable]]:

<pre>
p1 = pixel:new()
p1class = getmetatable(p1)
</pre><h4>See also</h4><ul><li>[[Setmetatable|<code>setmetatable()</code>]]</li><li>[[Metatables]]</li><li>[[Tables]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Tonum</h2>{{ApiReference
|name=tonum
|shortdesc=Converts a string representation of a decimal, hexadecimal, or binary number to a number value.
|str||The string.
}}
Returns the number, or no value (effectively <code>nil</code>) if the string does not represent a number.

The <code>tonum()</code> function accepts string representations of all numbers within the PICO-8 number range (<code>-32768.0</code> to <code>32767.0</code>). If the string represents a number outside of this range, it returns <code>-32768</code>.

(As of PICO-8 v0.1.11d, <code>tonum('xyz')</code> reports that the string can't be parsed as a number by returning "no value." In Lua, this is technically distinct from returning <code>nil</code>, though it is coerced to <code>nil</code> when used in an assignment or comparison.)<h4>Examples</h4><pre>
x = tonum('12345')      -- 12345
x = tonum('-12345.67')  -- -12345.67

x = tonum('0x0f')       -- 15
x = tonum('0x0f.abc')   -- 15.6709
x = tonum('0b1001')     -- 9

x = tonum('32767')      -- 32767
x = tonum('99999')      -- -32768
x = tonum('xyz')        -- nil
</pre><h4>See also</h4><ul><li>[[Tostr|<code>tostr()</code>]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Tostr</h2>{{ApiReference
|name=tostr
|shortdesc=Converts a non-string value to a string representation.
|val||The value to convert.
|usehex|optional|If true, uses 32-bit unsigned fixed point hexadecimal notation for number values. The default is to use concise decimal notation for number values.
}}
Returns the string representation of the value.

Given a number value, <code>tostr()</code> returns a string of the signed decimal representation of the number. If you set the optional second parameter to <code>true</code>, it will return an unsigned fixed point hexadecimal representation. (Use [[Sub|sub()]] on the result if you only want a portion of this string.)

Given a non-number value type, <code>tostr()</code> attempts to return something useful. Passing in a Boolean returns <code>'true'</code> or <code>'false'</code>. Passing in a string returns the string. <code>nil</code>, tables, and functions return <code><nowiki>[nil]</nowiki></code>, <code><nowiki>[table]</nowiki></code>, and <code><nowiki>[function]</nowiki></code>, respectively.

This is especially useful when concatenating values into string messages. The string concatenation operator (<code>..</code>) only accepts a string or a number on the right-hand side. A value of any other type must be converted to a string with <code>tostr()</code> before being concatenated to a string.<h4>Examples</h4><pre>
s = 'v: '..tostr(12345)            -- 'v: 12345'
s = 'v: '..tostr(-12345.67)        -- 'v: -12345.67'

s = 'v: '..tostr(0x0f)             -- 'v: 15'
s = 'v: '..tostr(0x0f, true)       -- 'v: 0x000f.0000'
s = 'v: '..tostr(-12345.67, true)  -- 'v: 0xcfc6.547b'

s = 'v: '..sub(tostr(0x0f, 3, 6))  == 'v: 000f'

-- runtime error: attempt to concatenate a boolean value
s = 'v: '..true                    

s = 'v: '..tostr(true)             -- 'v: true'
s = 'v: '..tostr('my string')      -- 'v: my string'

s = 'v: '..tostr(nil)              -- 'v: [nil]'
s = 'v: '..tostr({1, 2, 3})        -- 'v: [table]'

f = function() print('hi') end
s = 'v: '..tostr(f)                -- 'v: [function]'

-- f is a function that does not return a value
f = function() return end
a = 'v: '..tostr(f())              -- 'v: [no value]'
</pre><h4>See also</h4><ul><li>[[Tonum|tonum]]</li><li>[[Math]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Extcmd</h2>{{ApiReference
|name=extcmd
|shortdesc=Executes an administrative command from within a program.
|cmd||The command name, as a string.
}}
The command can be one of the following:<ul><li><code>'label'</code>: Sets the cart label to the current screen.</li><li><code>'screen'</code>: Saves a screenshot.</li><li><code>'rec'</code>: Sets the video recording start point.</li><li><code>'video'</code>: Saves an animated GIF to the desktop.</li><li><code>'audio_rec'</code>: Starts audio recording.</li><li><code>'audio_end'</code>: Ends audio recording and saves to the desktop.</li><li><code>'pause'</code>: Activates the pause menu, as if the player pressed the pause button.</li><li><code>'reset'</code>: Resets the currently running cart, as if the player pressed the reset key sequence (Control-R or Command-R).</li><li><code>'breadcrumb'</code>: After a cart uses [[Load|load()]] with the breadcrumb parameter to load another cart, loads the original cart, as if the player selected the breadcrumb menu item.</li><li><code>'shutdown'</code>: Exits the program if used in an exported binary.</li></ul>These commands are normally available in PICO-8 when you press function keys during cart execution. <code>extcmd()</code> lets you perform these at precise moments that may be difficult to capture by pressing keys, or when running in non-interactive "headless" mode (the <code>-x</code> command line flag).<h4>Examples</h4><pre>
extcmd('screen')
</pre><h4>See also</h4><ul><li>[[RunningPico8|Running Pico-8]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Fillp</h2>{{ApiReference
|name=fillp
|shortdesc=Sets the fill pattern.
|pat|optional|A bitfield representing the fill pattern to use.
}}
The fill pattern is part of the [[DrawState|draw state]]. It affects [[Circ|circ()]], [[Circfill|circfill()]], [[Rect|rect()]], [[Rectfill|rectfill()]], [[Pset|pset()]], and [[Line|line()]].

The pattern is a bitfield, a single number that represents a 4x4 pixel pattern. These are the bit values for each pixel in the pattern, in both decimal and hex:

<div align=center>{| class="wikitable" style="text-align: right; display: inline-table;"
 |&#8199;32768
 |&#8199;16384
 |&#8199;&#8199;8192
 |&#8199;&#8199;4096
 |-
 |2048
 |1024
 |512
 |256
 |-
 |128
 |64
 |32
 |16
 |-
 |8
 |4
 |2
 |1
 |}{| class="wikitable" style="text-align: right; display: inline-table;"
 |0x8000
 |0x4000
 |0x2000
 |0x1000
 |-
 |0x0800
 |0x0400
 |0x0200
 |0x0100
 |-
 |0x0080
 |0x0040
 |0x0020
 |0x0010
 |-
 |0x0008
 |0x0004
 |0x0002
 |0x0001
 |}</div>

The easiest way to represent this pattern in source code is as a binary number literal:

<pre>
fillp(0b0011001111001100)

-- A checkerboard pattern:
--     0011
--     0011
--     1100
--     1100
</pre>

The default pattern is a solid fill (0b0000000000000000). You can reset the pattern by calling <code>fillp()</code> with no arguments.

The color parameter to the drawing functions (such as [[Circfill|circfill()]]) can set two colors, to be used for the on bits (1's) and off bits (0's) of the pattern. The four lower bits of the color value are the "on" color, and the higher bits are the "off" color. For example, to draw the on bits as light blue (12, or <code>0xc</code>) and the off bits as dark blue (1), set the color to <code>0x1c</code> (28).

<pre>
fillp(0b0011001111001100) -- or 0x33cc.8
circfill(60, 60, 10, 0x1c)
</pre>

Alternatively, you can set the pattern to make the off bits transparent (showing what is drawn underneath). To do this, add <code>0b0.1</code>, or <code>0x0.8</code> if using hex, to the pattern value:

<pre>
rectfill(0, 0, 127, 127, 3)
fillp(0b0011001111001100.1) -- or 0x33cc.8
circfill(60, 60, 10, 0xc)
</pre><h4>Technical notes</h4>The current fill pattern is [[Memory|memory-mapped]] and may be read or written directly:<ul><li>0x5f31: pattern lo byte</li><li>0x5f32: pattern hi byte</li><li>0x5f33: transparency bit, 1=transparent, 0=opaque</li></ul><h4>Examples</h4><pre>
cls()
fillp()
rectfill(0,0,127,127,1)
fillp(0b0011001111001100)
circfill(40, 40, 10, 8)
fillp()
circ(40, 40, 10, 7)

circfill(80, 80, 10, 6)
fillp(0b0011001111001100.1)
circfill(80, 80, 10, 8)
fillp()
circ(80, 80, 10, 7)
 
fillp(0b0011011011000110)
rectfill(20, 100, 108, 120, 0xe8)

-- get the current fill pattern from its memory-mapped addresses
pattern=peek2(0x5f31)+peek(0x5f33)/2
</pre>
[[File:PICO-8 002.png|thumb|220x220px]]<h4>See also</h4><ul><li>[[DrawState]]</li><li>[[Circ|<code>circ()</code>]]</li><li>[[Circfill|<code>circfill()</code>]]</li><li>[[Rect|<code>rect()</code>]]</li><li>[[Rectfill|<code>rectfill()</code>]]</li><li>[[Pset|<code>pset()</code>]]</li><li>[[Line|<code>line()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>T</h2>#redirect [[Time]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Lshr</h2>{{ApiReference
|name=lshr
|shortdesc=Shifts the bits of a number to the right, using logical shift.
|num||The number.
|bits||The number of bits to shift.
}}
The <code>lshr()</code> function takes a number and a bit count, and returns the result of shifting the bits of the number to the right by that count. This uses a "logical shift."

Numbers in PICO-8 are stored using a 32-bit <span style="font-style:italic;">fixed point</span> format, with 16 bits for the integer portion, 16 bits for the fractional portion, and a twos complement representation for negative and positive values. Bit shifting uses the entire number representation. (See examples below.)

<code>lshr()</code> performs a "logical shift," which shifts all of the raw bits of the number, filling the highest bits with zeroes. The alternative to logical shift is "arithmetic shift." See [[Shr|shr()]].<h4>Examples</h4><pre>
-- 8 = 0b00001000 binary
-- 1 = 0b00000001 binary
print(lshr(8, 3))  -- 1

-- 1.000 = 0b0001.0000 binary
-- 0.125 = 0b0000.0010 binary
print(lshr(1, 3))  -- 0.125

--   -1.000 = 0b1111111111111111.0 binary (two's complement)
-- 8191.875 = 0b0001111111111111.111 binary
print(lshr(-1,3))  -- 8191.875
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rotl</h2>{{ApiReference
|name=rotl
|shortdesc=Rotates the bits of a number to the left.
|num||The number.
|bits||The number of bits to rotate.
}}
The <code>rotl()</code> function takes a number and a bit count, and returns the result of rotating the bits of the number to the left by that count.

Numbers in PICO-8 are stored using a 32-bit <span style="font-style:italic;">fixed point</span> format, with 16 bits for the integer portion, 16 bits for the fractional portion, and a two's complement representation for negative and positive values. Bit rotating uses the entire number representation. (See examples below.)

See [[Rotr|rotr()]] to rotate bits to the right.<h4>Examples</h4><pre>
--  8 = 0b00001000 binary
-- 64 = 0b01000000 binary
print(rotl(8, 3))  -- 64

-- 0.125 = 0b0000.0010 binary
-- 1.000 = 0b0001.0000 binary
print(rotl(0.125, 3))  -- 1

-- -4096.0000 = 0b1111000000000000.0000000000000000 binary (two's complement)
--                     rotate <-- by 12 bits
--     0.0586 = 0b0000000000000000.0000111100000000 binary
print(rotl(-4096,12))  -- 0.0586
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Rotr|<code>rotr()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rotr</h2>{{ApiReference
|name=rotr
|shortdesc=Rotates the bits of a number to the right.
|num||The number.
|bits||The number of bits to rotate.
}}
The <code>rotr()</code> function takes a number and a bit count, and returns the result of rotating the bits of the number to the right by that count.

Numbers in PICO-8 are stored using a 32-bit <span style="font-style:italic;">fixed point</span> format, with 16 bits for the integer portion, 16 bits for the fractional portion, and a two's complement representation for negative and positive values. Bit rotating uses the entire number representation. (See examples below.)

See [[Rotl|rotl()]] to rotate bits to the left.<h4>Examples</h4><pre>
-- 64 = 0b01000000 binary
--  8 = 0b00001000 binary
print(rotr(64, 3))  -- 8

-- 1.000 = 0b0001.0000 binary
-- 0.125 = 0b0000.0010 binary
print(rotr(1, 3))  -- 0.125

-- -4096.0000 = 0b1111000000000000.0000000000000000 binary (two's complement)
--                     rotate --> by 12 bits
--    15.0000 = 0b0000000000001111.0000000000000000 binary (two's complement)
print(rotr(-4096,12))  -- 15

-- (when printing fractional numbers, pico-8 rounds the decimal
-- representation to four decimal places. the largest fractional
-- portion is about 0.9999847... in decimal, so pico-8 prints it 
-- as "1".)
-- approx 1 = 0b0000000000000000.1111111111111111 binary (two's complement)
-- -15.9998 = 0b1111111111110000.0000000000001111 binary (two's complement)
print(rotr(0b0.1111111111111111, 12)  -- -15.9998
</pre><h4>See also</h4><ul><li>[[Math]]</li><li>[[Band|<code>band()</code>]]</li><li>[[Bor|<code>bor()</code>]]</li><li>[[Bxor|<code>bxor()</code>]]</li><li>[[Bnot|<code>bnot()</code>]]</li><li>[[Shl|<code>shl()</code>]]</li><li>[[Shr|<code>shr()</code>]]</li><li>[[Lshr|<code>lshr()</code>]]</li><li>[[Rotl|<code>rotl()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Peek4</h2>{{ApiReference
|name=peek4
|shortdesc=Reads a 32-bit value from four consecutive memory locations.
|addr||The address of the first memory location.
}}
The <code>peek4()</code> function reads a 32-bit value from four consecutive bytes in the addressable memory region (0x000-0x7fff). The value is interpreted in the [https://en.wikipedia.org/wiki/Endianness Little Endian] representation, which stores the lowest 8 bits in the first byte.

See [[Memory]] for information about the memory layout.<h4>Examples</h4><pre>
poke(0x4300, 0x00)
poke(0x4301, 0xc0)
poke(0x4302, 0xff)
poke(0x4303, 0x0f)

b = peek4(0x4300)  -- 0x0fff.c000 = 4095.75
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Poke4|<code>poke4()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Poke4</h2>{{ApiReference
|name=poke4
|shortdesc=Writes a 32-bit value to four consecutive memory locations.
|addr||The address of the first memory location.
|val||The 32-bit value.
}}
The <code>poke4()</code> function writes a 32-bit value to four consecutive bytes in the addressable memory region (0x000-0x7fff). The value is interpreted in the [https://en.wikipedia.org/wiki/Endianness Little Endian] representation, which stores the lowest 8 bits in the first byte.

See [[Memory]] for information about the memory layout.<h4>Examples</h4><pre>
poke4(0x4300, 0x0fff.c000)

b0 = peek(0x4300)  -- 0x00
b1 = peek(0x4301)  -- 0xc0
b2 = peek(0x4302)  -- 0xff
b3 = peek(0x4303)  -- 0x0f
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Peek4|<code>peek4()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>NULL</h2>{{Game|title = NULL|imagecaption = Title screen shot|first = Jusiv|second = Adventure|third = One|image = Null.jpg|imagewidth = 224}}<h4>Description</h4>A "surreal adventure game" (along with being a puzzle game) comprised of five areas. Each area has a different, unspecified goal that must be accomplished before the player can be transported to the next area.<h4>Rules</h4><ul><li>Wander around each area.  Try to find and read all newspapers.</li><li>A black creature can be triggered in every area.  Interact with it every single time in order to see a different ending (along with reading all newspapers).</li><li>In the first area (The Station), locate and activate several switches to unlock more places in the level.  Find the ticket and board a train to be transported to the next area.</li><li>In The Open (the next area), there are clues to follow to be teleported to The Rift.</li><li>In The Rift, you must make it to the next teleport at the end of the playfield.  Correct timing is needed in order to avoid several traps that will transport you back to the beginning of the area.</li><li>In The Grove, you must activate several areas by standing on them for several seconds each in order to be transported to The Remains.</li><li>In The Remains, you must collect all blue blobs in the area, which will open a door in a building at the top middle area of the level, which will end the game once you enter the building.</li></ul><h4>Controls</h4><ul><li>At the title screen, press z or x to start the game.</li><li>Use the arrow keys to move.</li><li>Use the x, z or c keys to interact with various items/read newspapers and to speed up onscreen dialog.</li><li>Use the enter or p key to pause the game or reset the cart.</li></ul><h4>Links</h4>[https://www.lexaloffle.com/bbs/?tid=30504 Play game]



<hr style="height: 0.0625em;background-color: #888;" /><h2>Battlebone</h2>{{Game|title = Battlebone|imagecaption = Title screen shot|first = beepyeah|second = Action|third = One|image = Battlebone.jpg|imagewidth = 224}}<h4>Description</h4>You are stuck in a dank chamber. Survive as long as you can against the skeleton hordes.<h4>Rules</h4><ul><li>One or more skeletons will instantly appear at the beginning of a game.  Their location can be seen on the radar display at the top left area of the screen.</li><li>Each skeleton takes three hits from the player’s sword in order to be destroyed.  One or more skeletons will instantly take a defeated skeleton’s place, however.</li><li>Skeletons can inflict damage on the player which is tracked via the bar at the top center of the screen.  Once the bar is totally depleted the game ends.  However, the player can earn points and regain a bit of health by touching the giant gold doubloons on the playfield (shown on the radar).</li></ul><h4>Controls</h4><ul><li>At the title screen, press z, c or x to start the game.</li><li>Use the arrow keys to move.</li><li>Use the x or z keys to stab.</li><li>Use the enter or p key to pause the game and/or reset the cart.</li></ul><h4>Links</h4>[https://www.lexaloffle.com/bbs/?tid=30594 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>Ceil</h2>{{ApiReference
|name=ceil
|shortdesc=Returns the next highest integer (the "ceiling") of a number.
|num||The number.
}}
If the given number is a fractional value between integers, the next highest integer is returned.

If the given number is an integer already, it is returned as-is.<h4>Examples</h4><pre>
print(ceil(5.9))   -- 6

print(ceil(-5.2))  -- -5

print(ceil(7))     -- 7

print(ceil(-7))    -- -7
</pre><h4>See also</h4><ul><li>[[Flr|<code>flr()</code>]]</li></ul><ul><li>[[Math]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Clamp</h2>#redirect [[Mid]]
<hr style="height: 0.0625em;background-color: #888;" /><h2>User blog:Felice Enellen/Hey kid, you want a toy?</h2>What scrolls down screens, delivers the memes,<br />
Turns into a browsing slog?<br />
What do spammers attack, attempting to hack?<br />
It's Blog, Blog, Blog!

It's Blog, Blog, it's short, it's boring, it's terse!<br />
It's Blog, Blog, it isn't just bad, it's worse!<br />
Nobody wants a Blog! You're gonna hate it, Blog!<br />
Why would you write a Blog? Nobody needs a Blog!

<span style="font-style:italic;">...Blog, from Llammo!</span>
<hr style="height: 0.0625em;background-color: #888;" /><h2>User blog:Felice Enellen</h2><hr style="height: 0.0625em;background-color: #888;" /><h2>Update60</h2>#redirect [[Update]]
<hr style="height: 0.0625em;background-color: #888;" /><h2>Counting Bytes</h2><h4>Terminology</h4>Computers like to count in binary, but humans like to count in decimal.

To deal with this painful disagreement, we've taken a few binary numbers that are very close to decimal numbers and we've given them names that correspond to the similar decimal numbers:{| align="center"
!colspan="2"|Number
!Word<br />Prefix
!Unit<br />Prefix
!Type
|-
|style="text-align:right;"|1&thinsp;000
|style="text-align:center;"|(or 10<sup>3</sup>)
|style="text-align:right;"|''kilo-''
|style="text-align:right;"|K-
|Decimal

|-
|style="text-align:right;"|1&thinsp;024
|style="text-align:center;"|(or 2<sup>10</sup>)
|style="text-align:right;"|''kibi-''
|style="text-align:right;"|Ki-
|Binary

|-
|style="text-align:right;"|1&thinsp;000&thinsp;000
|style="text-align:center;"|(or 10<sup>6</sup>)
|style="text-align:right;"|''mega-''
|style="text-align:right;"|M-
|Decimal

|-
|style="text-align:right;"|1&thinsp;048&thinsp;576
|style="text-align:center;"|(or 2<sup>20</sup>)
|style="text-align:right;"|''mebi-''
|style="text-align:right;"|Mi-
|Binary

|-
|style="text-align:right;"|1&thinsp;000&thinsp;000&thinsp;000
|style="text-align:center;"|(or 10<sup>9</sup>)
|style="text-align:right;"|''giga-''
|style="text-align:right;"|G-
|Decimal

|-
|style="text-align:right;"|1&thinsp;073&thinsp;741&thinsp;824
|style="text-align:center;"|(or 2<sup>30</sup>)
|style="text-align:right;"|''gibi-''
|style="text-align:right;"|Gi-
|Binary

|-
|
|etc.
|
|
|
|}Combine these with <span style="font-style:italic;">byte</span> or its abbreviation <span style="font-style:italic;">B</span>, and you get terminology like <span style="font-style:italic;">120 gigabyte SSD</span> or <span style="font-style:italic;">64KiB memory</span>.

You may notice there's a distinction between the decimal and binary naming schemes that you've probably not heard before. You've surely heard about <span style="font-style:italic;">megabytes</span> and <span style="font-style:italic;">gigabytes</span>, but probably not <span style="font-style:italic;">mebibytes</span> and <span style="font-style:italic;">gibibytes</span>. Typically, we tend to use the decimal-style prefixes for both decimal and binary numbers. It's just force of habit, and context usually tells the reader which one we really mean.

In fact, almost all readers will be unfamiliar with the binary <span style="font-style:italic;">xxbi-</span> word prefixes, so it is not necessarily recommended to use them. Prefer to speak to laypeople in terms of megabytes, not mebibytes. If writing documentation for a more technical user, the binary prefixes may be more acceptable.

However, it <span style="font-style:italic;">is</span> generally recommended to use the appropriate <span style="font-style:italic;">unit</span> prefixes. For instance, prefer to say "32KiB" over "32KB". This is still easily intuited by an average reader, while being more correct for a technical reader.

It's good to subtly link the use of any binary prefix to a page which explains the differences. (That's is why this page exists!)<h4>Why does it matter?</h4>In the real world, this subject mostly comes up with storage devices. Manufacturers favor decimal, as it allows them to put bigger numbers on their packaging. For instance, a 128GiB drive would be advertised as a 137GB drive, which is literally accurate. However, everywhere else in the computer world, 137GB is assumed to be 137GiB. Consumers are often disappointed to find their drives hold less data than expected.

This is less of an issue in gaming, but programmers may find that it is easier to get a point across to other programmers by using precise language. If, for instance, I tell you I have 130KB remaining in my budget, do I mean 133120 bytes, or 130000 bytes? For smaller numbers it matters very little, but as a programmer, you'll find numbers can get quite large and sometimes their exact values are important.

It's just a good habit to develop. Not critical, just good.
<hr style="height: 0.0625em;background-color: #888;" /><h2>KiB</h2>#redirect [[Counting Bytes]]<hr style="height: 0.0625em;background-color: #888;" /><h2>MiB</h2>#redirect [[Counting Bytes]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Mapdraw</h2>#redirect [[map]]
<hr style="height: 0.0625em;background-color: #888;" /><h2>Deprecated</h2>In programming, a <span style="font-style:italic;">deprecated</span> function is one which is still available, but which you should not use in new programs.

Keeping a function around, but deprecating it, is usually done to maintain backwards-compatibility with old programs.

Usually, a deprecated function is replaced with one or more new functions that do the same thing.

For instance, in the PICO-8 API, the original [[Mapdraw|mapdraw()]] function was renamed to just [[Map|map()]] for the sake of simplicity and consistency. The original function name was deprecated, but not removed, to avoid breaking old carts. However, new carts should use <code>map()</code>.

Occasionally, a function needs to be removed entirely. In these cases, the function may be deprecated for a period of time before it is removed. This is done so people who use the function have an opportunity to change their code before the function disappears and breaks it.
<hr style="height: 0.0625em;background-color: #888;" /><h2>Clipboard</h2>PICO-8 allows access the the system clipboard, either through its editors or with Lua code.<h4>Reading the clipboard with Lua</h4>The system clipboard contents can be found using [[Stat#Clipboard contents|<code>stat(4)</code>]], as a string:

<pre>
print('clipboard: '..stat(4))
</pre>

Caveat: Initially, <code>stat(4)</code> will return a blank string, even if there is data already on the system clipboard. The clipboard contents will only update under one of these conditions:<ul><li>The user presses the "paste" key sequence while Lua code is actively running. This is either Control-v (Windows, Linux) or Command-v (Mac OS X).</li><li>A string is written to the clipboard by Lua inside the current PICO-8 instance.</li></ul>This is to prevent a cartridge from accessing potentially-sensitive data on the host system's clipboard without the user's permission.<h4>Writing to the clipboard with Lua</h4>A string may be written to the system clipboard with [[Printh|<code>printh()</code>]], so you can paste it into another program interactively. To do this, provide a <code>filename</code> of <code>'@clip'</code>:

<pre>
printh('collision data: xpos='..xpos..' ypos='..ypos, '@clip')
</pre>

Each call to <code>printh(..., '@clip')</code> completely replaces the contents of the system clipboard with the given string. There is no way to append the string to the existing contents. As such, you must use the existing clipboard contents before the next call to <code>printh(..., '@clip')</code>.<h4>Editor clipboard formats</h4>The sprite editor reads and writes rectangular image data to the clipboard, formatted as a string of hexadecimal characters, like so:

<pre>
[gfx]WWHHPPPPP...PPP[/gfx]
</pre>

With:<ul><li>WW = width in hex (<code>01..80</code>, or 1..128 in decimal)</li><li>HH = height in hex (<code>01..80</code>, or 1..128 in decimal)</li><li>P = pixel in hex (<code>0..f</code>, or 0..15 in decimal)</li></ul>There should be <code>WW * HH</code> pixels encoded in the string.

When creating strings to for pasting into the sprite editor, be aware that newlines and any other characters that are not hexadecimal values will be treated as "0" (black) pixels.

<hr style="height: 0.0625em;background-color: #888;" /><h2>Keyboard Shortcuts</h2><sup><span style="font-style:italic;">!!! Work in progress !!!</span></sup>

Not all PICO-8 hardware has a keyboard, but when it does, there are many keyboard shortcuts that one can use. Known shortcuts are listed here.<hr />:'''Important:''' the lists below all start with the shortcuts for a '''QWERTY''' keyboard layout on a '''Windows''' build of PICO-8. Key bindings for other keyboard layouts or platform builds are only listed if they are known to be ''different'' from the Windows Build.:If your key isn't listed, or doesn't work right, try to use the Windows-style shortcut the way you would usually expect one to be done in your own OS. For instance, if you know Undo is Ctrl-Z on Windows, you'd want to try Cmd-Z on MacOS.:Also, if you are on a different regional layout, such as AZERTY or QWERTZ, try using the key that would be in the same ''physical'' position as the QWERTY key. And remember, there is a [[Keyconfig|<code>keyconfig</code>]] command you can use to change in-game button assignments.:'''Readers with knowledge of other platforms are encouraged to fill in the blanks if they know of keys that differ from the Windows layout.''' Don't worry too much about following the tricky formatting in these tables, unless you want to. Feel free to just enter whatever helpful notes you have, even if they aren't put into the tables. Someone else can do the formatting later if needed. Thanks!<hr /><!-- handy chars: ⌘Cmd ⇧Shift ⌥Opt ⌃↩⌤⌫⌦⌧⇥⇤␣⎋⇪⏏⇞⇟↖↘←→↑↓ --><h4>Global use</h4>{| class="article-table" style="width: 100%;"
!scope="col" style="width: 34%;"|Function
!scope="col" style="width: 22%;"|Windows
!scope="col" style="width: 22%;"|Linux
!scope="col" style="width: 22%;"|MacOS
|-
|<u>Q</u>uit
|<kbd>Alt</kbd>+<kbd>F4</kbd>
|<kbd>Ctrl</kbd>+<kbd>Q</kbd>
|<kbd>⌘Cmd</kbd>+<kbd>Q</kbd>
|-
|<u>R</u>eload/<u>R</u>un/<u>R</u>estart
|<kbd>Ctrl</kbd>+<kbd>R</kbd>
|<kbd>Ctrl</kbd>+<kbd>R</kbd>
|
|-
|Quick-<u>S</u>ave
|<kbd>Ctrl</kbd>+<kbd>S</kbd>
|<kbd>Ctrl</kbd>+<kbd>S</kbd>
|
|-
|<u>M</u>ute/un<u>m</u>ute
|<kbd>Ctrl</kbd>+<kbd>M</kbd>
|<kbd>Ctrl</kbd>+<kbd>M</kbd>
|
|-
|Editor toggle
|<kbd>Esc</kbd>
|<kbd>Esc</kbd>
|
|-
|Full screen toggle
|<kbd>Alt</kbd>+<kbd>Enter</kbd>
|<kbd>Alt</kbd>+<kbd>Enter</kbd>
|<kbd>⌘Cmd</kbd>+<kbd>F</kbd>
|-
|Save a screenshot to desktop
|<kbd>F1</kbd> / <kbd>F6</kbd><br /><kbd>Ctrl</kbd>+<kbd>6</kbd>
|
|
|-
|Capture cartridge label image
|<kbd>F2</kbd> / <kbd>F7</kbd><br /><kbd>Ctrl</kbd>+<kbd>7</kbd>
|
|
|-
|Start recording a video
|<kbd>F3</kbd> / <kbd>F8</kbd><br /><kbd>Ctrl</kbd>+<kbd>8</kbd>
|
|
|-
|Save GIF video to desktop
|<kbd>F4</kbd> / <kbd>F9</kbd><br /><kbd>Ctrl</kbd>+<kbd>9</kbd>
|
|
|-
|Toggle keyboard cursor
|<kbd>F5</kbd> / <kbd>F10</kbd><br /><kbd>Ctrl</kbd>+<kbd>0</kbd>
|
|
|-
|Toggle FPS display
|<kbd>Ctrl</kbd>+<kbd>1</kbd>
|
|
|-
|Previous editor
|<kbd>Alt</kbd>+<kbd>←</kbd>
|<kbd>Alt</kbd>+<kbd>←</kbd>
|
|-
|Next editor
|<kbd>Alt</kbd>+<kbd>→</kbd>
|<kbd>Alt</kbd>+<kbd>→</kbd>
|
|}<h4>While running</h4>{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|<u>P</u>ause menu
|<kbd>P</kbd> / <kbd>Enter</kbd>
|
|
|}See [[Btn|<code>btn()</code>]] for details on default controller/keyboard mappings, and [[Keyconfig|<code>keyconfig</code>]] for info on changing those mappings.<h4>Command Line</h4>{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|<u>C</u>opy (entire line)
|<kbd>Ctrl</kbd>+<kbd>C</kbd>
|
|
|-
|Paste
|<kbd>Ctrl</kbd>+<kbd>V</kbd>
|
|
|-
|History
|<kbd>&#8239;↑&#8239;</kbd> / <kbd>&#8239;↓&#8239;</kbd>
|
|
|-
|<u>E</u>nd-of-line
|<kbd>End</kbd><br /><kbd>Ctrl</kbd>+<kbd>E</kbd>
|
|
|-
|Start-of-line
|<kbd>Home</kbd><br /><kbd>Ctrl</kbd>+<kbd>A</kbd>
|
|
|-
|<u>K</u>ill to end-of-line
|<kbd>Ctrl</kbd>+<kbd>K</kbd>
|
|
|-
|Kill to start-of-line
|<kbd>Ctrl</kbd>+<kbd>U</kbd>
|
|
|-
|Clear screen
|<kbd>Ctrl</kbd>+<kbd>L</kbd>
|
|
|}<h4>Text Editor</h4>{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|Cut
|<kbd>Ctrl</kbd>+<kbd>X</kbd>
|
|
|-
|<u>C</u>opy
|<kbd>Ctrl</kbd>+<kbd>C</kbd>
|
|
|-
|Paste
|<kbd>Ctrl</kbd>+<kbd>V</kbd>
|
|
|-
|Select <u>A</u>ll
|<kbd>Ctrl</kbd>+<kbd>A</kbd>
|
|
|-
|<u>K</u>eyboard glyph mode toggle
|<kbd>Ctrl</kbd>+<kbd>K</kbd>
|
|
|-
|Insert/overwrite toggle
|<kbd>Ins</kbd>
|
|
|-
|Start of line
|<kbd>Home</kbd><br /><kbd>Ctrl</kbd>+<kbd>W</kbd>
|
|
|-
|<u>E</u>nd of line
|<kbd>End</kbd><br /><kbd>Ctrl</kbd>+<kbd>E</kbd>
|
|
|-
|Start of document
|<kbd>Ctrl</kbd>+<kbd>Home</kbd><br /><kbd>Ctrl</kbd>+<kbd>&#8239;↑&#8239;</kbd>
|
|
|-
|End of document
|<kbd>Ctrl</kbd>+<kbd>End</kbd><br /><kbd>Ctrl</kbd>+<kbd>&#8239;↓&#8239;</kbd>
|
|
|-
|Previous word
|<kbd>Ctrl</kbd>+<kbd>←</kbd>
|
|
|-
|Next word
|<kbd>Ctrl</kbd>+<kbd>→</kbd>
|
|
|-
|Previous function
|<kbd>Alt</kbd>+<kbd>&#8239;↑&#8239;</kbd>
|
|
|-
|Next function
|<kbd>Alt</kbd>+<kbd>&#8239;↓&#8239;</kbd>
|
|
|-
|Indent selection
|<kbd>⇥Tab</kbd>
|
|
|-
|Un-indent selection
|<kbd>Shift</kbd>+<kbd>⇥Tab</kbd>
|
|
|-
|Undo
|<kbd>Ctrl</kbd>+<kbd>Z</kbd>
|
|
|-
|Redo
|<kbd>Ctrl</kbd>+<kbd>Y</kbd>
|
|
|-
|<u>F</u>ind text in current tab
|<kbd>Ctrl</kbd>+<kbd>F</kbd>
|
|
|-
|Find text a<u>G</u>ain
|<kbd>Ctrl</kbd>+<kbd>G</kbd>
|
|
|-
|Repeat search across tabs (<u>H</u>yper search)
|<kbd>Ctrl</kbd>+<kbd>H</kbd>
|
|
|-
|Go to <u>L</u>ine number
|<kbd>Ctrl</kbd>+<kbd>I</kbd><br /><kbd>Ctrl</kbd>+<kbd>L</kbd>
|
|
|-
|<u>D</u>uplicate current line
|<kbd>Ctrl</kbd>+<kbd>D</kbd>
|
|
|-
|Toggle comment <u>B</u>lock
|<kbd>Ctrl</kbd>+<kbd>B</kbd>
|
|
|-
|Switch to next tab
|<kbd>Ctrl</kbd>+<kbd>⇥Tab</kbd>
|
|
|-
|Switch to previous tab
|<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>⇥Tab</kbd>
|
|
|}<h4>Sprite editor</h4>All tools:{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|Pan tool
|<kbd>Space</kbd>+<kbd>🖰&#8239;LClick+Drag</kbd>
|
|
|-
|<u>C</u>opy
|<kbd>Ctrl</kbd>+<kbd>C</kbd>
|
|
|-
|Paste (at current sprite location)
|<kbd>Ctrl</kbd>+<kbd>V</kbd>
|
|
|-
|Undo/Redo (single-step)
|<kbd>Ctrl</kbd>+<kbd>Z</kbd>
|
|
|-
|Previous sprite
|<kbd>Q</kbd>
|
|
|-
|Next sprite
|<kbd>W</kbd>
|
|
|-
|Previous color
|<kbd>1</kbd>
|
|
|-
|Next color
|<kbd>2</kbd>
|
|
|-
|Toggle full view
|<kbd>⇥Tab</kbd>
|
|
|-
|Replace color
|<kbd>Ctrl</kbd>+<kbd>🖰&#8239;LClick</kbd>
|
|
|-
|Shift by one pixel
|<kbd>←</kbd> / <kbd>→</kbd> / <kbd>&#8239;↑&#8239;</kbd> / <kbd>&#8239;↓&#8239;</kbd>
|
|
|-
|<u>F</u>lip <u>H</u>orizontal
|<kbd>F</kbd><br /><kbd>H</kbd>
|
|
|-
|Flip <u>V</u>ertical
|<kbd>V</kbd>
|
|
|-
|<u>R</u>otate 90° CCW
|<kbd>R</kbd>
|
|
|-
|Zoom
|<kbd>&lt;</kbd> / <kbd>&gt;</kbd><br /><kbd>🖰&#8239;Wheel</kbd>
|
|
|}Draw tool:{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|<u>C</u>opy
|<kbd>Ctrl</kbd>+<kbd>C</kbd>
|
|
|-
|Paste (at upper left)
|<kbd>Ctrl</kbd>+<kbd>V</kbd>
|
|
|-
|Replace color
|<kbd>Ctrl</kbd>+<kbd>🖰&#8239;LClick</kbd>
|
|
|-
|Color Picker
|<kbd>🖰&#8239;RClick</kbd>
|
|
|}Stamp tool:{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|Stamp with color 0 transparent
|<kbd>LCtrl</kbd>+<kbd>🖰&#8239;LClick</kbd>
|
|
|}Select tool:{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|Select none
|<kbd>Enter</kbd>
|
|
|}Fill tool:

(n/a?)

Lower sprite sheet area:{| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|Select multiple sprites<br />(for flip, shift, copy, rotate)
|<kbd>Shift</kbd>+<kbd>🖰&#8239;LClick+Drag</kbd>
|
|
|}<h4>Map editor</h4>(TODO)<h4>SFX editor</h4>(TODO, incomplete){| class="article-table" style="width: 100%;"
! scope="col" style="width: 34%;" |Function
! scope="col" style="width: 22%;" |Windows
! scope="col" style="width: 22%;" |Linux
! scope="col" style="width: 22%;" |MacOS
|-
|Swap pitch/note views
|
|<kbd>Tab</kbd>
|
|-
|Increase Speed
|
|<kbd>Period</kbd>
|
|-
|Decrease Speed
|
|<kbd>Comma</kbd>
|
|-
|Increase Speed by 4
|
|<kbd>Shift</kbd> + <kbd>Period</kbd>
|
|-
|Decrease Speed by 4
|
|<kbd>Shift</kbd> + <kbd>Comma</kbd>
|
|-
|Switch to Next Sound Effect
|
|<kbd>=</kbd>
|
|-
|Switch to Previous Sound Effect
|
|<kbd>-</kbd>
|
|}<h4>Music editor</h4>(TODO)
<hr style="height: 0.0625em;background-color: #888;" /><h2>Land Gruber</h2>{{Game|title = Land Gruber|imagecaption = Title screen shot|first = Burning_Out|second = Action|third = One|image = Landgruber.jpg|imagewidth = 224}}<h4>Description</h4>From one of the final scenes of the Die Hard movie, Hans Gruber is about to fall to his death.  Help him catch as many coins and bank notes as possible before he goes splat!<h4>Rules</h4><ul><li>As Gruber falls, batches of coins and bank notes are falling from the Nakatomi Plaza, which must be collected.</li><li>Avoid flames, as they deduct points.</li><li>Bank notes are worth the most while coins are worth the least during Gruber’s fall.  Hitting Theo’s limo at the end has the largest bonus.</li><li>The cloud layer indicates the player is at the halfway point of their fall/the game, along with a flashing indicator signaling that the ground/limo is near.</li></ul><h4>Controls</h4><ul><li>At the title screen, press z or x to start the game.</li><li>Use the arrow keys to move Gruber (left/right only).</li><li>Use the enter or p key to pause the game or reset the cart.</li><li>Use the x key to confirm game configuration at the menu and to skip cutscenes.</li><li>Use the z key to change the rating from R to PG-13 at the menu.</li></ul><h4>Links</h4>[https://www.lexaloffle.com/bbs/?tid=30782 Play game]




<hr style="height: 0.0625em;background-color: #888;" /><h2>Pico-Kit</h2>An opinionated collection of PICO-8 helpers that add a couple of useful bits of functionality. It comes with four libraries:<ul><li>oop - an implementation of classes and objects that uses metatables</li><li>tools - various tools for manipulating tables</li><li>debug - improved printing that allows you to print an entire table, among other things</li><li>physics - a tiny physics engine</li></ul>To get started, just download the 'starter.p8' file off of the [https://github.com/outkine/pico-kit github page] and open it up with PICO-8.
<hr style="height: 0.0625em;background-color: #888;" /><h2>Gpio</h2>#REDIRECT [[GPIO]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Set fps</h2>{{ApiReference
|name=_set_fps
|shortdesc=Set the target framerate.
|rate||The target framerate: 15, 30, or 60.
}}
This internal, undocumented function is how the PICO-8 application sets the target frame rate.

When the user's code is first run, PICO-8 is in 30fps mode. Typically, the user's code will be run through, without any actual drawing being done, and then control will return to the hidden outer code that will then begin to call [[Update|<code>_update()</code>]] and [[Draw|<code>_draw()</code>]] repeatedly.

At the point where the outer code takes over, it will check for the presence of either <code>_update()</code> or <code>_update60()</code> and then call either <code>_set_fps(30)</code> or <code>_set_fps(60)</code>, respectively.

If, however, the user wishes to do some drawing before control returns to the outer code, they may change the default frame rate with this function and then create their own custom main loop that updates, draws, and calls [[Flip|<code>flip()</code>]], repeatedly.<h4>Note on 15fps mode</h4>This mode is really most practical when calling <code>_set_fps(15)</code> from root user code, and then doing all updating and rendering with a custom main loop. Otherwise the outer code will take over and assign either 30fps or 60fps mode, depending on which functions are implemented.

However, if <code>_set_fps(15)</code> is called from within <code>_update()</code> (note that <code>_init()</code> is too early), then the outer code will begin to call <code>_update()</code> twice for every call to <code>_draw()</code>, effectively halving the draw rate to 15fps. This is both klunky and unsupported, so it would generally be better just to use standard 30fps mode and return early from every other <code>_draw()</code> call.<h4>Warning</h4>As an undocumented function, <code>_set_fps()</code> cannot be relied on for a game. Its functionality may change or be removed in future versions. Still, some may find a pragmatic use for it in tools or demos. Just be aware that you use it at your own risk.<h4>Examples</h4><pre>
-- make a reddish orange by rapidly alternating red and orange at 60fps
_set_fps(60)
while true do
  cls(8) -- red
  flip()
  cls(9) -- orange
  flip()
end

-- wait for 1 second at 15fps
_set_fps(15)
for i=1,15 do
  flip()
end
</pre>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Update buttons</h2>{{ApiReference
|name=_update_buttons
|shortdesc=Update the gamepad state.
}}
This internal, undocumented function is how the PICO-8 application updates the gamepad state.

While the user's code is first being run, the gamepad state is expected to be undefined and unreliable, as calls to functions like [[Btn|<code>btn()</code>]] or [[Btnp|<code>btnp()</code>]] are only expected to be done inside of [[Update|<code>_update()</code>]] and possibly [[Draw|<code>_draw()</code>]], which will not occur until after all of the user's code has been run through.

If, however, the user wishes to do some processing of inputs over an extended period of time before control returns to the outer loop that calls update/draw, they may force updates to the gamepad state by calling <code>_update_buttons()</code>. Typically, one would call this between a call to [[Flip|flip()]] and the logic that depends on the buttons.<h4>Warning</h4>As an undocumented function, <code>_update_buttons()</code> cannot be relied on for a game. Its functionality may change or be removed in future versions. Still, some may find a pragmatic use for it in tools or demos. Just be aware that you use it at your own risk.<h4>Examples</h4><pre>
print("press any button to continue")
repeat
  flip()
  _update_buttons()
until btn() != 0
</pre>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Count</h2>{{ApiReference
|name=count
|shortdesc=Count the non-nil entries in an array-style table
|tbl||The table.
}}
This legacy, undocumented function simply iterates over the indices in an array-style table and counts how many are non-<code>nil</code>.

Note that this will <span style="font-style:italic;">not</span> count entries which are not numeric array-style. See the example below for a demonstration.

This function was removed from the official API as of version 0.1.2:

<pre>removed count() from docs -- now just a legacy function. Use # operator instead.</pre>

It may be worth noting that the advice to use the # operator instead is probably well-intentioned, but the two operations are slightly different. The # operator returns the highest non-nil element's index, while this function laboriously walks over the table's contents and counts everything that isn't nil. In a full table, these are the same number, but with nil elements, they will differ.<h4>Warning</h4>As a now-undocumented legacy function, <code>count()</code> cannot be relied on for a game. Its functionality may be removed in future versions. Still, some may find a pragmatic use for it in tools or demos. Just be aware that you use it at your own risk.<h4>Examples</h4><pre>
> t = {1,2,nil,4,nil,6,7}
> print(count(t))
5

> -- this is not a numeric array-style element and will not be seen by count(t)
> t.x = 123
> print(count(t))
5

> -- this is not a numeric array-style element and will not be seen by count(t)
> t[true] = "true"
> print(count(t))
5
</pre><h4>See also</h4><ul><li>[[Tables]]</li><li>[[Add|<code>add()</code>]]</li><li>[[Del|<code>del()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Sgn</h2>{{ApiReference
|name=sgn
|shortdesc=Returns the sign of a number, 1 for positive, -1 for negative
|number|required|The number to determine the sign of.
}}<h4>Technical Note</h4><code>sgn(0)</code> will return 1, not 0 as might be common on other platforms.<h4>Examples</h4><pre>
sgn(100) -- returns 1
sgn(0)   -- returns 1 (not 0)
sgn(-14) -- returns -1
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Math]]</li><li>[[Abs|<code>abs()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Goto & Labels</h2>The goto system is related to goto in the C language (and many others) and will be familiar to those with experience outside Lua.<h4>How to use Goto</h4>Goto allows the user to define code blocks with Labels and the jump to them or "goto" them, at any point.

A label is defined with two colons (::) on either side of it's name.<pre>::a_label::</pre>To jump to the code directly after that label write:<pre>goto a_label</pre>Be aware that labels will "fall through". In the example below, if at line 3, math.random() !< 0.3, then the ::b:: label will run.

from the [http://lua-users.org/wiki/GotoStatement lua manual] :<pre>::a::
  print 'A'
  if math.random() < 0.3 then goto c end
::b::
  print 'B'
  if math.random() < 0.5 then goto a end
::c::
  print 'C'
  if math.random() < 0.1 then goto a else goto b end</pre><h4>See also</h4><ul><li>[[Lua]]</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Holdframe</h2>{{ApiReference
|name=holdframe
|shortdesc=Prevents the physical display from showing changes to video memory.
}}
This internal, undocumented function is how the PICO-8 application prevents changes to video memory from being shown on the physical display.

Normally, even in the absence of a proper <code>_update()</code>/<code>_draw()</code> loop or manual calls to <code>flip()</code>, the displayed image will periodically be automatically refreshed to show changes made to video memory. Many demos and tweetcarts take advantage of this.

To disable this automatic refresh, <code>holdframe()</code> may be called. Afterwards, the physical display will not show any changes made to video memory.

Automatic periodic refreshing will be re-enabled after the next call to <code>flip()</code>.<h4>Warning</h4>While <code>holdframe()</code> <span style="font-style:italic;">is</span> mentioned in the official documentation, it is only mentioned in the change log as an addition at a very early stage. It is otherwise undocumented. As an undocumented function, it cannot be relied on for a game. Its functionality may change or be removed in future versions. Still, some may find a pragmatic use for it in tools or demos. Just be aware that you use it at your own risk.<h4>Examples</h4><pre>
-- this displays a colorful random noise pattern...
while true do
  pset(rnd(128),rnd(128),rnd(16))
end

-- ...however, even though this *draws* the same noise, 
-- it *displays* nothing until the program is interrupted
holdframe()
while true do
  pset(rnd(128),rnd(128),rnd(16))
end
</pre><h4>See also</h4><ul><li>[[Flip|<code>flip()</code>]]</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Piconian</h2>{{Game|title = Piconian|imagecaption = Title screen shot|first = aquova|second = Action|third = One|image = Piconian.jpg|imagewidth = 224}}<h4>Description</h4>Fly around, avoiding (or destroying) space debris while obliterating as many enemy bases as possible.<h4>Rules</h4><ul><li>Use the radar display at the bottom right corner of the screen to locate enemy bases.</li><li>Avoid or shoot space debris (asteroids, mines) along the way.</li></ul><ul><li>The player's ship can wrap around the edge of a level (flying to the right edge will cause it to re-emerge at the left side of the screen, for example), providing shortcuts to bases.</li><li>An enemy base can be destroyed in two ways: by either a shot straight up its middle or by shooting all six of its pods.</li><li>Colliding with an asteroid, mine, base or missile fired from an enemy base will destroy the player's ship and the game will end when all lives have been exhausted.</li><li>An extra ship is awarded with every thousand points.</li></ul><h4>Controls</h4><ul><li>At the title screen, use the left/right arrow keys to view high scores.</li><li>At the title screen, press the x key to start a game.</li><li>Use the arrow keys to start a new level.</li><li>Use the x key to fire.</li><li>Use the arrow keys to move (ship will thrust on its own).</li><li>Use the z or enter key to pause the game and/or reset the cart.</li></ul><h4>Links</h4>[https://www.lexaloffle.com/bbs/?tid=31627 Play game]


<hr style="height: 0.0625em;background-color: #888;" /><h2>User blog:The5thPentagonMade/Keyboard Shortcuts in Mac</h2>Please read this before reading; Work in Progress -- Do not edit this page
<h2>By pressing certain key combinations, you can do things that normally need a mouse, trackpad, or other input device.</h2>

To use a keyboard shortcut, press and hold one or more modifier keys and then press the last key of the shortcut. For example, to use <kbd>⌘Command</kbd>+<kbd>C</kbd> (copy), press and hold the <kbd>⌘Command</kbd> key, then the <kbd>C</kbd> key, then release both keys. Mac menus and keyboards often use symbols for certain keys, including modifier keys:

Command (or Cmd) ⌘

Shift ⇧

Option (or Alt) ⌥

Control (or Ctrl) ⌃

<sup>On keyboards made for Windows PCs, use the Alt key instead of Option, and the Windows logo key instead of Command.</sup>

Some keys on some Apple keyboards have special symbols and functions, such as for display brightness , keyboard brightness , Mission Control, and more. If these functions aren't available on your keyboard, you might be able to reproduce some of them by creating your own keyboard shortcuts.

<!-- handy chars: ⌘Cmd ⌃Ctrl ⌥Opt ⇧Shift --><h4>Copy, paste, and other popular shortcuts</h4>Here the popular shortcuts contain cut, copy, paste, and more.
{| class="article table" style="width: 100%;"
!scope="col" style="width: 34%;"|Function
!scope="col" style="width: 11%;"|Combination
|-
|Cut the selected item and store it in the Clipboard
|<kbd>⌘Cmd</kbd>+<kbd>X</kbd>
|-
|Copy the selected item and store it in the Clipboard (Works for files in the <b>Finder</b>)
|<kbd>⌘Cmd</kbd>+<kbd>C</kbd>
|-
|Paste the selected item from the Clipboard (Works for files in the <b>Finder</b>)
|<kbd>⌘Cmd</kbd>+<kbd>V</kbd>
|-
|Undo the last action
|<kbd>⌘Cmd</kbd>+<kbd>Z</kbd>
|-
|Redo the last action
|<kbd>⇧Shift</kbd>+<kbd>⌘Cmd</kbd>+<kbd>Z</kbd>
|-
|Open the <b>Force Quit</b> dialog to force quit apps
|<kbd>⌥Opt</kbd>+<kbd>⌘Cmd</kbd>+<kbd>Esc</kbd>
|-
|Quit the selected app
|<kbd>⌘Cmd</kbd>+<kbd>Q</kbd>
|-
|Select all
|<kbd>⌘Cmd</kbd>+<kbd>A</kbd>
|-
|Hide the front window
|<kbd>⌘Cmd</kbd>+<kbd>H</kbd>
|-
|Close the selected app or close a tab
|<kbd>⌘Cmd</kbd>+<kbd>W</kbd>
|-
|Minimize the front window to the dock
|<kbd>⌘Cmd</kbd>+<kbd>M</kbd>
|-
|Display the supported app in full-screen mode
|<kbd>⌘Cmd</kbd>+<kbd>⌃Ctrl</kbd>+<kbd>F</kbd>
|-
|Open <b>Spotlight</b> Search
|<kbd>⌘Cmd</kbd>+<kbd>Spacebar</kbd>
|-
|Show the front window but hide all other windows
|<kbd>⌥Opt</kbd>+<kbd>⌘Cmd</kbd>+<kbd>H</kbd>
|-
|Take a screen-shot of the entire screen
|<kbd>⇧Shift</kbd>+<kbd>⌘Cmd</kbd>+<kbd>3</kbd>
|-
|Open the <b>Application Switcher</b> to switch open apps
|<kbd>⌘Cmd</kbd>+<kbd>Tab</kbd>
|-
|Find text in a browser
|<kbd>⌘Cmd</kbd>+<kbd>F</kbd>
|-
|Find again: Find the next occurrence
|<kbd>⌘Cmd</kbd>+<kbd>G</kbd>
|-
|Create a new document
|<kbd>⌘Cmd</kbd>+<kbd>N</kbd>
|-
|Create a new folder in the <b>Finder</b>
|<kbd>⇧Shift</kbd>+<kbd>⌘Cmd</kbd>+<kbd>N</kbd>
|-
|Open a document
|<kbd>⌘Cmd</kbd>+<kbd>O</kbd>
|-
|Save a document
<hr style="height: 0.0625em;background-color: #888;" /><h2>User blog:The5thPentagonMade</h2><hr style="height: 0.0625em;background-color: #888;" /><h2>Super Mario Bros. (Authentic)</h2>Super Mario Bros. (Authentic) is the original SMB, but the player can run back. The 1st world is played but the 1st & 2nd levels are just the playable ones. Luigi is separate from this, is in Luigi’s Journey: The Big Crumble. That was my 👍 spelling. The other one is weird: You are Super, you eat a Fire Flower in the rounds, you have World 1 to win, and there is World 1-5, a BONUS round matching World 1-0, and the Koopas are weird: Just green, and Bowser is the only boss.
<hr style="height: 0.0625em;background-color: #888;" /><h2>Delunky - Endless Descent</h2>{{Game|title = Delunky - Endless Descent|imagecaption = Title screen|first = johanp|second = Platformer|third = One|image = Delunky.jpg|imagewidth = 224}}<h4>Description</h4>Enter the caves and try to find as much gold as you can before you perish to the dangers of the depth. Use your trusty whip in combination with bombs, ropes, and whatever you scavenge to get as far as you can.<h4>Rules</h4><ul><li>The player starts off at the top of a level and must make their way downwards to the exit by either jumping, climbing down ladders, blasting holes in floors, using ropes or falling from platforms. The player can attach themselves to a wall and rappel either up or down from there depending on the wall's height (if it's too tall the player will not be able to latch onto it).  Reaching and entering an exit door at the end of a level will lead to the next one.</li><li>Along the way the player must gather gold for the highest score possible. Along with loose bars, gold can also be seen embedded in cave walls; these can be freed up by a bomb being detonated nearby or having a giant boulder destroy the wall. Stealing a golden skull and carrying it to the exit will also result in a 1000 point bonus.</li><li>The player comes armed with a whip to protect themselves from enemies and open various objects that could have helpful items inside to add to their supplies. They also begin a game with three bombs and three ropes, which bombs can be used to make an escape route if the player is trapped or protect the player against dangerous creatures. Ropes help the player reach various places that they otherwise wouldn’t be able to reach any way other than climbing, falling or jumping.</li><li>The player can only carry one special item at a time that does not get placed in their inventory (the latter of which includes bombs and ropes), which includes a golden skull, rock, crate or a woman.</li><li>Helping out the player are urns and crates that can be found in the caves; an urn can be shattered by throwing it against a wall or hitting it with the whip. Urns can contain gold, but on the other hand they also could contain a creature that could cost the player health units or their life should they come into contact with them. Crates can be opened with a whip and contain additional bombs or ropes. A blonde woman may also appear in the caves occasionally, which the player must pick up and take her to the exit. Upon exiting the level their health will be increased by a heart unit.</li><li>Dangers of caves includes creatures, being snakes, bats and spiders. Snakes move slowly but can change direction. Bats fly towards the player and spiders quickly jump around while also homing in on the player, both of which are alerted to the player’s presence when they get too close, although the player can lose them if they put enough of a distance between them, along with defeating them by jumping or climbing down on them from a ladder, blowing them up with a bomb or hitting them with their whip, an urn, crate, rock, arrow, golden skull, or even the blonde woman. (The creatures can also die when coming into contact with a spike.) Coming into contact with any of the creatures will cost the player a health point.</li><li>Other cave dangers include if the player were to fall too far, costing them health and/or their life. Arrows shot from stone idols will cost two of the player’s health units/hearts if they make contact, as those are set off when something crosses the idols’ line of sight. Giant boulders are released if the player steals the gold skull at their base. The player can also become trapped in an area where there is no escape. Spikes are also found all over the place, which coming into contact with one, being blown up by their own bomb, being hit by the giant boulder or being trapped and having to "admit defeat" will cause the player an instant death with no matter how much health they have.</li><li>The player's health is represented by hearts at the top right of the screen, which many of the aforementioned perils will cost the player their health and the game will end when there are no more hearts left.</li><li>Stone idols shoot arrows when something crosses their line of sight, but they can be set off by a creature flying by, having a bomb, golden skull, blonde woman, urn, crate, arrow or rock thrown in front of them. After an arrow is set off the player can pick it up and use it.</li></ul><h4>Controls</h4><ul><li>Use the x key to start a game.</li><li>Use the escape, p or enter keys to pause the game.</li><li>Use the arrow keys to move.</li><li>Use a directional arrow key while jumping to stick to a wall (i. e. press and hold the left arrow key while jumping left to stick to a wall facing west from the player).</li><li>Use the down arrow key to pick up an item.</li><li>Use the up arrow key to jump.</li><li>Use the x key to use, throw or drop a current item, along with using the whip.</li><li>To drop the rope down, choose it by cycling through items, then press x while holding the down arrow key.</li><li>Use the z key to cycle through items.</li><li>To enter the exit door use the up arrow key while standing in its doorway.</li><li>To accept defeat (kill the player/end the game), pause the game, then choose that from the menu.</li></ul><h4>Links</h4>[https://www.lexaloffle.com/bbs/?tid=31862 Play game]

<hr style="height: 0.0625em;background-color: #888;" /><h2>Minima</h2>{{Game|title = Minima|image = https://img.itch.zone/aW1nLzE1MzY4MjYucG5n/315x250%23c/MGIQyb.png|imagewidth = 315|imagecaption = The Minima Cartridge|first = Feneric|second = RPG|third = One}}<h4>Description</h4>In Minima you take on the role of a hero trying to save the land of Miskatonia from the evil Faxon and its minions. It's up to you to explore the land, talk with the people, figure a few things out, and get strong enough to defeat the Faxon and its legions of orcs, undead, and daemons.

Minima is an homage to the 8-bit Ultima games (especially Ultima II, Ultima III, Ultima IV, and Ultima V) as they were on the Commodore 128. Like those games, it features a 2D world view and 2D town views as well as 3D dungeon views.<h4>Controls</h4>Minima is easiest with a keyboard.<h5>Minima Command Keys</h5>; a 	 attackc 	 cast spell

d 	 dialog, talk, buy

e 	 enter, board, mount, climb, descend

p 	 pause, bring up game menu

f 	 fountain drink; force chest; flame torch

s 	 sit & wait

w 	 wearing & wielding

x 	 examine, look (repeat to search);<h5>PocketC.H.I.P. Command Keys (if not changed)</h5>; / 	 attack0 	 cast spell

left shift 	 dialog

z 	 enter, board, mount, climb, descend

enter 	 pause, bring up game menu

fn 	 fountain drink; force chest; flame torch

tab 	 sit & wait

right ctrl 	 wearing & wielding

- 	 examine
<hr style="height: 0.0625em;background-color: #888;" /><h2>Super Mega Bread</h2>{{Game|title = Super Mega Bread|imagecaption = Title Screen|first = jclermont|second = Platformer|third = One|image = SuperMegaBreadTitle.png|imagewidth = 256}}<h4>Description</h4>[[File:Bread.p8 0.gif|thumb|220x220px]]
The player takes the role of Bread Man, who has the ability to throw butter or jump in mid-air using butter. There are four levels, each with a different theme and gimmick. The main antagonist is Dr. Yogurt, who is polluting BreadLand with processed junk food.<h4>Controls</h4><ul><li>Z: Jump</li><li>X: Throw Butter</li><li>Left/Right: Move</li><li>Up/Down: Aim Butter</li><li>Enter: Pause/Settings</li></ul><h4>Unlockables</h4><ul><li>Level Select: Beat the game once.</li><li>Mayo Mode: Go into the crevice in the ice block at the start of Grape Glacier.<ul><li>You start each level with limited Mayo, with no pickups or checkpoints.</li></ul></li><li>Yogurt Mode: Stand in the corner right above the exit to the final boss room.<ul><li>You play as Dr. Yogurt and have shorter jumps.</li></ul></li></ul><h4>Links</h4><ul><li>https://jclermont.itch.io/super-mega-bread</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Blockrush</h2>[[File:625F99C3-C017-475C-81AA-2E56AD01BC46.png|thumb|Main menu]]
[[File:214D6237-25D2-4B2B-BCC7-0420FAC619F5.jpeg|thumb|Gameplay]]<h4>Information</h4>This game was made by Oskar Zanota and Eddy Rashed, for the Pixeler’s game jam, that they won. It was made in 2 days, but the full version is still in development.<h4>How to play</h4>You play as a cube in a 2D world. When you move, you cannot stop until you reach a solid object. To finish a level, get to the treasure chest ! There are also hidden crowns that you can (you don’t have to) pickup during your game.<ul><li>Play the game jam’s version here : https://oskar-codes.itch.io/blockrush</li><li>Play the latest version here : https://oskar-codes.github.io/Blockrush</li></ul><h4>Controls</h4>Menu :<ul><li>Left and right arrow to navigate</li><li>X, V, or M to select a level</li><li>C, Z, or N to toggle music</li></ul>In game :<ul><li>Move with arrow keys</li><li>X, V, or M to reset the level, or to teleport if on a teleporter</li><li>C, Z, or N to go back to the menu</li></ul><h4>Objects</h4><ul><li>Treasure chest : pick it up to finish the level</li><li>Crown : an optional collectible that can be picked up in each level, picking it up brings you to the start of the level.</li><li>Orb : stops you on your track and allows you to change direction.</li><li>Teleporter : teleports you to the teleporter of the corresponding color when X, V, or M is pressed.</li><li>Wall teleporter : teleports you to the corresponding teleporter on the same line when moving towards it. Your direction remains the same.</li><li>Electricity : kills you whenever you touch it.</li><li>Wall spikes : kills you if you move towards them.</li><li>Arrow : changes your direction to the arrow's direction.</li><li>WannaBeBlock : a block that destroys itself if you move towards it from far enough. (not available in the game jam’s version)</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Bluestone's Awakening</h2>{{Game|title = Bluestone's Awakening|first = jclermont|second = Platformer|third = 1|image = BluestonesAwakeningTitle.png}}<h4>Description</h4>[[File:BluestonesAwakeningGameplay.gif|thumb|220x220px]]
The game features a blob creature named Bluestone who is dreaming about giving gifts to his friends. Once he delivers all of the gifts, he can wake up and go to work. However, there is an indigo creature which he must avoid.<h4>Controls</h4><ul><li>Z: Jump (Hold button to jump higher)</li><li>X: Grab/Release Object</li><li>Left/Right: Movement</li><li>Down: Duck/Hide<ul><li>If you're holding an item, enemies will just run past you and be unable to hurt you, but you can't move while ducking.</li></ul></li></ul><h4>Links</h4><ul><li>BBS: https://www.lexaloffle.com/bbs/?pid=59762#p</li><li>Itch.io: https://jclermont.itch.io/bluestones-awakening</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>CPU</h2>PICO-8 keeps track of CPU usage using two values: Lua cycles and system cycles. Most operations affect Lua cycles, but some functions have an additional system cycle cost.

There are 4194304 cycles in a second (2^22), so about 69905 cycles per frame at 60 FPS, or 139810 cycles at 30 FPS. The function call [[stat|<code>stat(1)</code>]] returns the total (Lua + system) cycle ratio for the current frame, and [[stat|<code>stat(2)</code>]] returns the system ratio.<blockquote>Example: since [[cls|<code>cls()</code>]] uses 2 Lua cycles and 1024 system cycles, PICO-8 running at 60 FPS can call [[cls|<code>cls()</code>]] about <code>2^22/60/1026 = 68</code> times.</blockquote><h4>Optimization Tips:</h4>Some tips for when your code isn't running fast enough: (these will increase your code's size and reduce its clarity, however - it's a trade-off)<ul><li>First, make sure you know why your code is running slow - which part's costing the most time? Use time() or stat(1) calls to measure this, or just delete blocks of code to see where the problem lies.</li><li>Focus on just the code causing the most slowdown (usually a while/for loop), and only until the desired speed is achieved, as optimizing your whole code will quickly run you out of tokens for no actual gain. (Often, 99% of the time is spent in 1% of the code. Optimizing the rest of the code is pointless).</li><li>Having a stat(1) printh before the end of _update & _draw (or before the flip) that will show you how your game's actual performance is improving (or not) as you're making optimizations is invaluable here.</li><li>If doing an optimization doesn't seem to help actual performance (as measured by the above point's stat(1)), you've probably failed to find the actual problem point, try spending more time on that.</li></ul>Now that you found the code causing the slowdown:<ul><li>You can always remove it if it's not essential. That's one of the only optimizations that will improve your code size and clarity, too!</li><li>Forget about the code for a moment and consider what it's supposed to be doing - what's the fastest way that can be implemented? Can a clever algorithm or data structure be used to avoid pointless calculation?</li><li>For example, pico has a fair(ish) amount of lua memory - 2 MB - a function that has a small (or sometimes not-so-small) set of possible inputs and does slow computations on them can often be replaced with a lookup table (which could be computed at startup time, if too large to fit in the code).</li><li>Now onto the micro-optimizations:</li><li>Function calls cost, so inlining short calls (replacing the calls with the code inside the function) can help performance (in exchange for severely harming code size and clarity - use with care).</li><li>Access to global or non-local variables (locals from other functions) is slower than access to local variables - use local variables instead, if possible. If a global or non-local variable is read multiple times, it'd save cycles to cache it in a local variable first (this helps a bit even if the variable's read twice).</li></ul><h4>Lua cycles</h4>Some standard Lua operation costs: (tested on 0.1.12c)<ul><li>Access to global variables or to local variables from another function: 1 cycle per access. (Only local variables within same function avoid this cost)</li></ul><ul><li>Assignment statement: minimum 1 cycle per assignment, does not combine with other costs. (E.g. 'a=b' and 'a=b+c' both cost only 1 cycle, 'a,b=b,a' costs 2)</li><li>Regular arithmetic operators: 1 cycle (note that <span style="font-style:italic;">x</span><code>^y</code> is excluded - has an additional varying system cost)</li><li>Logical operators: for a chain of N and/or operators, of which K are evaluated (not short-circuited), the cost is K+1 cycles. ('not' is 1 cycle). (E.g. 'a and b and c' costs 1, 2, or 3, depending on how many are evaluated)</li><li>Relational operators: if directly inside an if/while condition: 0 cycle. If directly inside a logical operator: 1 cycle total for all relational operators within that chain of logical operators. If directly inside something else: 2 cycles. (E.g. 'a==b==c' and, 'a==a and b==b and c==c' both cost 4 cycles)</li><li>String concatenation: 3 cycles</li><li>Table element access: 1 cycle</li><li>Table construction: 1+n+L cycles, where n is the number of elements, and L is 1 if some of the elements are list-style (without an explicit key) or otherwise 0. (E.g. {a,b} is 4 cycles, but {[1]=a,[2]=b} is 3 cycles. Funny)</li><li>Function construction: 1 cycle, or 2 cycle if it captures any local or non-local variables.</li><li>Function call: 2+n cycles, where n is the number of arguments. This is regardless of whether the function is accessed through a local or a global.</li><li>Function return: 1+n cycles, where n is the number of return values. This also applies to the implicit "return" at the end of all user-defined functions (which costs 1 cycle).</li><li>If statement: roughly 1 cycle per evaluated if/elseif.</li><li>While loop: roughly 1 cycle per iteration.</li><li>Numeric for loop: 5+n, where n is the number of iterations.</li><li><span style="font-weight:bold;">do … end</span>: 0 cycles</li><li>Metamethod access: 0 cycles (doesn't include cost of the metamethod itself)</li></ul>Lua CPU stats are only updated every 1024 cycles.<h4>Functions that add negative Lua cycles</h4>Some functions have negative Lua cycles associated with them that get subtracted from the Lua cycle count by the PICO-8 runtime. This mechanism allows PICO-8 to make these functions artificially cheaper.

For instance, [[shl|<code>shl(x,y)</code>]] should cost 4 cycles because it is a function call with two arguments, but each call subtracts 3 cycles from the Lua cycle counter, for a total of 1 cycle.

The table below lists functions that have their total cost tweaked in this way.{|
| Function || Adjusted cycles || Notes
|-
| [[peek|<code>peek(x)</code>]], [[peek2|<code>peek2(x)</code>]], [[peek4|<code>peek4(x)</code>]] || <code>1</code> || only when called with 1 argument
|-
| [[poke|<code>poke(x,y)</code>]] || <code>1</code> || only when called with 2 arguments
|-
| [[poke2|<code>poke2(x,y)</code>]], [[poke4|<code>poke4(x,y)</code>]] || <code>2</code> || only when called with 2 arguments
|-
| [[band|<code>band(x,y)</code>]], [[bor|<code>bor(x,y)</code>]], [[bxor|<code>bxor(x,y)</code>]] || <code>1</code> || only when called with 2 arguments
|-
| [[bnot|<code>bnot(x)</code>]] || <code>1</code> || only when called with 1 argument
|-
| [[shl|<code>shl(x,y)</code>]], [[shr|<code>shr(x,y)</code>]], [[lshr|<code>lshr(x,y)</code>]]
|| <code>1</code> || only when called with 2 arguments
|-
| [[rotl|<code>rotl(x,y)</code>]], [[rotr|<code>rotr(x,y)</code>]] || <code>1</code> || only when called with 2 arguments
|-
| [[flr|<code>flr(x)</code>]], [[ceil|<code>ceil(x)</code>]] || <code>1</code> || only when called with 1 argument
|}<h4>Functions that add Lua cycles</h4>A few functions consume additional Lua cycles (in addition to the standard cost of 2+(#arguments)):

(Measured on PICO-8 1.1.12d RC10){|
| Function || Additional cycles || Notes
|-
| <code>[[Add|add()]]</code> || 5 || 
|-
|<code>[[All|all()]]</code>
|???
|TODO - Results wildly unclear
|-
|[[Del|del()]]
|if n-s > 0 then 4+(2+n-s)*3 else 4
|n is the size of the table.
s is 1 if deleted and 0 otherwise.
|-
|[[Foreach|foreach()]]
|if n > 0 then 2+n*(5+c) else 12
|n is the size of the table.
c is the cost of the function passed to the foreach.
|-
|[[Tostr|tostr()]]
|if table then 14 else 9
|table is true if the argument is a table.
|-
|[[Printh|printh()]]
|16
|
|-
|[[Menuitem|menuitem()]]
|16
|
|}The following functions neither add nor subtract cycles, and cost the standard amount:

[[sgn|<code>sgn()</code>]], [[abs|<code>abs()</code>]]<code>, [[Sin|sin()]], [[Cos|cos()]],</code> <code>[[Atan2|atan2()]].</code>

[[Min|min()]], [[Max|max()]], [[Mid|mid()]]<code>.</code>

<code>[[Camera|camera()]], [[Clip|clip()]], [[Cursor|cursor()]], [[Fillp|fillp()]], [[Pal|pal()]], [[Palt|palt()]].</code>

[[Fget|<code>fget()</code>]]<code>, [[Fset|fset()]], [[Mget|mget()]], [[Mset|mset()]], [[Pget|pget()]], [[Pset|pset()]], [[Sget|sget()]], [[Sset|sset()]].</code>

[[Cocreate|cocreate()]], [[Coresume|coresume()]], [[Costatus|costatus()]], [[Dget|dget()]], [[Dset|dset()]], [[Time|time()]], [[Type|type()]].

[[Getmetatable|getmetatable()]], [[Setmetatable|setmetatable()]], [[Pairs|pairs()]], [[Next|next()]], [[Rawget|rawget()]], [[Rawset|rawset()]].

[[Sub|sub()]], [[Tonum|tonum()]].<h4>System cycles</h4>A few functions consume system cycles. Note that they will add to their standard Lua cycle cost.

System CPU stats are updated after each call.

Here is the list, most measured on PICO-8 1.1.11g:{|
| Function || Cycles || Notes
|-
| [[cls|<code>cls()</code>]] || <code>1024</code> || same cost as [[rectfill|<code>rectfill</code>]] of same size
|-
| [[print|<code>print()</code>]] || <code>2+n*8</code>
|<code>n</code> is the number of characters in the string, even those not rendered

spaces, newlines, and double-width glyphs each count as one character
|-
| [[spr|<code>spr()</code>]] || n
|<code>n</code> is the number of pixels drawn, including transparent pixels (width × height of the sprite rectangle)

cost is 0 if first argument is outside the [0, 255] range
|-
| [[sspr|<code>sspr()</code>]] || <code>n</code>
|<code>n</code> is the number of pixels drawn, including transparent pixels (width × height of the destination rectangle)
|-
| [[rect|<code>rect()</code>]] || <code>max(1,2*ceil(a/4)) + max(0,2*ceil(b/2-1))</code>
|
Where:
*<code>w,h = abs(x2-x1),abs(y2-y1) </code>

*<code>a,b = max(w,h),min(w,h)</code>
|-
| [[rectfill|<code>rectfill()</code>]] || <code>max(1,flr(n/16))</code> || <code>n</code> is the number of pixels drawn (width × height)
|-
| [[circ|<code>circ()</code>]] || <code>2+n*4</code>
|warning: that formula is incomplete for clipped circles
|-
| [[circfill|<code>circfill()</code>]] || <code>n*flr((n+9)/4)</code>
|warning: that formula is incomplete for clipped circles
|-
| [[line|<code>line()</code>]] || <code>ceil(n/2)</code> || <code>n</code> is the number of pixels drawn; there is an additional cost of <code>1</code> if at least one pixel had to be clipped
|-
| [[map|<code>map()</code>]] / [[mapdraw|<code>mapdraw()</code>]] || <code>max(1,n*64)</code>
|<code>n</code> is the number of sprites rendered; only cells that are not zero in the map are considered
|-
| [[music|<code>music()</code>]] || <code>16</code> || no cost if no argument
|-
| [[sfx|<code>sfx()</code>]] || <code>16</code> || no cost if no argument
|-
| [[memcpy|<code>memcpy()</code>]] || <code>n+1</code>
|<code>n</code> is the number of bytes copied
|-
| [[memset|<code>memset()</code>]] || <code>max(1,ceil(n/2))</code>
|<code>n</code> is the number of bytes set
|-
|[[Cstore|cstore()]]
|max(1, n*64)
|n is the number of bytes stored.
|-
| [[reload|<code>reload()</code>]] || <code>max(1,n*8)</code>
|<code>n</code> is the number of bytes reloaded
|-
| [[btn|<code>btn()</code>]] || <code>4</code> || no cost if no argument
|-
| [[btnp|<code>btnp()</code>]] || <code>4</code> || no cost if no argument
|-
| [[rnd|<code>rnd()</code>]] || <code>4</code> ||
|-
|[[Srand|srand()]]
|8
|
|-
| [[sqrt|<code>sqrt()</code>]] || <code>24</code> || only <code>16</code> if argument is zero
|-
| <code>x^y</code> || <code>8*(n+1)</code> || <code>n</code> is the position of the last fractional bit in <code>y</code>; for instance, cost is <code>8</code> for any integer such as <code>y == 13</code>, and is <code>8*3</code> for <code>y == 1.25</code>
|-
| [[stat|<code>stat()</code>]] || <code>16</code> ||
|}<hr style="height: 0.0625em;background-color: #888;" /><h2>Moon Recon</h2>{{Game|title = Moon Recon|imagecaption = Title/startup screen|first = BGelais/Lostcadesoft|second = Action|third = One|image = Moon recon.jpg|imagewidth = 224}}<h4>Description</h4>The player's ship moves through a constantly scrolling moon landscape while reacting to dangers.<h4>Rules</h4><ul><li>Moving right will increase the speed of the player's ship while moving left will decrease it.  There is no way to stop moving.</li><li>Dangers come from above with U. F. O.s that shoot at the player while large rocks appear in their path.</li><li>Shooting upwards can destroy U. F. O.s while shooting forward (/to the right of the player's ship) will destroy rocks.</li><li>If the player's ship is hit by a bomb dropped by a U. F. O. or collides with a rock it will destroy their ship and the game will end when there are no more remaining ships.</li></ul><h4>Controls</h4><ul><li>Use the z key to start a game.</li><li>Use the p or enter keys to pause the game or reset the cart.</li><li>Use the left and right arrow keys to move.</li><li>Use the z key to fire upwards.</li><li>Use the x key to fire to the right.</li></ul><h4>Links</h4>[https://www.lexaloffle.com/bbs/?tid=33608 Play game]



<hr style="height: 0.0625em;background-color: #888;" /><h2>User blog:SparrowhawkJr</h2>#REDIRECT [[User blog:The5thPentagonMade]]<hr style="height: 0.0625em;background-color: #888;" /><h2>User blog:SparrowhawkJr/Keyboard Shortcuts in Mac</h2>#REDIRECT [[User blog:The5thPentagonMade/Keyboard Shortcuts in Mac]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Poke2</h2>{{ApiReference
|name=poke2
|shortdesc=Writes a 16-bit value to two consecutive memory locations.
|addr||The address of the first memory location.
|val||The 16-bit value.
}}
The <code>poke2()</code> function writes a 16-bit value to two consecutive bytes in the addressable memory region (0x0000-0x7fff). The value is interpreted in the [https://en.wikipedia.org/wiki/Endianness Little Endian] representation, which stores the lowest 8 bits in the first byte.

See [[Memory]] for information about the memory layout.<h4>Examples</h4><pre>
poke2(0x4300, 0x0cff)

b0 = peek(0x4300)  -- 0xff
b1 = peek(0x4301)  -- 0x0c
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Peek2|<code>peek2()</code>]]</li><li>[[Peek4|<code>peek4()</code>]]</li><li>[[Poke4|<code>poke4()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Peek2</h2>{{ApiReference
|name=peek2
|shortdesc=Reads a 16-bit value from two consecutive memory locations.
|addr||The address of the first memory location.
}}
The <code>peek2()</code> function reads a 16-bit value from two consecutive bytes in the addressable memory region (0x0000-0x7fff). The value is interpreted in the [https://en.wikipedia.org/wiki/Endianness Little Endian] representation, which stores the lowest 8 bits in the first byte.

See [[Memory]] for information about the memory layout.<h4>Examples</h4><pre>
poke(0x4300, 0xff)
poke(0x4301, 0x0c)

b = peek2(0x4300)  -- 0x0cff = 3327
</pre><h4>See also</h4><ul><li>[[Memory]]</li><li>[[Peek|<code>peek()</code>]]</li><li>[[Poke|<code>poke()</code>]]</li><li>[[Poke2|<code>poke2()</code>]]</li><li>[[Peek4|<code>peek4()</code>]]</li><li>[[Poke4|<code>poke4()</code>]]</li><li>[[Memcpy|<code>memcpy()</code>]]</li><li>[[Reload|<code>reload()</code>]]</li><li>[[Cstore|<code>cstore()</code>]]</li><li>[[Memset|<code>memset()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rawset</h2>{{ApiReference
|name=rawset
|shortdesc=Write to a table member, bypassing metamethods
|tbl||The table whose member to modify.
|member||The member to modify.
|value||The member's new value.
}}
When creating things like class objects, one often overrides metamethods like <code>__index</code> and <code>__newindex</code> with custom code, but might then need to write directly to the table without going through those overrides. This can be done with <code>rawset()</code>.<h4>See also</h4><ul><li>[[Setmetatable|<code>setmetatable()</code>]]</li><li>[[Getmetatable|<code>getmetatable()</code>]]</li><li>[[Rawset|<code>rawset()</code>]]</li><li>[[Rawget|<code>rawget()</code>]]</li><li>[[Rawlen|<code>rawlen()</code>]]</li><li>[[Rawequal|<code>rawequal()</code>]]</li><li>[[Metatables]]</li><li>[[Tables]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rawget</h2>{{ApiReference
|name=rawget
|shortdesc=Read a table member, bypassing metamethods
|tbl||The table whose member to read.
|member||The member to read.
}}
When creating things like class objects, one often overrides metamethods like <code>__index</code> and <code>__newindex</code> with custom code, but might then need to read directly from the table without going through those overrides. This can be done with <code>rawget()</code>.<h4>See also</h4><ul><li>[[Setmetatable|<code>setmetatable()</code>]]</li><li>[[Getmetatable|<code>getmetatable()</code>]]</li><li>[[Rawset|<code>rawset()</code>]]</li><li>[[Rawget|<code>rawget()</code>]]</li><li>[[Rawlen|<code>rawlen()</code>]]</li><li>[[Rawequal|<code>rawequal()</code>]]</li><li>[[Metatables]]</li><li>[[Tables]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rawlen</h2>{{ApiReference
|name=rawlen
|shortdesc=Get the length of a table, bypassing metamethods
|tbl||The table whose length to retrieve.
}}
When creating things like custom containers, one often overrides the <code>__len</code> metamethod with custom code, but might then need to check the true length of the underlying table without going through that override. This can be done with <code>rawlen()</code>.<h4>See also</h4><ul><li>[[Setmetatable|<code>setmetatable()</code>]]</li><li>[[Getmetatable|<code>getmetatable()</code>]]</li><li>[[Rawset|<code>rawset()</code>]]</li><li>[[Rawget|<code>rawget()</code>]]</li><li>[[Rawlen|<code>rawlen()</code>]]</li><li>[[Rawequal|<code>rawequal()</code>]]</li><li>[[Metatables]]</li><li>[[Tables]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Rawequal</h2>{{ApiReference
|name=rawequal
|shortdesc=Compare two tables, bypassing metamethods
|tbl1||A table to compare.
|tbl2||Another table to compare.
}}
When creating things like custom containers and objects, one often overrides the <code>__eq</code> metamethod with custom code, possibly to to do deep comparisons or to omit certain elements, but might then need to check for regular equality without going through that override. This can be done with <code>rawequal()</code>.<h4>See also</h4><ul><li>[[Setmetatable|<code>setmetatable()</code>]]</li><li>[[Getmetatable|<code>getmetatable()</code>]]</li><li>[[Rawset|<code>rawset()</code>]]</li><li>[[Rawget|<code>rawget()</code>]]</li><li>[[Rawlen|<code>rawlen()</code>]]</li><li>[[Rawequal|<code>rawequal()</code>]]</li><li>[[Metatables]]</li><li>[[Tables]]</li><li>[[Lua]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Config</h2>{{CommandReference
|name=config
|shortdesc=Modify the configuration settings.
|setting|optional|The name of the setting, e.g. <code>theme</code>. If absent, available settings are listed.
|value|optional|The new value for the setting. If absent, the current value is printed.
}}

This is a way to modify the PICO-8 configuration live at runtime, within the PICO-8 environment. Changes will be saved to PICO-8's [[configuration]] file.

Run the command with no arguments to see the names of the available settings.

Run the command with the name of a setting to see its current value and info on how to change the value.

Run the command with both the name of a setting and a new value to change the setting.<h4>Examples</h4>At the Pico-8 prompt:
<pre>
> config tab_width
config tab_width [width]
current tab_width: 1

> config tab_width 2
set tab_width: 2
</pre><h4>See also</h4><ul><li>[[Keyconfig|<code>keyconfig</code>]]</li><li>[[Configuration]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Next</h2>{{ApiReference
|name=next
|shortdesc=A stateless iterator of key-value pairs for all elements in a table.
|tbl||The table.
|key|optional|The current key.
}}
The <code>next()</code> function is the stateless iterator that underpins [[Pairs|<code>pairs()</code>]], as used in <code>for k,v in pairs(t)</code> to iterate over all elements in a table. It takes the table and the current key and returns the next key/value pair, or nil if there isn't one. The key passed in may be omitted or nil to retrieve the first key/value pair of the table.

Under normal conditions, <code>next()</code> is not referred to directly, instead being supplied under the hood by <code>pairs()</code>. However, it has its uses. For instance, it can be called with just the table to get the first key/value pair, and thus determine quickly whether nor not the table is empty:

<pre>
function empty(tbl)
  -- note that we compare to nil, since 'false' is a legal key
  return next(tbl) == nil
end
</pre>

As noted with <code>pairs()</code>, this will iterate over every value in the table, not just those with sequential indexes. It can return keys and values for tables being used as mappings (dictionaries) or objects.

Also note that the concept of "next" here is based on the next value in the internal representation of the table (an unordered hash table). This does not guarantee the order in which the results are returned, only that you will see all entries in the table exactly once.<h4>Examples</h4><pre>
t = {n=42, x=100, y=200}

-- write "for k, v in pairs(t) do ... end" manually
local k, v
while true do
  k,v = next(t, k)
  if(k == nil) break
  print(k..': '..v)
end

-- output:
-- x: 100
-- y: 200
-- n: 42
</pre><h4>See also</h4><ul><li>[[Lua]]</li><li>[[Tables]]</li><li>[[Add|<code>add()</code>]]</li><li>[[All|<code>all()</code>]]</li><li>[[Del|<code>del()</code>]]</li><li>[[Foreach|<code>foreach()</code>]]</li></ul>
<hr style="height: 0.0625em;background-color: #888;" /><h2>User blog:Felice Enellen/A trick I just came up with</h2>Sometimes you want to encode a nonzero signed offset into an unsigned range, e.g. [-8..-1,+1..+8] into [0..7,8..15]. Normally this requires some conditional decoding to accommodate the gap in the middle where you didn't encode 0:

<pre>
-- decode [0..7,8..15] -> -[8..-1,+1..+8]
if value>7 then
  offset = value-7   -- +1..+8
else
  offset = value-8   -- -8..-1
end
</pre>

Or, more concisely:

<pre>
-- decode [0..7,8..15] -> -[8..-1,+1..+8]
offset = value>7 and value-7 or value-8
</pre>

The concise code above is 11 tokens in PICO-8. We can do better with some PICO-8 fixed-point math trickery:

<pre>
-- decode [0..7,8..15] -> [-8..-1,+1..+8]
offset = flr(value*0x1.0001-0x7.0008)
</pre>

What we're doing here is akin to walking down a sidewalk with a stride just a tiny bit longer than the distance between the lines on the sidewalk, and then adjusting our starting position so that when we get to the "middle" we step from just before one line to just after the next line, never actually touching the section between those lines, which is where our non-existent "0" value is.

This code is only 7 tokens. The only thing that needs to change for a different range is the constant that's subtracted. The integer bits should be the encoded value corresponding to -1 (7 in this case) and the fractional bits should be the encoded value corresponding to +1 (8 in this case).

Note that your range doesn't actually have to be balanced or a power-of-two in width. You could, for instance, encode [-20..-1,+1..+80] into [0..19,20..99] and then decode it like this:

<pre>
-- decode [0..19,20..99] -> [-20..-1,+1..+80]
-- remember we're writing in hex here, 
-- so 19 becomes 0x13 and 20 becomes 0x14
offset = flr(value*0x1.0001-0x13.0014)
</pre>


<span style="font-weight:bold;">Bonus:</span>

Just for fun, here's how you might do it in a C-style language:

<pre>
// decode [0..19,20..99] -> [-20..-1,+1..+80]
offset = (value * 0x10001 - 0x130014) >> 16;
</pre>

This is basically just doing inline fixed-point math, which is how PICO-8's numbers work under the hood.
<hr style="height: 0.0625em;background-color: #888;" /><h2>Internal API Functions</h2>This page is a clearinghouse for undocumented & internal API functions. As content here is elaborated on and fleshed out, it could be promoted to separate pages if it describes an API that's considered useful enough.<h4>Warning</h4>As these are internal functions, they cannot be relied on for a game. Their functionality <span style="font-weight:bold;">will</span> change or be removed in future versions. Still, some may find a pragmatic use for them in tools or demos. Just be aware that you use them at your own risk.<h4>Message to fellow editors</h4>Remember that relative neophytes will discover this and other undocumented API pages. PICO-8 is, for many, a learning platform. They are not yet aware of what it means to use an undocumented API function, and what risks are associated. It's your responsibility as their indirect mentor to help them understand that such functions are not actually <span style="font-style:italic;">intended</span> to be used directly, even if they <span style="font-style:italic;">are</span> visible at runtime, and should only be used with understanding and care.

Please be sure to include a warning similar to the one above on any functions that you break out into their own pages. This is the basic template used for existing pages, which can be adapted as necessary:

<!-- just using an inset dark table to offset the sample a bit. 
     this is a one-off, so I don't feel too bad about it being kinda kludgey. :P
     --Felice -->{| style="background: #202020; margin-left: 1em; margin-right: 1em; padding-left: 0.5em; padding-right: 0.5em;"
| <code>== Warning ==

As an undocumented function, &lt;code&gt;</code><span style="color: #ee7070;"><code>INSERT_FUNCTION_NAME_HERE</code></span><code>()&lt;/code&gt; cannot be relied on for a game. Its functionality may change or be removed in future versions. Still, some may find a pragmatic use for it in tools or demos. Just be aware that you use it at your own risk.</code>
|}For functions and functionality that are <span style="font-style:italic;">clearly</span> intended only to <span style="font-style:italic;">support</span> the outer layer of the PICO-8 Lua wrapper, it'd probably be good to go farther and suggest strongly that they not be used <span style="font-style:italic;">at all</span>, explaining that this documentation is only for the sake of <span style="font-style:italic;">understanding</span> the inner workings of PICO-8.

Also please remember to include the page in {{Category:Undocumented API}}.

Thanks!<h4>Internal API Functions</h4><ul><li>bbsreq()<br />​​​​​produces red warning popup at the bottom "can not connect to bbs req host"<br />behavior only happens once per pico8 restart<br />C++ definition includes a call to ​​​​​​add_api_function_name bbsreq</li><li>radio()<br />has no obivous effect<br />returns `nil, 0`</li><li>set_draw_slice(n[,vertical])<br />tells voxatron what Z layer to draw the pico8 screen at(?)<br />n=0-63, or 0-127 if vertical is true<br />can be called more than once per frame for 3d effects in voxatron?<br />This is now documented at [[Set draw slice]] as Undocumented API for PICO-8, since it IS documented on the voxatron side. <!-- I'll leave it to the original editors to decide whether or not to leave this info here. --Felice --></li><li>_startframe()<br />effect is currently same as holdframe's<br />used in the internal p8 header _mainloop function<br />called after first _update_buttons(), before first _mark_cpu(0)<br />global only, no closure</li><li>_get_menu_item_selected(n)<br />returns true or false if the n-th menu item is selected (n in [1..5]), nil for invalid n<br />used automatically by _mainloop()</li><li>_update_buttons(n)<br />used in the internal [[Header|p8 header _mainloop]] function<br />n affects the value returned by time().<br />Note this already has its own Undocumented API page at [[Update buttons]], due to its common use in custom main loops for tweetcarts, which zep does not seem to object to to.</li><li>_update_framerate()<br />used in the internal [[Header|p8 header _mainloop]] function<br />called after flip()</li><li>_set_mainloop_exists(n)<br />used in the internal p8 header<br />called 1-2 times. n=0 first, then n=1 if _mainloop exists, otherwise n=2 and then _mainloop is created<br />if called with n=2, time() no longer advances automatically.</li><li>_set_fps(n)<br />used in the internal p8 header<br />called once based on the existence of _update60, n=30 or n=60, though technically it also accepts 15<br />value used throughout pico8 code<br />Note this already has its own Undocumented API page at [[Set fps]], due to its common use in custom main loops for tweetcarts, which zep does not seem to object to to.</li><li>_mark_cpu(n)<br />used in the internal p8 header _mainloop function<br />called with n=0 before _update() or _update60, n=1 after last update in mainloop, n=2 after _draw()<br />no obvious effect, possibly related to stat(1)?</li><li>_set_paused(n)<br />code seems to want a number parameter<br />no obvious effect (tested with n=0, 1, -32768, 32767, 1/32768, true, false)</li><li>__refund_cpu__(n)<br />used in the internal p8 header<br />n=-16 and n=-17 in header<br />no obvious effect, tested in/after high-cpu code<br />function has checks in place before passing to lua_spend_cpu</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Header</h2>PICO-8 injects a header and footer into every lua program before running it. These snippets implement some API calls and defines the creation and handling of the main game loop and functions. As of 0.1.12c they are as follows:

Header:

<pre>
_pausemenu = {}

function menuitem(index, label, callback)
 if (index < 1 or index > 5) then return end
 _pausemenu[index] = {}
 _pausemenu[index].label = label
 _pausemenu[index].callback = callback
 _menuitem(index, label)
end

function all(c)
 if (c == nil or #c == 0) then return function() end end
 local i = 1
 local li = nil
 __refund_cpu__(-16)
 return function()
  if (c[i] == li) then i = i + 1 end
  while (c[i] == nil and i <= #c) do i = i + 1 end
  li = c[i]
  __refund_cpu__(-17)
  return li
 end
end

function foreach(c, _f) for i in all(c) do _f(i) end end

function count(c)
 local total = 0
 for i = 1, #c do if c[i] ~= nil then total = total + 1 end end
 return total
end

function add(c, i)
 if (c == nil) then return end
 local num = #c
 c[num + 1] = i
 return i
end

function del(c, i)
 if (c == nil) then return end
 local num = #c
 if (num < 1) then return end
 local j
 local k
 for j = 1, num do
  if c[j] == i then
   for k = j, num - 1 do c[k] = c[k + 1] end
   c[num] = nil
   return i
  end
 end
end
</pre>

Unknown:
<pre>
if (_mainloop) then
 _mainloop()
else
 print("no _mainloop()")
end
</pre>

Footer:
<pre>
_end_of_program = 1

if (_init ~= nil) then _init() end

_set_mainloop_exists(0)

if (_mainloop ~= nil) then _set_mainloop_exists(1) end

if (_update60 ~= nil) then
 _set_fps(60)
 _update = nil
else
 _set_fps(30)
end

if (_mainloop == nil and (_draw ~= nil or _update ~= nil or _update60 ~= nil)) then
 _set_mainloop_exists(2)
 _mainloop = function()
  while (true) do
   _update_buttons(_update60 and 1 or 2)
   _startframe()
   if (stat(7) == 60) then
    _mark_cpu(0)
    _update60()
   elseif (stat(7) == 30 and _update60) then
    _update60()
    _update_buttons(1)
    _mark_cpu(0)
    _update60()
   elseif (stat(7) == 30 and _update) then
    _mark_cpu(0)
    _update()
   elseif (stat(7) == 15 and _update) then
    _update()
    _update_buttons(2)
    _mark_cpu(0)
    _update()
   end
   _mark_cpu(1)
   if (_draw ~= nil) then _draw() end
   _mark_cpu(2)
   flip()
   _update_framerate()
   for i = 1, 5 do
    if (_get_menu_item_selected(i)) then
     _pausemenu[i].callback()
    end
   end
  end
 end
end

if (_mainloop ~= nil) then _mainloop() end
</pre>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Undocumented API Functions</h2>#REDIRECT [[Internal API Functions]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Set draw slice</h2>{{ApiReference
|name=set_draw_slice
|shortdesc=Set the target voxel plane for PICO-8 draw code running inside of Voxatron.
|slice||The target slice, normally 0..63, but 0..127 if <code>vertical</code> is true.
|vertical|optional|Option to render vertically into X,Z slices instead of X,Y slices.
}}
When running PICO-8 draw code in Voxatron, this function may be used to set the Z value at which PICO-8 pixels should be drawn as voxels. It may be called more than once per frame to produce 3-dimensional shapes and effects.

If <code>vertical</code> is set to <code>true</code>, this function instead sets the Y value that PICO-8 pixels should be drawn into a vertical X,Z slice. Note however that, because Voxatron's volume is 128x128x64, these slices will only be 128x64, rather than the usual 128x128 of X,Y slices.<h4>Attention</h4>This function is <span style="font-style:italic;">only</span> documented in Voxatron, and it is <span style="font-style:italic;">only</span> used when PICO-8 code is running inside of Voxatron. It serves no purpose when running inside of PICO-8 and does <span style="font-style:italic;">not</span> normally need to be called.<h4>Examples</h4><pre>
-- in voxatron, draw an 8x8x8 rainbow cube slice-by-slice in z,
-- left of the middle of the visible 128x128x64 volume
for i=8,15 do
  set_draw_slice(28+i)
  rectfill(54, 60, 61, 67, i)
end

-- now draw another 8x8x8 rainbow cube slice-by-slice in y,
-- to the right of the first cube
for i=8,15 do
  set_draw_slice(60+i, true)
  rectfill(66, 28, 73, 35, i)
end
</pre>
<hr style="height: 0.0625em;background-color: #888;" /></body></html>er or not to leave this info here. --Felice --></li><li>_startframe()<br />effect is currently same as holdframe's<br />used in the internal p8 header _mainloop function<br />called after first _update_buttons(), before first _mark_cpu(0)<br />global only, no closure</li><li>_get_menu_item_selected(n)<br />returns true or false if the n-th menu item is selected (n in [1..5]), nil for invalid n<br />used automatically by _mainloop()</li><li>_update_buttons(n)<br />used in the internal [[Header|p8 header _mainloop]] function<br />n affects the value returned by time().<br />Note this already has its own Undocumented API page at [[Update buttons]], due to its common use in custom main loops for tweetcarts, which zep does not seem to object to to.</li><li>_update_framerate()<br />used in the internal [[Header|p8 header _mainloop]] function<br />called after flip()</li><li>_set_mainloop_exists(n)<br />used in the internal p8 header<br />called 1-2 times. n=0 first, then n=1 if _mainloop exists, otherwise n=2 and then _mainloop is created<br />if called with n=2, time() no longer advances automatically.</li><li>_set_fps(n)<br />used in the internal p8 header<br />called once based on the existence of _update60, n=30 or n=60, though technically it also accepts 15<br />value used throughout pico8 code<br />Note this already has its own Undocumented API page at [[Set fps]], due to its common use in custom main loops for tweetcarts, which zep does not seem to object to to.</li><li>_mark_cpu(n)<br />used in the internal p8 header _mainloop function<br />called with n=0 before _update() or _update60, n=1 after last update in mainloop, n=2 after _draw()<br />no obvious effect, possibly related to stat(1)?</li><li>_set_paused(n)<br />code seems to want a number parameter<br />no obvious effect (tested with n=0, 1, -32768, 32767, 1/32768, true, false)</li><li>__refund_cpu__(n)<br />used in the internal p8 header<br />n=-16 and n=-17 in header<br />no obvious effect, tested in/after high-cpu code<br />function has checks in place before passing to lua_spend_cpu</li></ul><hr style="height: 0.0625em;background-color: #888;" /><h2>Header</h2>PICO-8 injects a header and footer into every lua program before running it. These snippets implement some API calls and defines the creation and handling of the main game loop and functions. As of 0.1.12c they are as follows:

Header:

<pre>
_pausemenu = {}

function menuitem(index, label, callback)
 if (index < 1 or index > 5) then return end
 _pausemenu[index] = {}
 _pausemenu[index].label = label
 _pausemenu[index].callback = callback
 _menuitem(index, label)
end

function all(c)
 if (c == nil or #c == 0) then return function() end end
 local i = 1
 local li = nil
 __refund_cpu__(-16)
 return function()
  if (c[i] == li) then i = i + 1 end
  while (c[i] == nil and i <= #c) do i = i + 1 end
  li = c[i]
  __refund_cpu__(-17)
  return li
 end
end

function foreach(c, _f) for i in all(c) do _f(i) end end

function count(c)
 local total = 0
 for i = 1, #c do if c[i] ~= nil then total = total + 1 end end
 return total
end

function add(c, i)
 if (c == nil) then return end
 local num = #c
 c[num + 1] = i
 return i
end

function del(c, i)
 if (c == nil) then return end
 local num = #c
 if (num < 1) then return end
 local j
 local k
 for j = 1, num do
  if c[j] == i then
   for k = j, num - 1 do c[k] = c[k + 1] end
   c[num] = nil
   return i
  end
 end
end
</pre>

Unknown:
<pre>
if (_mainloop) then
 _mainloop()
else
 print("no _mainloop()")
end
</pre>

Footer:
<pre>
_end_of_program = 1

if (_init ~= nil) then _init() end

_set_mainloop_exists(0)

if (_mainloop ~= nil) then _set_mainloop_exists(1) end

if (_update60 ~= nil) then
 _set_fps(60)
 _update = nil
else
 _set_fps(30)
end

if (_mainloop == nil and (_draw ~= nil or _update ~= nil or _update60 ~= nil)) then
 _set_mainloop_exists(2)
 _mainloop = function()
  while (true) do
   _update_buttons(_update60 and 1 or 2)
   _startframe()
   if (stat(7) == 60) then
    _mark_cpu(0)
    _update60()
   elseif (stat(7) == 30 and _update60) then
    _update60()
    _update_buttons(1)
    _mark_cpu(0)
    _update60()
   elseif (stat(7) == 30 and _update) then
    _mark_cpu(0)
    _update()
   elseif (stat(7) == 15 and _update) then
    _update()
    _update_buttons(2)
    _mark_cpu(0)
    _update()
   end
   _mark_cpu(1)
   if (_draw ~= nil) then _draw() end
   _mark_cpu(2)
   flip()
   _update_framerate()
   for i = 1, 5 do
    if (_get_menu_item_selected(i)) then
     _pausemenu[i].callback()
    end
   end
  end
 end
end

if (_mainloop ~= nil) then _mainloop() end
</pre>
<hr style="height: 0.0625em;background-color: #888;" /><h2>Undocumented API Functions</h2>#REDIRECT [[Internal API Functions]]<hr style="height: 0.0625em;background-color: #888;" /><h2>Set draw slice</h2>{{ApiReference
|name=set_draw_slice
|shortdesc=Set the target voxel plane for PICO-8 draw code running inside of Voxatron.
|slice||The target slice, normally 0..63, but 0..127 if <code>vertical</code> is true.
|vertical|optional|Option to render vertically into X,Z slices instead of X,Y slices.
}}
When running PICO-8 draw code in Voxatron, this function may be used to set the Z value at which PICO-8 pixels should be drawn as voxels. It may be called more than once per frame to produce 3-dimensional shapes and effects.

If <code>vertical</code> is set to <code>true</code>, this function instead sets the Y value that PICO-8 pixels should be drawn into a vertical X,Z slice. Note however that, because Voxatron's volume is 128x128x64, these slices will only be 128x64, rather than the usual 128x128 of X,Y slices.<h4>Attention</h4>This function is <div style="font-style:italic;">''</div>only<div style="font-style:italic;">''</div> documented in Voxatron, and it is <div style="font-style:italic;">''</div>only<div style="font-style:italic;">''</div> used when PICO-8 code is running inside of Voxatron. It serves no purpose when running inside of PICO-8 and does <div style="font-style:italic;">''</div>not<div style="font-style:italic;">''</div> normally need to be called.<h4>Examples</h4><pre>
-- in voxatron, draw an 8x8x8 rainbow cube slice-by-slice in z,
-- left of the middle of the visible 128x128x64 volume
for i=8,15 do
  set_draw_slice(28+i)
  rectfill(54, 60, 61, 67, i)
end

-- now draw another 8x8x8 rainbow cube slice-by-slice in y,
-- to the right of the first cube
for i=8,15 do
  set_draw_slice(60+i, true)
  rectfill(66, 28, 73, 35, i)
end
</pre>
<hr style="height: 0.0625em;background-color: #888;" /></body></html>